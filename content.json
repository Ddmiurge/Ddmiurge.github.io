{"meta":{"title":"Ddmiurge's blog","subtitle":"","description":"","author":"Ddmiurge","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-09-05T04:41:25.000Z","updated":"2021-09-05T05:06:18.856Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2021-09-05T04:40:08.000Z","updated":"2021-09-05T05:05:42.030Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"悲惨人生","slug":"悲惨人生","date":"2023-09-10T16:00:00.000Z","updated":"2023-09-16T02:55:50.799Z","comments":true,"path":"2023/09/11/悲惨人生/","link":"","permalink":"http://example.com/2023/09/11/%E6%82%B2%E6%83%A8%E4%BA%BA%E7%94%9F/","excerpt":"","text":"为什么人生总是痛苦多欢乐少呢如果能让我苦痛而悲惨的人生重来，那我一定不会选择暑期实训 第一周：噩梦的铺垫​ 鼠鼠暑期实训的第一周就不同寻常，一个悲剧的故事往往会有一个悲伤的开始。我在暑期实训开始的第一天上午就因为国际交流而请假了。在我们暑期实训的这一个小组里面。有两位同学和我在上同一个国际交流。我们组内的还有一位同学在上另外一个国际交流，这意味着我们这个小组五个人有四个人经常不在。 ​ 为了方便叙事，我简单列一下我们组员： A: 以前带我拿竞赛分的超级巨佬，比我大一届的半个老乡，唯一没有国际交流的人 B: 以前有过大作业合作经历的同一届学生，和我上同一个国际交流 C: 组长，在上另一个国际交流，自称相关课程完全没有接触过 D: 一个比我大一届的学长，在上同一届国际交流 ​ 星期一国际交流结束后的上午我没有去，下午我才是第一次见到所有组员，和C,D都是在这个时候第一次见面。 ​ 在这个时候我知道了C是相关的课程一点都没学过（这不能怪ta,我们这种实验性质的学院排课有问题）。后来经过短暂的讨论，我们决定让C来负责后端。后端老师最开始讲的，而且做过的觉得后端相对而言要简单一些所以说就让C来做后端了(应该问题不大吧，只是取数据传过来)。 ​ 第一周的工作时写需求分析，概要设计文档，鼠鼠的任务主要是画一些前端的设计图，还算轻松，划划水。 ​ 和D商量让他去做主页的设计，我来弄对比页的设计。 ​ 好些文档我都在复制粘贴划水，心想虽然四个人有国际交流，但是大家好像都能做点东西（至少写文档的时候感觉都还行），还算可以。除了天天都要过来签到坐牢意外还算行吧 ​ 第二周：苦痛的开场​ 第二周的前面两天主要是完成详细设计的文档，这个时候开始，D就开始失踪了，连续几天见不到人。然后详细设计文档的时候发现他的主页的设计图，搜索的设计图有些问题，和后端大数据的同学商量之后，我保留了他一张展示的图，然后其他的全部淘汰掉重新设计了。到了星期二的时候，老师因为连续见不到他人已经开始问我们他人呢（值得一提的是，这位老师可能认识完了我们小组所有的人了，D日常不在被记住了，C作为组长除了星期一意外的下午都不在，然后我和AB两个人基本都在）。根据他的解释，是去医院了。 ​ 然后在星期三星期四左右的时候 ，差不多就开始编写代码了。D这个时候倒是出现了，和我讨论分工。此时我对其印象还行，至少其在写文档的时候还算积极，去医院了也能理解。讨论结果是他去照着我画的设计图弄主页先，然后我来弄搜索页。老师的要求是周五前端和后端要完成一个接口的联调，所以说周五的时候我的部分弄好一个接口然后和后端对接就好了，他的之后弄好了再来。 ​ 周五的时候我们联调完了去找老师验收，老师的评价是我zhengdiankaishipin4们组进度太慢了，周末得加班~~（后端是C来弄的，老师看到了连连摇头，AB后来去帮他了，我们此次验收的接口是C弄得后端）~~~。 ​ 不过周末没有加班，我去看奥本海默了，确实是一部好电影，诺兰真的nb 第三周：天之将明，其黑尤烈​ 大的要来了。 ​ 星期一的时候再弄图表的传参，弄了一整天没弄好，搞得我有点心态小小失衡。这个时候D不在，东西也没有交上了让我更加烦躁了。然后到了星期二的时候还是这样。过来和我进行了讨论，我告诉其先不要先别的，把写了的东西先交上来，至少应该让和你合作的人了解到现在你是什么进度。他同意了，但是我还是没有看到他的代码 ​ 到了下午的时候我又催了一次，告诉我说今天晚上应该可以弄好。嗯，晚上应该可以弄好传上来。 ​ 什么都没有我直接忍无可忍了，我在周三上午弄完了图表和界面之后，去看他工作，发现正点开视频看如何跳转页面，给我说正在学怎么弄，我告诉其先把做了的交上来，让我看看进度。于是他终于才用git把东西给传上去了，告诉我说这个主页分成了三个组件来弄。 ​ 呃呃，然后打开一看发现里面就是一坨。。。物理意义上的，全他妈挤在中间了，页头，侧边栏和主体部分都在同一行。。。至于按钮的相应函数这些一个都没有。还问我接下来做什么，于是我让其去负责一个可有可无的非重要的页面的工作 ​ 于是上午剩下来的时间我就把对应函数都写了，可以进行搜索和登录注册了~~（没完全弄好，我传用户id还没弄，然后登录之后登录按钮还在）~~~。晚上国际交流的时候，B帮忙把主页稍微调了一下，至少可以看了 ​ 星期四，还是见不到人，我开始着手全国概览页面，B帮忙处理了一些主页的问题，主要是主页，登陆注册页的美化调整格式，还有就是登陆回来之后把登录和注册按钮给去掉。等到了下午还没有见到人的时候，我心情真的挺差的，也不想写了，弄了一部分过后去找老师验收了。然后被狠狠指出问题了，这么多个组没一个目前就这进度的，不过也说了到时候验收的时候就按三个人的工作量来算~~（C负责的后端一个接口完善了一周，基本上是弄完了大数据的AB两个人弄的）~~~。此时心情更加雪上加霜。不过随后把页面间传参补上了，然后B把美化弄得差不多了以后我心情好了许多了。 ​ 接着我开开心心下班拿出手机一看： D: 哥们，晚上有时间没，能否抽个空，我想问你些代码方面的东西，在XX，有点不太会 ​ 。。。 ​ 老子心情瞬间跌入谷底。欸不是，现在都快弄完了才来问是吧，而且还是下班的时间，喊我来给你辅导。我只能说预见结局了，我不去指导，那么不会做，光明正大不交东西上来，我去指导，做不出来，还是交不上来东西，所以我告诉他有什么问题直接在网上问吧，他就说回寝室问我。我他妈破大防，去便利店买酒，而据同行的B说，我在便利店的时候和D还是前后出来的，不过我没有注意到，蚌。一个晚上也没有看见他问任何东西，鉴定为摆了。 ​ 星期五我已经不想管他了，我把矩阵树图画好后贴在了概览页，然后其他杂七杂八的东西弄差不多了过后一起去找老师验收，还是得到了认可。给出的意见就是让我们把页面加一个侧边栏或者页首栏让这些页面看起来像是在同一个项目里面的。 ​ 第四周：让我们看看接下来会发生什么​ 肝帝B周末把侧边栏加上了，周一就是一点收尾的工作。也是我开始写这篇纪实的日子，现在是周二上午，我确实是没有什么事情要做了，让我们看看接下来会发生些什么。 ​ 续： ​ 现在一切都结束了。说句实话，看了答辩以后，感觉其他组的人确实还是有东西的。给我印象最深刻的组就是那个做视频识别，自动剪辑并投放的那个小组。这个小组是自己带的项目，而且还拉到了投资，看他们的完成度完全不像是这么短的时间内做出来的，而且后续还会继续进行商业化。嗯，确实nb。 ​ 无论如何，折磨已经结束了。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"},{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2022-01-23T06:03:41.186Z","updated":"2022-01-23T13:26:31.205Z","comments":true,"path":"2022/01/23/最小生成树/","link":"","permalink":"http://example.com/2022/01/23/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"MST​ 设$N=(V,E)$是一个连通网，$U$是顶点集$V$的一个非空子集，边$(u,v)$是一个具有最小权值的边，其中$u\\in U,v\\in V-U$则必存在一棵包含边$(u,v)$的最小生成树 Prim思路 将所有的点分为两个点集，一个是已经生成的最小生成树的点集，另外一个是已经在已生成的树里面的点，另一个是还没有生成的树中的点的集合 开始时先随机选择一个点到第一个集合中 每一次选择一条边，这条边的两个顶点分别属于两个集合当中且权值最小，将这条边和点加入到选中的集合中 选择$N-1$条边生成最小生成树 代码P3366 【模板】最小生成树 - 洛谷 上面这道题作为例题了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 5005#define Maxm 200005#define inf 0x3f3f3f3fint dist[Maxn];struct edge&#123; int to; int val;&#125;;vector&lt;edge&gt;G[Maxn];bool vis[Maxn];int main()&#123;#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);#endif int N,M; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=M;i++)&#123; int u,v,z;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;z); G[u].push_back(&#123;v,z&#125;); G[v].push_back(&#123;u,z&#125;); &#125; for(int i=1;i&lt;=N;i++)dist[i]=inf;clr(vis,0); dist[1]=0;vis[1]=1; vector&lt;edge&gt;::iterator iter=G[1].begin(); while(iter!=G[1].end())&#123; edge p=*iter; int v=p.to; dist[v]=min(dist[v],p.val);//注意重边 iter++; &#125; int ans=0; for(int i=1;i&lt;=N-1;i++)&#123; int pos; int minc=inf; for(int j=1;j&lt;=N;j++)&#123; if(minc&gt;dist[j] &amp;&amp; vis[j]==0)&#123; minc=dist[j]; pos=j; &#125; &#125; ans+=minc; vis[pos]=1; iter=G[pos].begin(); while(iter!=G[pos].end())&#123; edge p=*iter; if(dist[p.to]&gt;p.val&amp;&amp;vis[p.to]==0)dist[p.to]=p.val; iter++; &#125; &#125; bool tag=0; for(int i=1;i&lt;=N;i++)&#123; if(vis[i]==0)&#123;tag=1;break;&#125; &#125; if(tag)printf(&quot;orz&quot;); else cout&lt;&lt;ans; return 0;&#125; Kruscal别的不说，我觉得这个算法简直是永远的神，简单易懂好写 思路 把每一条边按照权值的大小进行排序，令最小生成树初始状态为$N$个点，没有边的非联通图 从最小的边开始，假如边的两个点不在同一个连通分量，就选择这条边(通过并查集来进行判断) 选择$N-1$条边后最小生成树生成，或者选完了过后还没$N-1$条被选说明选不出来 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 5005#define Maxm 200005class DSU&#123;private: int belong[Maxn];public: void init()&#123;for(int i=0;i&lt;Maxn;i++)belong[i]=i;&#125; int find(int u)&#123; if(u==belong[u])return u; return belong[u]=find(belong[u]); &#125; bool islink(int u,int v)&#123; int fu=find(u); int fv=find(v); return fu==fv; &#125; void link(int u,int v)&#123; int fu=find(u); int fv=find(v); belong[fu]=fv; &#125;&#125;D;struct edge&#123; int u; int v; int val; bool operator &lt;(const edge&amp; cmp)const&#123; return val&lt;cmp.val; &#125;&#125;E[Maxm];int main()&#123;#ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);#endif D.init(); int N,M;scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=M;i++)&#123; int u,v,z;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;z); E[i]=&#123;u,v,z&#125;; &#125; sort(E+1,E+1+M); int tot=0,now=1,ans=0; while(now&lt;=M)&#123; int u=E[now].u; int v=E[now].v; if(D.islink(u,v)==false)&#123; D.link(u,v); tot++; ans+=E[now].val; &#125; if(tot==N-1)break; now++; &#125; if(tot!=N-1)printf(&quot;orz&quot;); else printf(&quot;%d&quot;,ans); return 0; &#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://example.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"数据结构笔记","slug":"数据结构笔记","date":"2022-01-17T04:47:54.421Z","updated":"2022-02-10T15:28:37.612Z","comments":true,"path":"2022/01/17/数据结构笔记/","link":"","permalink":"http://example.com/2022/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 写在前面​ 寒假看看数据结构的网课当作复习吧，随便写了一些笔记 概念小结123456789101112131415161718graph LR;数据--个体--&gt;数据元素;数据元素--性质相同的构成的集合--&gt;数据对象;数据元素--加上数据元素之间的关系--&gt;数据结构;数据结构--映像到内存--&gt;存储结构;数据结构--加上操作--&gt;抽象数据类型;数据结构--逻辑模型--&gt;逻辑结构;逻辑结构--&gt;集合结构;逻辑结构--&gt;线性结构;逻辑结构--&gt;树形结构;逻辑结构--&gt;图形结构;抽象数据类型--&gt;数据对象;抽象数据类型--&gt;数据类型;抽象数据类型--&gt;基本操作;存储结构--&gt;顺序结构;存储结构--&gt;链式结构;存储结构--&gt;索引结构;存储结构--&gt;散列结构; 逻辑结构：研究对象之间的特性和关系； 存储结构：有效组织计算机进行存储 算法五个特性： 有穷性：经过有穷步可以结束 确定性：每一条指令必须有确切的含义，没有二义性 可行性：可以执行的 输入 输出 算法设计要求： 正确性 可读性 健壮性 高效性 栈和队列定义和特点 栈特点：后进先出（LIFO） 队列特点：先进先出（FIFO 使用案例进制转换 将十进制数159转换成八进制数 短除法余数分别依次是$7，3，2$，每一次得到余数的时候放入栈中，然后将栈中元素依次弹出可以得到八进制数$237$ 括号匹配 假设表达式中有[],()两种括号，括号可以嵌套，但是顺序不可以出错。比如([] ())是合法的，但是([)]不合法 按照顺序依次push进入栈中，如果和下面的匹配就弹出，如果出现交叉的情况说明不匹配。 表达式求值算法有限算法 把表达式分为： 操作数： 常数，变量 运算符： 算术运算符，逻辑运算符，关系运算符 界限符： 左右括号和表达式结束符 设置两个栈，一个是算符栈，另一个是操作数栈 从左至右开始扫描表达式： 如果是数：压入操作数栈 如果是运算符： 优先级高于运算符栈顶的优先级，入栈并继续向后扫描 优先级低于运算符栈顶的优先级，从操作数栈弹出两个运算数，弹出栈顶运算符，并进行运算，并将结果压栈进入操作数栈 继续进行扫描 舞伴问题 舞会上男女各自拍成一列，开始时从队头出来配对跳舞，跳完了过后自己排到后面去。 树 二叉树和树是两个概念，因为树的结点的孩子不分左右 假设二叉树叶子节点个数为$N_0$,有两个孩子的节点个数为$N_2$,则$N_0=N_2+1$ $$设节点数为N,两个孩子的节点数为N_2,一个的为N_1,没有的为N_0\\边数:\\N-1=N_2+N_1+N_0-1=2*N_2+N_1\\化简可得$$ 满二叉树：一个深度为$k$且有$2^k-1$个结点的二叉树 完全二叉树：深度为$k$的具有$n$个节点的二叉树，当且仅当每一个节点都与深度为$k$的满二叉树从上到下，从左到右编号1到$n$对应的时候，称作完全二叉树。其深度为$\\lfloor log_2n\\rfloor+1$ 完全二叉树节点$ib $的父亲$\\lfloor i/2\\rfloor$,儿子$2i,2i+1$ 先序遍历:根左右；中序遍历：左根右；后序遍历：左右根 如果二叉树各节点均不同，则三种遍历的序列都唯一 如果知道先序遍历和中序遍历，或者后序遍历和中序遍历，则可以确定唯一的二叉树。已知先序/后序，中序，确定子树的时候，通过先序/后序确定子树的根，通过中序确定左右。 线索二叉树：我选择把这篇文章贴上来#图解 数据结构：轻松搞定线索二叉树 - 知乎 树转换成二叉树：从上到下，当前节点孩子放在该节点的左子树，兄弟放在右子树 二叉树转换成树：左孩子的的右孩子连接到双亲，删除原来的右孩子的线 二叉树转换成森林：从根节点开始，顺着将和右孩子的连线抹掉，再把每一个二叉树再进行还原。 哈夫曼树：最优二叉树，带权路径长度最短的树 构造方法：先构造N个二叉树，每个都只有一个节点，选择权值最小的两个节点作为左右子树构成一个新的树，权值设为两个节点权值之和，然后在森林之中删除掉原来的两个节点，再把新的树放入到森林当中 特点：经过$N-1$次合并形成，有$2N-1$条边，且每个分支节点度都为2。 图定义和术语 图：G=(V,E) V(Vertex):顶点（数据元素）的非空有穷集合 E(Edge):边的有穷集合 根据是否每条边有方向分为有向图，无向图 任意两个点都有边叫做完全图(有向图是两个点之间有两条边) 有向图的边也叫做弧 边的数目很少($\\leq nlogn$)叫做稀疏图 边较多的叫做稠密图 网：边带权的图 邻接：有边相连的两个顶点之间联系 $(v_i,v_j)表示无向边，v_i邻接v_j,&lt;v_i,v_j&gt;表示有v_i到v_j的一条有向边，称作v_i邻接到v_j或者v_j邻接于v_i$ 关联（依附）:边和顶点的关系 顶点的度：和顶点相关联的边的数目（有向图称出度入度） 路径：连续的边构成的顶点序列 路径长度：路径上的边的权值之和 回路：第一个顶点和最后一个顶点相同的路径 简单路径：除了起点终点可以相同外，其他顶点均不相同 连通图：在图中，任意两个顶点之间存在路径成为连通图（有向图则成为强连通图） 连通分量：无向图的极大连通子图称为其的连通分量(有向图叫做强连通分量) 生成树：包含无向图所有顶点的极小连通子图 生成森林：对于非连通图，由各个连通分量的生成树的集合","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"图","slug":"图","permalink":"http://example.com/tags/%E5%9B%BE/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://example.com/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"2022元旦日记","slug":"2022元旦日记","date":"2022-01-01T12:10:21.550Z","updated":"2022-01-01T12:26:59.628Z","comments":true,"path":"2022/01/01/2022元旦日记/","link":"","permalink":"http://example.com/2022/01/01/2022%E5%85%83%E6%97%A6%E6%97%A5%E8%AE%B0/","excerpt":"","text":"第一次出校​ 来大学已经一个学期了，之前因为种种原因一直都没有出去过学校。今天趁着元旦节出校门去逛了一圈。想着是去南京的中央商业区看看，不过对于南京不怎么了解，所以说最后就是坐地铁在新街口一带逛了逛街。首先是去麦当劳搓了一顿午饭。然后在一个书店里面看了看。在里面找到了《我的青春恋爱物语果然有问题》。有点惊喜。随后在无印良品的时候听见外面音响说什么南京大学生歌手比赛什么的，所以没怎么仔细看无印良品就出去听歌去了。听了几首歌之后和室友们一起去蜜雪冰城了，回来在楼上看了看手办，顺便还听了比赛的最后两首歌。我要表白最后一位歌手，长得好漂亮而且歌也很好听，不过好像是已经有npy了。回来之前还买了一份远坂凛的手办","categories":[{"name":"周记","slug":"周记","permalink":"http://example.com/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"},{"name":"元旦","slug":"元旦","permalink":"http://example.com/tags/%E5%85%83%E6%97%A6/"}]},{"title":"一个人的博物馆--讲座报告","slug":"一个人的博物馆讲座报告","date":"2021-12-10T16:00:00.000Z","updated":"2022-03-10T06:08:39.713Z","comments":true,"path":"2021/12/11/一个人的博物馆讲座报告/","link":"","permalink":"http://example.com/2021/12/11/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%8D%9A%E7%89%A9%E9%A6%86%E8%AE%B2%E5%BA%A7%E6%8A%A5%E5%91%8A/","excerpt":"","text":"一个人的博物馆博物馆网址主讲人：吴先斌馆长 前言​ 今天意外地受到了邀请，在两点钟的时候去书院听一个讲座。本来最开始的时候没有抱着太大的期望，但是去了过后这个讲座确实给人很惊喜。这学期听睡了很多讲座，这个讲座称得上是印象相当深刻的一个讲座了。不过虽然说一边听，一边打字记录，但是有些细节的地方可能还是会有记错的地方 ​ 我博客以前好像没有这么多图过 内容Part1​ 最开始馆长先进行了一下自我介绍，提到了自己也曾经和吴健雄先生见过一面。在讲座的开始之前，他先是简略过了一段那个历史，提到说要从更高的层面来理解这段历史,了解到日本的野心和我们民族意识的觉醒，说到了国家公祭日是对战争受害者的缅怀。 ​ 随后馆长说到了自己创办博物馆的私心。作为一个企业家的他，以前一直都是在经商，和很多人一样，对于历史其实并没有深刻的认识。而他经商的过程中突然意外地发现饿了一本史料：有很多日本人曾经在东南大学的建筑里面，也就是说东南大学的校址是当时日军地一个驻地。于是他就去请教了一位历史学的教授，问他为什么日本人驻扎在那里。可是教授却说没有办法解读，没办法告诉他答案。 ​ 所以他自己心中郁闷：为什么一个学历史的教授都没有办法解读这件事情？由于心中有点好奇，所以说问教授为什么没法解读。而教授说史料不够，尤其是对于大屠杀的研究史料不够(十五年前)，甚至还不如日本。这就让馆长十分惊讶。因为这么重大的历史事件，三十万人被杀，但是对此地研究甚至都还不如加害者日本。馆长请教授举个例子来证明史料的落后。教授谈到了：第一点是我们大屠杀事件研究起步落后，日本是在60-70年代南京大屠杀著作公开发行，我们在79年才发行了关于南京大屠杀资料,且是作为内部资料;第二点是社会民众参与这段历史研究落后。 ​ 馆长对于民众参与到历史地研究中来并不理解。所以说教授让他有时间去听讲座。而馆长有一次去听了个日本教授关于日本某个侵华部队犯下的罪过的研究。发现这个教授讲座逻辑清晰，讲得非常地好。就在讲座结束了之后去问这位日本教授是哪一个大学的。结果这个日本教授说自己就是一个保安。是自己平时研究。 ​ 这样下来馆长就知道了当时教授说要动员社会民众参与历史研究的意义。 ​ 专家的研究是从思考的层面上面来。而社会人士则可以从自己专门的方面对同一段历史进行解读，所以说社会上的认识都对历史不同层面上的解读之后，对于历史可以有一个更加全面，清晰的认识。有助于反思和铭记历史。 ​ 李大钊作为历史学家曾经说过：“要到社会中做历史研究。”差不多是这个意思吧。 ​ 所以在听了讲座时候，就萌发了一个想法：为什么不自己去建立一个博物馆，为想要研究南京大屠杀的人提供一个平台。 ​ 后来就建立南京民间抗日博物馆，目前为止收集了文物6000余件，书籍40000余。也是中国170家抗战博物馆中，仅有的两家民间的抗战博物馆。 Part2​ 博物馆不同于大学。一个博物馆还应当去大量地进行社会实践，去宣传，普及，而不仅仅是研究。 ​ 馆长就先是提到了戴安澜将军。毛主席为他写了一首五联诗缅怀他，周总理称其为 黄埔之英，民族之雄。 ​ 说到作为民族英雄牺牲在缅甸战场的他，家人亲属一直以来都没有机会去祭拜。一直到了大约十年前地时候，他的儿子才有机会去祭拜他的父亲。馆长先生了解到了这件事情之后，就和戴安澜将军的儿子联系，提出要一同去祭拜将军。因为者不仅仅只是一个儿子对于父亲的祭拜，也是一个民族的后代对于英雄先辈的祭拜。 ​ 而后他们在2011年的时候一同去了缅甸，根据当时的一张战报记载需寻找一个叫做茅邦村的地方。众所周知，虽然三百年前，缅甸曾经是东南亚小霸王，但是现在经济发展状况并不如意，建国以来就没怎么好过。曼德勒，缅甸的上海，连水电都不能保证。在当地下了飞机之后。两百公里的路程，开车花了十三个小时的时间（路不好）。最后找到了那个村子又发现不是要找的那个村子。弃车步行，38°高温下在原始森林中不行，反复寻找，苍天不负有心人终于找到了。 ​ 原本是去祭拜先烈的，但是在缅甸发现了一个奇怪的现象。 ​ 在缅甸境内，有大量的日本军人的纪念碑，甚至连日本的战马都有自己的纪念碑。日本民间在缅甸境内修建了多达3000的纪念碑来纪念死在缅甸战场的日本人。甚至还贿赂缅甸的警察，在警哨上面去刻上日本军人的名字。缅甸的警察每吹一次哨子，就相当于是纪念了一次日本人。 ​ 试想一下一个缅甸人在缅甸见到的都是日本人的纪念碑，而不是日本人的纪念碑，那么关于中国军队远征缅甸的性质就会被模糊掉。这是作为后代的我们难以面对的一个问题。所以说在缅甸的山头，就决定要为我们的英雄去修建一座纪念碑。 ​ 后面就通过馆长通过民间的方式，修建了第一座缅甸的中国军人纪念碑。 ​ 这件事也引起了关注，目前为止，民间也已经是修建了十多座纪念碑了。馆长也说到我们要争取超过日本人。虽然说日本人从几十年前就开始修建纪念碑了，但是我们应当有捍卫历史，尊重先贤的决心。 Part3​ 这一部分有一个小标题——揭露虚假的和平 ​ 馆长问我们有没有看过日本的一个电视剧《排球女将》。不过我们之中没有人看过。毕竟是上一个时代的片子了。三原顺子，在电视剧中饰演了女队长。后来她因为感情问题退出了演艺圈从政。有一次讲话中提到：“日本想要摆脱经济低迷的状态，需要一种精神，一种八纮一宇的精神。”这些话引发了轩然大波。 ​ 八纮一宇是说要征服八方，纳入到一个屋顶之下。1938年相川胜六为了纪念神武天皇2600年生日就你妈离谱修建了八纮一宇塔，炫耀日本侵略武功。充当军国主义宣传侵略战争工具。 ​ 修建的过程中使用了日占区的石材。其中就有南京的石头。占领区的全部用于塔的基石，自己的石头放在上面。瞬间想到了元代的镇南塔。盟军胜利之后要求日本人拆掉塔。日本人移花接木的方式，将八纮一宇四个字用水泥糊掉，铜像撤掉，保留了样子，改名和平之塔核平之塔。 ​ 日本人甚至恬不知耻地在这座塔下传递奥运圣火。 ​ 随着日本经济复苏和民族主义情绪复苏，恢复了八纮一宇塔的模样。 ​ 2013年的时候，日本研究这个塔的一个民间团体找到了馆长，鼓励他把石材要回来。2015年的时候，馆长组织了南京市民去讨要石头 ​ 谈到了以前做南京大屠杀宣传的时候，日本媒体从来都没有报道。这次还没到日本，媒体的手机都打来了，到了之后日本众多媒体都到了。 ​ 在日本和知县导论此时，那个知县说了这个要讨论，要了资料去研究。 ​ 在新闻发布会上，《产经新闻》（看《参考消息》上面翻译的他们的文章就知道这家报纸不是什么好东西）带了自己的翻译。他们提问：你来讨石，有没有法律资格？馆长知道自己不能绕到里面去。就回答：“你问我有没有法律资格。我说中国人有矛盾了，处理问题和日本人不一样，中国讲究情，理，法，我们先将情，再讲理，最后再讲法。讲法，我身份证是南京的，第二，我是南京民间抗战博物馆馆长，保护和收集散落世界的南京抗战文物是馆长的责任，第三，我这次来，不是来和你谈战争赔偿问题的，我是来追赃的，掠夺我的东西，我随时随地都可以要回来。”又要再次提问什么素质，被日本组织者打断：一人只有一次机会。 ​ 后面第二天专门找了《产经新闻》的报纸来看。 ​ 称讨石一方态度强硬，说什么来在多次都是和核平之塔。 ​ 而在回来之后还受到了日本的恐吓信。 ​ ​ 把我恶心到了。 ​ 而结果非常遗憾：石头没有讨回来。馆长说本来想再去。但是负责协调的老日本共产党员去世了，加上疫情。不过和日方仍然保持通信。而知县曾经表态：“要经过议会的表决。”这就十分困难了。 ​ 但是讨石的过程并不是没有任何意义的。这也让很多日本人知道了石头的本来面目。 ​ 经过调研，南京还有四块石头没有归还，除此之外还有其他的石头，也希望可以回到祖国来。 Part4​ 最后还有一个提问环节。谈到了历史教育，文化交流的问题。馆长提到了对历史不了解并不是我们的错，而是老一辈的他们没有教育好，也希望我们虽然是工科生，但是也要去了解历史，了解民族的过去。 合照","categories":[{"name":"讲座报告","slug":"讲座报告","permalink":"http://example.com/categories/%E8%AE%B2%E5%BA%A7%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"南京","slug":"南京","permalink":"http://example.com/tags/%E5%8D%97%E4%BA%AC/"},{"name":"抗日战争","slug":"抗日战争","permalink":"http://example.com/tags/%E6%8A%97%E6%97%A5%E6%88%98%E4%BA%89/"}]},{"title":"图论复习(最短路)","slug":"图论复习（最短路）","date":"2021-12-08T12:23:20.146Z","updated":"2021-12-09T07:31:46.638Z","comments":true,"path":"2021/12/08/图论复习（最短路）/","link":"","permalink":"http://example.com/2021/12/08/%E5%9B%BE%E8%AE%BA%E5%A4%8D%E4%B9%A0%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89/","excerpt":"","text":"前言​ 下学期开始讲数据结构，我自己比较想去争取一下免修。不过其实关于图论的部分基本上已经是忘得差不多了（我觉得我现在可能唯一还会的算法就是倍增求$LCA$了）。图论的部分就打算从最简单的最短路和最小生成树开始复习了（据说下学期数据结构的内容要求只有$Dijkstra$算法）。 Dijkstra​ 它中间的k很容易打漏 ​ 应该是一个荷兰人在上世纪五十年代提出来的算法吧（记不清了），用来计算非负权图的单源最短路 算法思路​ 假设起点为$S$,$dist[i]$表示从$S$到点$i$的最短路，$vis[i]$表示是否选中了这一个点($0$表示还没有选中，$1$表示已经选中) ​ 思路如下： $dist$数组初始化为$inf$,$dist[S]=0$，$vis$数组初始化为$0$ 重复接下来的操作$n$次（假如这个图联通的话） 从没有选中的点中选择$dist$值最小的一个点$u$,$vis[u]=1$ 设$v$是$u$可以直接到达的节点，$val$是这两条边的权值,$dist[v]=min(dist[v],dist[u]+val)$ 或者说（不知道这个图到底联不联通）: 每次选的点加入集合，每次从集合中去出点来，直到集合为空为止 算法的正确性​ 我就根据自己的理解给一个证明了。不保证正确性。 ​ 每一次都是从没有选择的一群点中选择$dist$最小的点$u$。首先就是不可能存在路径$S \\rightarrow mid\\rightarrow u $，$mid$属于还没有选择的点当中，十的$dist$更小。这是因为这个图是没有负权的，其他的点$dist$都是更大的，这样转移过来$u$的$dist$不会更小了。所以说每次选的点的最短路长度都是求出来了的，所有的点选完了那么最短路就求出来了 算法的优化​ 暴力遍历数组选择节点时间复杂度为$O(n^2)$,为了优化算法，应当考虑提高选择结点的时候的效率。 ​ 考虑用优先队列进行优化，将选择节点的效率提高到$O(\\log n)$,这样算法的效率就提高了 12345678910111213141516171819priority_queue&lt; pair&lt;int,int&gt; &gt;Que;void Dijsktra()&#123; clr(dist,0x3f); dist[S]=0; Que.push(make_pair(0,S)); while(Que.size())&#123; int u=Que.top().second;Que.pop(); if(inq[u])continue; inq[u]=true; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; int w=val[i]; if(dist[v]&gt;dist[u]+w)&#123; dist[v]=dist[u]+w; Que.push(make_pair(-dist[v],v)); &#125; &#125; &#125;&#125; 上面是一份代码的案例。有自己define的语句。 Floyd相当简单直白的算法了。边的权值可以负可以正，无向有向均可，但是要没有负环。 算法思路​ 点$u$到点$v$的路径可以分分解为点$u$到点$mid$再到点$v$两条路径长度之和，所以说对于任意两个点之间的最短路，都枚举一下两个点之间转移的中间节点是多少就好了。 1234for(int k=1;k&lt;=N;k++)//枚举中间节点 for(int i=1;i&lt;=N;i++)//枚举起点 for(int j=1;j&lt;=N;j++)//枚举终点 dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]); ​ 缺点就是比较慢，时间复杂度达到了$O(n^3)$,优点是求得多源点最短路。 Bellman-Ford相比于$Dijkstra$，可以处理有负边权的情况 算法思路假设$dist[i]$表示从$S$到点$i$的最短路，$edge$是边的结构体,其中包含两个点和对应的权值 $dist$数组初始化为$inf$,$dist[S]=0$ 下面操作（松弛操作）重复$n-1$次： 枚举每一条边，$dist[edge[k].u]=min(dist[edge[k].u],dist[edge[k].v]+edge[k].val)$ 再进行一次松弛操作，如果说松弛操作可以成功，那么就说明这个图存在负环 12345678910111213141516171819bool Bellman_ford()&#123; memset(dist,0x3f,sizeof(dist)); dist[S]=0; for(int i=1;i&lt;N;i++)&#123; for(int j=1;j&lt;=E;j++)&#123; int u=edge[j].u; int v=edge[j].v; int w=edge[j].w; dist[u]=min(dist[u],dist[v]+w); &#125; &#125; for(int i=1;i&lt;=E;i++)&#123; int u=edge[j].u; int v=edge[j].v; int w=edge[j].w; if(dist[u]&gt;dist[u]+dist[v]+w)return false; &#125; return true;&#125; 算法的正确性​ 图的最短路不会包含正权的环（假设说有正环，那么肯定是有一条边可以删掉的，建议自己画图理解一下），也不会有负环（有负环哪来的最短路）。所以说一个图的最短路最多会有$N-1$条边。 ​ $N$个点，$N-1$条边，其实就是一棵树，$Bellman-Ford$可以看作是以$S$作为根，一层一层地生成这棵最短路的树的一个过程，这棵树最多有$N-1$层，所以说最多只需要进行$N-1$次操作就好了，如果说还能继续的话就说明是存在负环了。 SPFA算法思想​ 相当于是通过队列的方式对$Bellman-Ford$进行优化。通过队列的方式减少了多余的扫描 $dist$初始化为无穷大，$inq$初始化为0（用来记录是否在队列里面），$dist[S]$设为$0$，$inq[S]=1$并且放入队列当中 只要队列不为空： 拿出队首的元素$u$，扫描队首元素可以到达的节点$v$ 如果说$dist[v]&gt;dist[u]+w$,更改值，检查$v$是否在队列当中，如果说不在队列里面的话，那么放入队列里面,$inq$设置为$1$ 如果说一个点加入队列的次数超过了$N$说明有负环 1234567891011121314151617181920void SPFA()&#123; //没有对于负环的检测 memset(dist,0x3f,sizeof(dist)); memset(inq,0,sizeof(inq)); dist[S]=0; inq[S]=1; Que.push(S); while(Que.size())&#123; int u=Que.front();Que.pop(); inq[u]=0; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; int w=val[i]; if(dist[u]&gt;dist[v]+w)&#123; dist[u]=dist[v]+w; if(!inq[v])&#123;Que.push(v);inq[v]=1;&#125; &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"SPFA","slug":"SPFA","permalink":"http://example.com/tags/SPFA/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://example.com/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"http://example.com/tags/Floyd/"}]},{"title":"LGP2471","slug":"LGP2471","date":"2021-11-16T16:00:00.000Z","updated":"2021-12-04T04:01:39.089Z","comments":true,"path":"2021/11/17/LGP2471/","link":"","permalink":"http://example.com/2021/11/17/LGP2471/","excerpt":"","text":"LGP2471Analysis​ 这道题要算到区间的最大值，而且又不需要进行修改，所以说就直接联想到了用ST表来对区间的最大值进行求解。 ​ 我们假设左边的年限$x$对应的序号为$l$,右边$y$为$r$,因为年限是按照顺序输入的，所以说可以直接用lower_bound进行查找，分成四种情况处理 左右区间的降水量都未知 直接输出maybe 左区间已知，右区间未知 如果$r==l+1$输出maybe(二者之间都是未知的) 先计算$[l+1,r]$区间的最大值，然后对于最大值和和左区间进行比较，如果说左区间的值小于最大值，输出false 否则的话就直接输出maybe 左区间未知，右区间已知 如果说$l==r$输出maybe(二者之间都是未知的) 计算$[l,r-1]$区间的最大值，然后最大值和右区间进行比较，如果说右区间的值小于最大值，输出false 否则的话输出maybe 左右区间都已知 如果说$r==l+1$并且$y==x+1$输出true 否则输出maybe 如果说左区间的值小于等于右区间的值的话，直接输出false 计算$[l+1,r-1]$区间的最大值，然后和右区间的值进行比较，如果说大于的话就直接输出false 然后看$r-l==y-x$是否成立（中间没有位置的），成立输出true 否则输出maybe Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 50005#define logn 20void init();inline int read();int N,M;int val[Maxn];int LG[Maxn];int year[Maxn];int ST[Maxn][logn];int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif N=read(); for(int i=1;i&lt;=N;i++)&#123;year[i]=read();val[i]=read();ST[i][0]=val[i];&#125; init(); M=read(); while(M--)&#123; int y=read(),x=read(); int posl=lower_bound(year+1,year+1+N,y)-year; int posr=lower_bound(year+1,year+1+N,x)-year; //二者都不已知 if((posl==N+1||y!=year[posl])&amp;&amp;(posr==N+1||x!=year[posr]))&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; //l已知 r未知 if((posl!=N+1&amp;&amp;y==year[posl])&amp;&amp;(posr==N+1||x!=year[posr]))&#123; if(posl+1==posr)&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; else&#123; int tmp=LG[(posr-1)-(posl+1)+1]; int maxv=max(ST[posl+1][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posl])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; //l未知,r已知 else if((posl==N+1||y!=year[posl])&amp;&amp;(posr!=N+1&amp;&amp;x==year[posr]))&#123; if(posl==posr)&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; else&#123; int tmp=LG[(posr-1)-posl+1]; int maxv=max(ST[posl][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; //二者都已知 else&#123; if(val[posl]&lt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else if(posl+1==posr)&#123; if(x==y+1)&#123;cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; else&#123; int tmp=LG[(posr-1)-(posl+1)+1]; int maxv=max(ST[posl+1][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else if(posr-posl==x-y)&#123; cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; continue; &#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; &#125; return 0;&#125;inline int read()&#123; int x=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; return x*sign;&#125;void init()&#123; LG[1]=0; for(int i=2;i&lt;Maxn;i++)&#123;LG[i]=LG[i&gt;&gt;1]+1;&#125; for(int i=1;i&lt;logn;i++)&#123; for(int j=1;j+(1&lt;&lt;i)-1&lt;=N;j++)&#123; ST[j][i]=max(ST[j][i-1],ST[j+(1&lt;&lt;i-1)][i-1]); &#125; &#125;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"ST表","slug":"ST表","permalink":"http://example.com/tags/ST%E8%A1%A8/"}]},{"title":"LGP4588","slug":"LGP4588","date":"2021-11-16T16:00:00.000Z","updated":"2021-12-04T04:02:50.751Z","comments":true,"path":"2021/11/17/LGP4588/","link":"","permalink":"http://example.com/2021/11/17/LGP4588/","excerpt":"","text":"LGP4588Analysis​ 最开始拿到这一道题目的时候第一个反应是暴力求解问题。遇见除法的时候就直接乘上逆元来取模 ​ 但是$\\exist x, ax\\equiv1(mod\\ n)\\iff gcd(a,n)=1$ 对于每一组输入，第一行是两个数字 Q,M ​ 这个M是输入给的，不保证上面的条件。 ​ 这个时候就要转换思路了 ​ 我们考虑高精度直接硬算 ​ 两个操作每次就只修改一个数(单点修改)。 ​ 同余的性质：两个数相乘再去模等于两个数分别取模再相乘再取模（可以左右两边的结果合并） ​ 所以说可以考虑用线段树进行操作，选择以时间为轴（能想出来这种方法的真是神仙），这棵线段树应当有$n$个叶子节点，初始值为$1$，假如第$i$次操作是$1$操作，将第$i$个节点转换成为$m$,假如是$2$操作，将$pos$位置改成$1$,每次输出根节点的值就好了 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 100005class Segment_tree&#123; private: Int64 databank[Maxn&lt;&lt;2]; Int64 Mod; public: void SetMod(int M)&#123;Mod=M;&#125; void pushup(int nowpos)&#123; databank[nowpos]=(databank[nowpos&lt;&lt;1]*databank[nowpos&lt;&lt;1|1])%Mod; &#125; void init(int nowpos,int L,int R)&#123; if(L==R)&#123;databank[nowpos]=1;return;&#125; int mid=L+R&gt;&gt;1; init(nowpos&lt;&lt;1,L,mid); init(nowpos&lt;&lt;1|1,mid+1,R); pushup(nowpos); &#125; void modify(int nowpos,int L,int R,int pur,int val)&#123; if(L==R&amp;&amp;L==pur)&#123; databank[nowpos]=val; return; &#125; int mid=L+R&gt;&gt;1; if(pur&lt;=mid)modify(nowpos&lt;&lt;1,L,mid,pur,val); if(pur&gt;mid)modify(nowpos&lt;&lt;1|1,mid+1,R,pur,val); pushup(nowpos); &#125; void output()&#123;cout&lt;&lt;databank[1]&lt;&lt;endl;&#125;&#125;S;inline void read(int &amp;x)&#123; x=0;char c=getchar();while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif int t;read(t); while(t--)&#123; int q,m;read(q);read(m); S.SetMod(m); S.init(1,1,q); for(int i=1;i&lt;=q;i++)&#123; int op,v;read(op);read(v); if(op==1)S.modify(1,1,q,i,v),S.output(); else&#123; S.modify(1,1,q,v,1); S.output(); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"LGP1966","slug":"LGP1966","date":"2021-10-28T02:32:05.305Z","updated":"2021-10-28T02:47:58.587Z","comments":true,"path":"2021/10/28/LGP1966/","link":"","permalink":"http://example.com/2021/10/28/LGP1966/","excerpt":"","text":"LGP1966Analysis观察$\\sum_{1}^{n}(a_i-b_i)^2$,展开发现$a_i^2,b_i^2$的总和是固定的，所以说为了满足题目条件，就应该让$\\sum a_ib_i$尽可能大。由排序不等式可知，顺序和是最大的，所以说这道题就可以转换成一道逆序对数的题目 关于排序不等式戳这 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 100005#define Mod 99999997int N,ans;struct dbk&#123; int val; int pos; bool operator &lt;(const dbk &amp;obj)const&#123; return val&lt;obj.val; &#125;&#125;A[Maxn],B[Maxn];int tmp[Maxn];struct tree_array&#123; int v[Maxn]; void modify(int pos)&#123; while(pos&lt;=N)&#123; v[pos]++; pos+=lowbit(pos); &#125; &#125; int query(int pos)&#123; int res=0; while(pos)&#123; res+=v[pos]; res%=Mod; pos-=lowbit(pos); &#125; return res; &#125;&#125;T;void sol()&#123; for(int i=1;i&lt;=N;i++)&#123; cin&gt;&gt;A[i].val; A[i].pos=i; &#125; for(int i=1;i&lt;=N;i++)&#123; cin&gt;&gt;B[i].val; B[i].pos=i; &#125; sort(A+1,A+1+N); sort(B+1,B+1+N); for(int i=1;i&lt;=N;i++)&#123; tmp[A[i].pos]=B[i].pos; &#125; for(int i=1;i&lt;=N;i++)&#123; T.modify(tmp[i]); ans+=(T.query(N)-T.query(tmp[i])); ans%=Mod;ans+=Mod;ans%=Mod; &#125;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif cin&gt;&gt;N; sol(); cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"逆序对数","slug":"逆序对数","permalink":"http://example.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"}]},{"title":"大学第一篇博客","slug":"大学的第一篇博客","date":"2021-09-16T03:55:21.840Z","updated":"2023-09-11T08:32:33.202Z","comments":true,"path":"2021/09/16/大学的第一篇博客/","link":"","permalink":"http://example.com/2021/09/16/%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"重新弄了一下博客，也没有什么想说的。完了，只是说明我还活着","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"2-SAT问题","slug":"2-SAT问题","date":"2021-09-05T02:20:23.262Z","updated":"2021-09-16T03:55:37.848Z","comments":true,"path":"2021/09/05/2-SAT问题/","link":"","permalink":"http://example.com/2021/09/05/2-SAT%E9%97%AE%E9%A2%98/","excerpt":"","text":"2-SAT问题描述有n个组，第i个组里有两个节点$A_i, A_i’$ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的n个点都能两两相容。这类型的问题我们称之为2-SAT问题 问题引入Question 某国有N个党派，每个党派里面有且只有两个代表（编号连续），要求从中选一个代表出来组成和平委员会，且如果两个代表不和，则他们不能同时属于委员会 Sample Input1233 21 32 4 Sample Output1231 45 Analysis理解可以通过图论知识来解决，如果选1,则不能选4,只能选3,而如果选4，则只能选2，所以我们根据这个来建立有向边。 $Conclusion$:若所有$i_1,i_2$都不在同一个强分支，则有解。 对于判定强分支有以下的方法 $Kusarajo$,$Tarjan$ 染色法 这里选择使用染色法 染色法从每一个组别开始去$dfs$,将要选择的点依次标记出来，并把其相关的必选点也同样染色，如果出现了冲突，则清除染色方案，重新染色。 12345678910111213141516171819202122232425//color是标记颜色的，other记录同一组中另外一个元素是多少//stk是手动的栈，这里采用链式前向星存图bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u;//记录 for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,false,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[2*i-1]||color[2*i])continue; //已经染过了色 top=0; if(!DFS(2*i-1))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(2*i))return false; &#125; &#125; return true;&#125; 这里来说一下这一段代码 123for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true; 注意这里不可以写成 1return DFS(to[i]); 因为这一点染色是否成功要看与之相关的所有的点的染色是否成功，而如果有相关一个点失败了，那么就是失败了，要回去重新$dfs$ Codes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define maxn 8005#define maxm 20005using namespace std;int other[maxn*2],ans[maxn],N,M,tot=0;int head[maxn],to[maxm],nxt[maxm];bool color[maxn];int stk[maxn],top=0;inline int read()&#123; int res=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125; void init(int K)&#123; for(int i=1;i&lt;=2*K;i++) other[i]=(i&amp;1)?i+1:i-1;&#125;inline void addedge(int x,int y)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot;&#125;bool DFS(int u);bool twoSAT();int main()&#123; N=read();M=read(); init(N); for(int i=1;i&lt;=M;i++)&#123; int a=read(),b=read(); addedge(a,other[b]); addedge(b,other[a]); //a,b之间是相互冲突的，如果a选了的话，那么就 //必须要选b所在组别的另外一个，如果是b选了同理 &#125; if(twoSAT())&#123; for(int i=1;i&lt;=2*N;i++)if(color[i])printf(&quot;%d\\n&quot;,i); &#125; else printf(&quot;NIE&quot;); return 0;&#125;bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u;//记录 for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,false,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[2&lt;&lt;i-1]||color[2*i])continue; //已经染过了色 top=0; if(!DFS(2*i-1))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(2*i))return false; &#125; &#125; return true;&#125; 例题洛谷P4782链接：洛谷P4782 Analysis就和它自己说的一样，这是一道模板题，这里选择把真和假的两种状态作为所说的选择。所以就选择用$i$表示这一个点要选，$i+N$来表示这一个点不选 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define maxn 1000005using namespace std;int color[maxn&lt;&lt;1],N,M,other[maxn&lt;&lt;1];int stk[maxn&lt;&lt;1],top=0;int head[maxn&lt;&lt;1],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],tot=0;//i表示 这一个节点真,i+N表示假 inline int read()&#123; int res=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125;void init(int K)&#123; for(int i=1;i&lt;=2*K;i++) other[i]=(i&lt;=K)?(i+K):(i-K);&#125;inline void add(int x,int y)&#123; to[++tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;bool DFS(int u);bool twoSAT();int main()&#123; N=read();M=read(); init(N); int a,b,c,d; for(int i=1;i&lt;=M;i++)&#123; a=read();b=read(); c=read();d=read(); add(a+!b*N,c+d*N); add(c+!d*N,a+b*N); &#125; if(twoSAT())&#123; printf(&quot;POSSIBLE\\n&quot;); for(int i=1;i&lt;=N;i++)&#123; printf(&quot;%d &quot;,color[i]&lt;color[i+N]); &#125; &#125; else printf(&quot;IMPOSSIBLE&quot;); return 0;&#125;bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u; for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,0,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[i]||color[i+N])continue; top=0; if(!DFS(i))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(i+N))return false; &#125; &#125; return true;&#125; 洛谷P4171链接：洛谷P4171 Analysis这题里面一种材料要么就只能做满洲菜，要么就做汉族菜，因此每一种材料，汉族菜和满洲菜就相当于是对应着$true$和$false$两种状态了，因此就这样来染色法解决问题。这一道题最需要注意的是在于输入时，每一道菜的序号不一定只有一位数。 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define maxn 105#define maxm 1005using namespace std;int head[maxn&lt;&lt;1],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1],tot=0;int stk[maxn&lt;&lt;1],top=0;int col[maxn&lt;&lt;1],other[maxn&lt;&lt;1],N,M,K;inline int read()&#123; int res=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125;void init(int K)&#123; for(int i=1;i&lt;=K;i++) other[i]=i+N,other[i+N]=i;;&#125;inline void add(int x,int y)&#123; to[++tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;bool dfs(int u);bool twoSAT();int main()&#123; K=read(); while(K--)&#123; N=read();M=read(); init(N); for(int i=1;i&lt;=M;i++)&#123; int x=0,y=0,rep=1; char kd[5]; cin&gt;&gt;kd; while(kd[rep]&gt;=&#x27;0&#x27;&amp;&amp;kd[rep]&lt;=&#x27;9&#x27;)&#123; x=x*10+kd[rep]-48; rep++; &#125; if(kd[0]==&#x27;m&#x27;)x+=N; cin&gt;&gt;kd; rep=1; while(kd[rep]&gt;=&#x27;0&#x27;&amp;&amp;kd[rep]&lt;=&#x27;9&#x27;)&#123; y=y*10+kd[rep]-48; rep++; &#125; if(kd[0]==&#x27;m&#x27;)y+=N;//注意这里的输入很重要 add(x,other[y]); add(y,other[x]); &#125; if(twoSAT())printf(&quot;GOOD\\n&quot;); else printf(&quot;BAD\\n&quot;); memset(other,0,sizeof(other)); memset(to,0,sizeof(to)); memset(head,0,sizeof(head)); memset(nxt,0,sizeof(nxt)); tot=0; &#125;&#125;bool dfs(int u)&#123; if(col[u])return true; if(col[other[u]])return false; col[u]=1; stk[++top]=u; for(int i=head[u];i;i=nxt[i]) if(!dfs(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(col,0,sizeof(col)); for(int i=1;i&lt;=N;i++)&#123; if(col[i]||col[i+N])continue; top=0; if(!dfs(i))&#123; while(top)col[stk[top]]=0,top--; if(!dfs(i+N))return false; &#125; &#125; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://example.com/tags/2-SAT/"},{"name":"染色法","slug":"染色法","permalink":"http://example.com/tags/%E6%9F%93%E8%89%B2%E6%B3%95/"}]},{"title":"20190709 test","slug":"20190709","date":"2021-09-05T02:20:23.192Z","updated":"2021-09-05T02:20:23.540Z","comments":true,"path":"2021/09/05/20190709/","link":"","permalink":"http://example.com/2021/09/05/20190709/","excerpt":"","text":"T1Desctription 一队勇士正在向你进攻，每名勇士都有一个战斗值$a_i$。但是这队勇士却有一个致命弱点，如果存在$i$&lt;$j$&lt;$k$使得$a_i$&gt;$a_j$&gt;$a_k$，则会影响他们整体的战斗力。我们将这样的一组(i,j,k)称为这队勇士的一个弱点。请求出这队勇士的弱点数目。 Input 输入文件：$weakness.in$ 输入的第一行是一个整数n，表示勇士的数目。 接下来一行包括n个整数，表示每个勇士的战斗值$a_i$ Output 输入文件：$weakness.out$ 输出为一行，包含一个整数。表示这队勇士的弱点数目。 Anlysis这一道题很明显的就是一个逆序对数的题目，求每一个数和前面的数可以组成多少逆序对数，和后面可以组成多少逆序对数，然后乘起来，用树状数组来进行计算就可以了。 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define lowbit(x) x&amp;(-x) #define maxn 1000000using namespace std;int N,a[maxn+5];int dat[maxn+5],dat2[maxn+5];int par[maxn+5],par2[maxn+5];int limnum=0;long long ans=0;inline void read(int &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;void upd(int x,int d[])&#123; while(x&lt;=limnum)&#123; d[x]++; x+=lowbit(x); &#125; &#125;long long sum(int x,int d[])&#123; int res=0; while(x&gt;0)&#123; res+=d[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; freopen(&quot;weakness.in&quot;,&quot;r&quot;,stdin); freopen(&quot;weakness.out&quot;,&quot;w&quot;,stdout); read(N); for(int i=1;i&lt;=N;i++)&#123; read(a[i]); if(a[i]&gt;limnum)limnum=a[i]; &#125; for(int i=1;i&lt;=N;i++)&#123; upd(a[i],dat); par[i]=sum(limnum,dat)-sum(a[i],dat); upd(a[N-i+1],dat2); par2[N-i+1]=sum(a[N-i+1]-1,dat2); &#125; for(int i=1;i&lt;=N;i++)&#123; ans+=(par[i]*par2[i]); &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"}]},{"title":"20190710 test","slug":"20190710test","date":"2021-09-05T02:20:22.933Z","updated":"2021-09-23T14:41:27.575Z","comments":true,"path":"2021/09/05/20190710test/","link":"","permalink":"http://example.com/2021/09/05/20190710test/","excerpt":"","text":"20190710的testT1Desctription 传说，数千年前圣帕特里克消灭了哞尔兰所有的蛇。然而，蛇们现在卷土重来了！圣帕特里克节是在每年的3月17日，所以小明要用彻底清除哞尔兰所有的蛇来纪念圣帕特里克。小明装备了一个捕网，用来捕捉N组排成一行的蛇（1≤N≤400）。小明必须按照这些组在这一行中出现的顺序捕捉每一组的所有蛇。每当小明抓完一组蛇之后，她就会将蛇放在笼子里，然后带着空的捕网开始捕捉下一组。 一个大小为s的捕网意味着小明可以抓住任意包含g条的一组蛇，其中g≤s。然而，每当小明用大小为s的捕网抓住了一组g条蛇，就意味着浪费了s−g的空间。小明可以任意设定捕网的初始大小，并且她可以改变K次捕网大小（1≤K&lt;N）。 请告诉小明她捕捉完所有组的蛇之后可以达到的总浪费空间的最小值。 Input 输入的第一行包含N和K。第二行包含N个整数$a_1$,…,$a_N$，其中$a_i$（0≤$a_i$≤10^6）为第i组蛇的数量 Output 输出一个整数，为小明抓住所有蛇的总浪费空间的最小值。 Anlysis这一道题一眼就可已看出来是在考$dp$,那么问题就在于如何来设计方程了,考试的时候我设计了一个三维的状态，接着循环写了四层，然后不负众望，$TLE$了。（而$WYXdalao$轻松$AC$） 然后重新来看，设$f[i][j]$代表第$i$个时候，用了$j$个袋子时最少浪费了多少，我们提前预处理出一个前缀和，用来获取区间内蛇的数量，因为要放下所有的蛇，所以说数量要选择最大那一个来减。 Codes123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define maxn 405#define inf 0x3f3f3f3fusing namespace std;int N,K;int f[maxn][maxn];int a[maxn],mxn[maxn][maxn]; int sum[maxn];int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); memset(f,0x3f,sizeof(f)); for(register int i=1;i&lt;=N;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; //边界 K++;//因为j要减1,所以避免负数 f[0][0]=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=min(K,i);j++)&#123; int mxn=a[i]; for(int k=i-1;k&gt;=0;k--)&#123; f[i][j]=min(f[i][j],f[k][j-1]+mxn*(i-k)-(sum[i]-sum[k])); mxn=max(mxn,a[k]); &#125; &#125; &#125; int ans=inf; for(int i=0;i&lt;=K;i++)&#123; ans=min(ans,f[N][i]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; T2Desctription 小明喜欢养宠物，想要将编号为1…N的N只宠物（N≤7500）分为非空的K组（2≤K≤N），使得任意两只来自不同组的宠物都需要走一定的距离才能相遇。宠物x和宠物y（其中1≤x&lt;y≤N）愿意为了见面走 ($2019201913x$+$2019201949y$) mod $2019201997$英里。给定一个将N只宠物分为K个非空小组的分组方案，令M为任意两头来自不同组的宠物愿意为了见面行走的英里数的最小值。为了测试宠物们相互之间的忠诚度，小明想要将N头宠物以最佳的方式分为K组，使得M尽可能大 Input 输入仅有一行，包含N和K，用空格分隔。 Output 输出最优的M。 Anlysis考试的时候我没有想到可以来找规律!!!$$(2019201913x+2019201949y)\\mod 2019201997\\\\=(-84x-48y)\\mod 2019201997$$所以$y=N $,$x=K-1$时最大 Codes123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int N,K; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); printf(&quot;%d&quot;,-84*(K-1)-48*N+2019201997); return 0;&#125; T3Desctription 设T 为一棵有根树，我们做如下的定义： • 设a和b为T 中的两个不同节点。如果a是b的祖先，那么称“a比b不知道 高明到哪里去了”。 • 设a 和 b 为 T 中的两个不同节点。如果 a 与 b 在树上的距离不超过某个给定 常数x，那么称“a 与b 谈笑风生”。 给定一棵n个节点的有根树T，节点的编号为1 到 n，根节点为1号节点。你需 要回答q 个询问，询问给定两个整数p和k，问有多少个有序三元组(a;b;c)满足： a、b和 c为 T 中三个不同的点，且 a为p 号节点； a和b 都比 c不知道高明到哪里去了； a和b 谈笑风生。这里谈笑风生中的常数为给定的 k。 Input 输入文件的第一行含有两个正整数n和q，分别代表有根树的点数与询问的个数。接下来n – 1行，每行描述一条树上的边。每行含有两个整数u和v，代表在节点u和v之间有一条边。 接下来q行，每行描述一个操作。第i行含有两个整数，分别表示第i个询问的p和k。。 Output 输出 q 行，每行对应一个询问，代表询问的答案。 Anlysis这一道题，首先要明白，要分两种情况 $b$是$a$的祖先，这种情况比较简单，可以根据乘法原理，在$O(1)$内得到答案 $b$是$a$的子孙，这种情况就不好求了，要用主席树来做，选择以深度为下标，$size$作为维护的值进行修改。还要用到$dfs$序，一个节点和他的子树的序号是一个连续的区间，这样来进行查询 考试的时候，当然就是没有做出来了 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define maxn 600300#define Int64 long longusing namespace std;int N,Q;int siz[maxn],dep[maxn],fa[maxn];int head[maxn],to[maxn],nxt[maxn],tot=0;int cnt=0,s=0;int dfn[maxn],Root[maxn];int maxdep=0;struct nde&#123; int lch,rch; Int64 data;&#125;sgt[maxn*20];inline void read(int &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign; &#125;inline void add(int x,int y)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot;&#125;void dfs(int u)&#123; siz[u]=1; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!siz[v])&#123; dep[v]=dep[u]+1; maxdep=max(dep[v],maxdep); fa[v]=u; dfs(v); siz[u]+=siz[v]; &#125; &#125;&#125;void insert(int &amp;p,int l,int r,Int64 val,int pur)&#123; sgt[++s]=sgt[p]; p=s; sgt[p].data+=val; if(l==r)return; int mid=(l+r)&gt;&gt;1; if(mid&gt;=pur)insert(sgt[p].lch,l,mid,val,pur); else insert(sgt[p].rch,mid+1,r,val,pur);&#125;Int64 query(int ver1,int ver2,int l,int r,int x,int y)&#123; if(l==x&amp;&amp;r==y)return sgt[ver2].data-sgt[ver1].data; int mid=(l+r)&gt;&gt;1; if(mid&gt;=y)return query(sgt[ver1].lch,sgt[ver2].lch,l,mid,x,y); else if(mid&lt;x) return query(sgt[ver1].rch,sgt[ver2].rch,mid+1,r,x,y); else return query(sgt[ver1].lch,sgt[ver2].lch,l,mid,x,mid)+query(sgt[ver1].rch,sgt[ver2].rch,mid+1,r,mid+1,y);&#125; void dfs_(int u)&#123; dfn[u]=++cnt; Root[cnt]=Root[cnt-1];//insert里面会给这个root赋值的 insert(Root[cnt],1,maxdep,(Int64)siz[u]-1,dep[u]); //因为是以dep作为下标来的，所以是1-maxdep //然后每一个深度相同的插入可以当作对这个的修改。 for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v!=fa[u])dfs_(v); &#125;&#125;int main()&#123; //freopen(&quot;talk.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;talk.out&quot;,&quot;w&quot;,stdout); read(N);read(Q); for(int i=1;i&lt;=N-1;i++)&#123; int x,y; read(x);read(y); add(x,y);add(y,x); &#125; dep[1]=1; dfs(1); dfs_(1); while(Q--)&#123; int p,k; read(p);read(k); if(dep[p]==maxdep)&#123;printf(&quot;0\\n&quot;);continue;&#125; Int64 ans=0; ans+=(long long)(min(k,dep[p]-1))*(siz[p]-1); int l=dfn[p]-1,r=dfn[p]+siz[p]-1; ans+=query(Root[l],Root[r],1,maxdep,dep[p]+1,min(maxdep,dep[p]+k)); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://example.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"dfs序","slug":"dfs序","permalink":"http://example.com/tags/dfs%E5%BA%8F/"}]},{"title":"20190712的test","slug":"20190712test","date":"2021-09-05T02:20:22.776Z","updated":"2021-09-07T06:05:06.081Z","comments":true,"path":"2021/09/05/20190712test/","link":"","permalink":"http://example.com/2021/09/05/20190712test/","excerpt":"","text":"T1Description N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.例如颜色分别为1,2,2,1的四个布丁一共有3段颜色. Input 第一行给出N,M表示布丁的个数和好友的操作次数. 第二行N个数$A_1$,$A_2$…$A_n$表示第i个布丁的颜色从第三行起有M行,对于每个操作,若第一个数字是1表示要对颜色进行改变，其后的两个整数X,Y表示将所有颜色为X的变为Y，X可能等于Y. 若第一个数字为2表示要进行询问当前有多少段颜色，这时你应该输出一个整数. Output 针对第二类操作即询问，依次输出当前有多少段颜色. Sample Input123454 31 2 2 121 2 12 Sample Output1231 Analysis","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"fhq_treap","slug":"fhq-treap","permalink":"http://example.com/tags/fhq-treap/"}]},{"title":"20190723的test","slug":"20190723","date":"2021-09-05T02:20:22.666Z","updated":"2021-09-05T02:20:23.443Z","comments":true,"path":"2021/09/05/20190723/","link":"","permalink":"http://example.com/2021/09/05/20190723/","excerpt":"","text":"TrafficDescription​ 工人打算用一组传感器测量公路上的车流量，每个传感器被用来测量一小段路面上的车流量的数值。不幸的是，某一天装有传感器的盒子进了水，之后它们就不能精确的测量了。现在每个传感器只能输出一个可能结果的范围。例如，一个传感器可能会给出范围[7,13]，表示在这段路面上的车流量不小于7，并且不大于13。 ​ 高速路要测量的这一段长N英里，当然高速路都是单向的，从第1英里驶向第N英里。工人想要安装N个传感器——每个监测1英里长的路段。在其中某些路段上，有能够使得车辆进入高速公路的上匝道，在这样的路段上，工人会将传感器装在上匝道上，测量流入的车流量。在某些路段上有能够使得车辆离开高速公路的下匝道，在这样的路段上，工人会将传感器装在下匝道上。每一个路段包含至多一个匝道。如果在公路的一个路段上没有上匝道或下匝道，工人就将传感器装在高速公路的主路上。 ​ 给定N个传感器的读数，请求出在高速公路第1英里之前和第N英里之后车流量的最为准确的可能范围。这些范围应当与所有N个传感器的读数相一致。 Input​ 输入的第一行包含N（1≤N≤100）。余下N行每行按从第1英里至第N英里的顺序描述一段1英里长的路段。每行包含一个字符串，为”on”（如果这段路上有一个上匝道），”off”（如果这段路上有一个下匝道），或者是”none”（如果这段路上没有匝道），然后是两个范围为0…1000的整数，表示这段路上的传感器的读数所给出的下界、上界。至少一个高速公路路段的描述会是”none”。 Output​ 输出的第一行包含两个整数，为第1英里之前的车流量的最准确的可能范围。第二行包含两个整数，为第N英里之后的车流量的最准确的可能范围。输入保证存在符合要求的解。 Analysis前后扫一遍即可 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//正反各自扫一遍?过程中求交集和加减? #include&lt;bits/stdc++.h&gt;#define maxn 105#define inf 0x3f3f3f3f#define max(x,y) (x&gt;y)?x:y#define min(x,y) (x&lt;y)?x:yusing namespace std; int N;struct data&#123; char op[5]; int L,R;&#125;d[maxn];int main()&#123; freopen(&quot;traffic.in&quot;,&quot;r&quot;,stdin); freopen(&quot;traffic.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;N); int fs=0,fe=0; for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s%d%d&quot;,d[i].op,&amp;d[i].L,&amp;d[i].R); &#125; int FL=-inf,FR=inf,EL=-inf,ER=inf; for(int i=N;i&gt;=1;i--)&#123; if(d[i].op[0]==&#x27;n&#x27;)&#123; FL=max(FL,d[i].L); FR=min(FR,d[i].R); &#125; if(d[i].op[0]==&#x27;o&#x27;&amp;&amp;d[i].op[1]==&#x27;n&#x27;)&#123; FL-=max(d[i].R,d[i].L); FR-=min(d[i].L,d[i].R); &#125; if(d[i].op[1]==&#x27;f&#x27;)&#123; FL+=min(d[i].L,d[i].R); FR+=max(d[i].R,d[i].L); &#125; &#125; printf(&quot;%d %d\\n&quot;,max(FL,0),FR); for(int i=fe;i&lt;=N;i++)&#123; if(d[i].op[0]==&#x27;o&#x27;&amp;&amp;d[i].op[1]==&#x27;n&#x27;)&#123; EL+=min(d[i].L,d[i].R); ER+=max(d[i].L,d[i].R); &#125; if(d[i].op[1]==&#x27;f&#x27;)&#123; EL-=max(d[i].R,d[i].L); ER-=min(d[i].L,d[i].R); &#125; if(d[i].op[0]==&#x27;n&#x27;)&#123; EL=max(EL,d[i].L); ER=min(ER,d[i].R); &#125; &#125; printf(&quot;%d %d&quot;,max(EL,0),ER); fclose(stdin); fclose(stdout); return 0;&#125; PaintDescription​ $Todobe$要把她的寝室弄得漂漂酿酿，所以她管$Yashem66$要了一些墙纸。 ​ $Todobe$有一面墙，可分为n块，$Yashem66$提供的所有墙纸都是统一规格的，均只可覆盖连续k块完整的墙面，但是有m种不同的颜色的墙纸，每种颜色的墙纸都有无限张。$Todobe$要用这些墙纸把墙贴满，墙纸不可以裁剪，墙纸与墙纸之间可以有重叠部分。当墙纸重叠时，只能看到最外层的墙纸颜色。 ​ $Todobe$想知道她以不同的方式贴墙纸，共能贴出多少种不同配色方案的墙面，两种方案不同当且仅当两种方案中至少有一块墙面的颜色不同。 Input输入一行3个整数n,m,k。 Output输出一行一个整数代表方案数量，答案取模$1e9+7$ Analysis这一道题目很不好想，首先，对于$N$个块，$M$个颜色，一共有$M^N$种方案，然后通过模拟可以发现，这里面肯定有一个连续K个块是同一个颜色的，这就好了，联想到核电站问题的做法就可以了.但是因为数据范围很大，所以要用到矩阵乘法来优化，注意快速幂要开$long;long$否则会出错 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll mod=(ll)1e9+7;int N,M,K;ll A[105][105];ll qkpow(ll d,ll p)&#123; ll res=1; while(p)&#123; if(p&amp;1)res=(res*d)%mod; d=(d*d)%mod; p&gt;&gt;=1; &#125; return res;&#125;void mul(ll *a,ll (*b)[105])&#123; ll tmp[105]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=K-1;i++) for(int j=1;j&lt;=K-1;j++) (tmp[i]+=(a[j]*b[j][i]))%=mod; memcpy(a,tmp,sizeof(tmp));&#125; void mulslf(ll (*a)[105])&#123; ll tmp[105][105]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=K-1;i++)&#123; for(int j=1;j&lt;=K-1;j++)&#123; for(int k=1;k&lt;=K-1;k++)&#123; (tmp[i][j]+=a[i][k]*a[k][j])%=mod; &#125; &#125; &#125; memcpy(a,tmp,sizeof(tmp));&#125;ll mtrqkpow(int p)&#123; ll f[105]; memset(f,0,sizeof(f)); f[K-1]=M; for(int i=K-2;i&gt;=1;i--)&#123; f[i]=(f[i+1]*M)%mod; &#125; while(p)&#123; if(p&amp;1)mul(f,A); mulslf(A); p&gt;&gt;=1; &#125; return f[1];&#125;int main()&#123; freopen(&quot;paint.in&quot;,&quot;r&quot;,stdin); freopen(&quot;paint.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); ll res1=qkpow(M,N);//总的可能性 for(int i=1;i&lt;=K-1;i++)&#123; A[i][1]=M-1; A[i][i+1]=1; &#125; printf(&quot;%lld&quot;,(((res1-mtrqkpow(N-K+1))%mod)+mod)%mod); fclose(stdin); fclose(stdout); return 0; &#125; AirlineDescription​ $Todobe$Farmer John正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到T个城镇 (1 &lt;= T &lt;= 25,000)，编号为1到T。这些城镇之间通过R条道路 (1 &lt;= R &lt;= 50,000，编号为1到R) 和P条航线 (1 &lt;= P &lt;= 50,000，编号为1到P) 连接。每条道路i或者航线i连接城镇$A_i$ (1 &lt;= $A_i$ &lt;= T)到$B_i$ (1 &lt;= $B_i$ &lt;= T)，花费为$C_i$。对于道路，0 &lt;= $C_i$ &lt;= 10,000；然而航线的花费很神奇，花费$C_i$可能是负数(-10,000 &lt;= $C_i$ &lt;= 10,000)。道路是双向的，可以从$A_i$到$B_i$，也可以从$B_i$到$A_i$，花费都是$C_i$。然而航线与之不同，只可以从$A_i$到$B_i$。事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从$A_i$到$B_i$，那么保证不可能通过一些道路和航线从$B_i$回到$A_i$。由于$FJ$的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇S(1 &lt;= S &lt;= T) 把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。 Input第1行：四个空格隔开的整数: T, R, P, and S ,第2到R+1行：三个空格隔开的整数（表示一条道路）：$A_i$, $B_i$ 和 $C_i$, 第R+2到R+P+1行：三个空格隔开的整数（表示一条航线）：$A_i$,$ B_i$ 和$ C_i$ Output第1到T行：从S到达城镇i的最小花费，如果不存在输出”NO PATH” Analysis题目分析你以为这是一道$SPFA$水题？至少我当时是这么以为的，但是这一道题要卡你的$SPFA$所以说直接来就会爆，因此必须要想办法来优化 SLF优化这一个$SLF$优化说起来并不难，它将原来的队列转换成为了双端队列，对于加入的点$v$，如果说$dist[v]&lt;=dist[Q.top()]$,那么就把这个点放在队列的顶部，反之则将这个点放在最后面 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define maxn 25005#define maxe 50005 #define Int64 long long#define max(x,y) (x&gt;y)?x:y#define min(x,y) (x&lt;y)?x:yusing namespace std;int head[maxn],to[maxe&lt;&lt;2],nxt[maxe&lt;&lt;2],wel[maxe&lt;&lt;2],tot=0;;Int64 dis[maxn];int N,R,P,S;bool vis[maxn];int dfn[maxn],low[maxn],dfst=0,stk[maxn],top=0;int block[maxn],cnt=0;template&lt;typename t&gt;inline void read(t &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;inline void add(int x,int y,int z)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot; wel[tot]=z;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++dfst; stk[++top]=u; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!block[v])&#123; low[u]=min(dfn[v],low[u]); &#125; &#125; if(low[u]==dfn[u])&#123; block[u]=++cnt; while(stk[top]!=u)&#123; block[stk[top]]=cnt; top--; &#125; top--; &#125;&#125;void SPFA(int R,int w)&#123; deque&lt;int&gt;D; dis[R]=w; vis[R]=true; D.push_front(R); while(!D.empty())&#123; int u=D.front();D.pop_front(); vis[u]=false; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i],w=wel[i]; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; if(!vis[v])&#123; if(D.size()&amp;&amp;dis[v]&lt;=dis[D.front()])D.push_front(v); else D.push_back(v); vis[v]=true; &#125; &#125; &#125; &#125; &#125; int main()&#123;#ifndef ONLINE_JUDGE freopen(&quot;airline.in&quot;,&quot;r&quot;,stdin); freopen(&quot;airline.out&quot;,&quot;w&quot;,stdout);#endif read(N);read(R);read(P);read(S); for(int i=1;i&lt;=R;i++)&#123; int x,y,z;read(x);read(y);read(z); add(x,y,z);add(y,x,z); &#125; for(int i=1;i&lt;=P;i++)&#123; int x,y,z;read(x);read(y);read(z); add(x,y,z); &#125; tarjan(S); memset(dis,0x3f,sizeof(dis)); SPFA(S,0); for(int i=1;i&lt;=N;i++)&#123; if(dis[i]==0x3f3f3f3f3f3f3f3fl)printf(&quot;NO PATH\\n&quot;); else printf(&quot;%lld\\n&quot;,dis[i]); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SPFA","slug":"SPFA","permalink":"http://example.com/tags/SPFA/"},{"name":"SLF优化","slug":"SLF优化","permalink":"http://example.com/tags/SLF%E4%BC%98%E5%8C%96/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"20190820test","slug":"20190820test","date":"2021-09-05T02:20:22.627Z","updated":"2021-09-05T02:20:23.421Z","comments":true,"path":"2021/09/05/20190820test/","link":"","permalink":"http://example.com/2021/09/05/20190820test/","excerpt":"","text":"AgentDesciption IMF(不可能任务小组)有N个Agent，每个Agent的能力值互不相同，现在部长先生想要派出A,B两队Agent去参加特别任务。但是参加大战的两个队伍要满足两个要求： 1. A队中能力最大的Agent的能力值要小于B队能力最弱的Agent的能力值。 2. A,B两队都要有人参加。 并不是所有的Agent都要去参加的，心急的部长先生想知道有多少种安排Agent的方案。由于答案可能很大，所以只需要你求出答案模的值就可以了。 Input输入仅一行，为一个整数N。 Output输出答案模的值。 Analysis这一道题花了一点时间来推，就从$N==6$的情况来讨论一下： $1.$当$A$组当中只有$1$个的时候一共有: $31+15+7+3+1$种方法，这些都是$2^n-1$,没有什么问题，因为依次取$1,2,3…$你能够选的方案就是这么多，没有什么毛病（就是一个子集的问题，不过排除不选的方案） $2.$当$A$组当中只有$2$个的时候一共有：$15+7+3+1$种方法吗？不是的，这个时候因为当你选定$A$组最大的那一个的时候，剩余的小的那一个是还有选择的余地的，所以这里并不是这么多，而是要根据排列组合看一看。 $3.$到了这里的时候，差不多就可以看出规律来了，你会发现，这些$2^n-1$的系数，也是$2^x$,没错，这是因为你这样来看的时候，系数都是组合数，加起来就是$2^x$次方了 $4.$化简可以得到式子：$$2^0*(2^{n-1}-1)+2^1*(2^{n-2}-1)+……+2^{n-2}(2^1-1)\\\\=2^{n-1}(N-1)-2^{n-1}+1$$因此代码就呼之欲出了： 12345678910111213141516171819202122232425262728293031//好像找到规律了,但是找到了也一点都不好写 #include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll mod=1e9+7;ll N;inline ll qkpow(ll b,ll p)&#123; ll res=1; while(p)&#123; if(p&amp;1)res=res*b%mod; b*=b; b%=mod; p=p/2; &#125; return res;&#125;int main()&#123; //freopen(&quot;agent.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;agent.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld&quot;,&amp;N); ll idx=qkpow(2,N-1); ll res=(idx*(N-1))%mod; res=res-idx+1; printf(&quot;%lld&quot;,(res+mod)%mod); //fclose(stdin); //fclose(stdout); return 0; &#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://example.com/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"20190920周记","slug":"20190920","date":"2021-09-05T02:20:22.350Z","updated":"2021-09-16T03:59:33.583Z","comments":true,"path":"2021/09/05/20190920/","link":"","permalink":"http://example.com/2021/09/05/20190920/","excerpt":"","text":"Summary​ 我也不知道应该说一些什么，感觉就是很普通的一周。上周父亲带着我去买了一块表，感觉还不错。这周每天晚上都是延长了晚自习，一直到十点半的时候才从学校回来。这么一周下来感觉还是有一些累，回来锻炼，洗漱之后都是已经很晚了，然后早上再起来也是感觉有一些疲倦。至于各个学科，数学到时还不错,题目坐下来到时勉强算得上是顺手，物理化学也是还好。至于地理，感觉有的时候看到五三这些还是觉得不明所以，唉。 ​ 英语倒是感觉背单词的效率不是很高，没有找出足够多的时间来背，感觉一周七个$list$好像是成为了空谈。不过我还是在尽力，语文课，听33说话倒还是有一些意思。 ​ 自己闲暇的时光尝试去看了看$python$，感觉基本的操作倒也是不难，甚至尝试用$python$ AC了两道题目。虽然说$python$功能真的是很强大，但是确实是慢了一些，$C++$15 ms就可以A掉的题目，$python$要67 ms。 ​ 好简短的总结啊，唉，不想说了","categories":[{"name":"周记","slug":"周记","permalink":"http://example.com/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"20191022考试总结","slug":"20191022考试总结","date":"2021-09-05T02:20:22.253Z","updated":"2022-01-23T07:54:37.136Z","comments":true,"path":"2021/09/05/20191022考试总结/","link":"","permalink":"http://example.com/2021/09/05/20191022%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"XorarrayDescription xor——异或，和 and 与or 一样，是一种重要的逻辑运算，他的运算规律是 0 xor 0 = 0，1 xor 1 = 0，1 xor 0 = 1，0 xor 1 = 1 两个整数之间的异或是将两个整数转化成二进制，对他们的每一位分别进行 xor 操作，例：6(110) xor 13(1101) = 11(1011) 现在我们要介绍一种新的操作——数组异或，将两个相同大小（假设都为n）的数组A、B异或成一个新数组C，则新数组必满足:$$C[k]=\\sum_i^{k}\\sum_j^{k}\\ A[i]\\bigoplus B[i]$$ 现在给你数组大小n，和两个数组A,B 求他们的异或数组C 由于最终答案可能过大，你需要对C的每个元素对$1e9+7$取模 Input 一共3行。 第一行一个正整数N。 接下来两行每行N个正整数，表示数组A、B。 Output 一共1行，N个正整数，表示数组C。 Analysis我，我mod少打了一个0，直接就爆0了,$qwq$,太惨了。 这一道题目的核心在于，因为对于每一个$C[k]$的值，考虑将所有的$A[i]$,$B[i]$中每一位中的0的个数,1的个数计算出来，每一位A的0的个数和B的1的个数，B的0的个数和A的1的个数相乘，然后加起来，这样就可以得到这一位上面异或所产生的总的1的个数是多少，而这里面的1是二进制下面的，因此需要还原回去乘以对应的幂次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn=100005;const LL mod=1000000007;LL A[maxn],B[maxn],C[maxn],N;LL cntA[40][2],cntB[40][2]; template&lt;typename t&gt;inline void read(t &amp;x);void solve(); int main()&#123; freopen(&quot;xorarray.in&quot;,&quot;r&quot;,stdin); freopen(&quot;xorarray.out&quot;,&quot;w&quot;,stdout); read(N); solve(); fclose(stdin); fclose(stdout); return 0;&#125;template&lt;typename t&gt;inline void read(t &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;void solve()&#123; for(int i=1;i&lt;=N;i++)read(A[i]); for(int i=1;i&lt;=N;i++)read(B[i]); for(int i=1;i&lt;=N;i++)&#123; LL now; for(int j=0;j&lt;=31;j++)&#123; cntA[j][(A[i]&gt;&gt;j)&amp;1]++; cntB[j][(B[i]&gt;&gt;j)&amp;1]++; now=(cntA[j][0]*cntB[j][1]+cntB[j][0]*cntA[j][1])%mod; (now&lt;&lt;=j)%=mod; (C[i]+=now)%=mod; &#125; cout&lt;&lt;C[i]&lt;&lt;&quot; &quot;; &#125;&#125; RoadDescription 给出一个 N 个点的有向图，每个点的出度恰好为一。 现在希望给这 N 条边重定向，求图中不出现环的方案数（对$1e9$+7取模）。 Input 第一行一个正整数 N。 第二行 N 个正整数 $X_i$，表示存在一条有向边 i 指向 $X_i$。 Output 一行，一个整数 Ans，表示定向后不出现环的方案数。 Analysis这一道题目，思路其实很简单，首先这个原图里面肯定是存在环的，如果说要让这个环不再是环的话，那么只需要让环里面任意条边反向就可以了，但是不可以全部反向或不反向。考虑强连通分量缩点来得到每一个环的点的个数是多少(以下记作size) 若是缩点之后，$size&gt;1$,那么让这里面的边反过来的方案数就有$$\\C_{size}^1+\\C_{size}^2+……+\\C_{size}^{size-2}+\\C_{size}^{size-1}$$ 根据所学过的排列组合的知识，可以化简为$2^{size}-2$ 若是缩点之后，$size=1$,那么这一条边反不反向都是可以的，直接乘个2就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define maxn 100005const int mod=(int)1e9+7;int N,tot=0,dfst=0,CntBlocks=0;int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];int low[maxn],dfn[maxn],Belong[maxn];int stk[maxn],Blocksize[maxn];void add(int x,int y)&#123;to[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void tarjan(int u); LL qkpow(LL p); int main()&#123; freopen(&quot;road.in&quot;,&quot;r&quot;,stdin); freopen(&quot;road.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;N);int t; for(int i=1;i&lt;=N;i++)scanf(&quot;%d&quot;,&amp;t),add(i,t); for(int i=1;i&lt;=N;i++)if(!dfn[i])tarjan(i); LL ans=1; for(int i=1;i&lt;=CntBlocks;i++)&#123; if(Blocksize[i]==1)&#123; (ans*=2)%=mod; &#125; else&#123; LL t=qkpow(Blocksize[i]); ans=(ans*t)%mod; &#125; &#125; cout&lt;&lt;ans; fclose(stdin); fclose(stdout); return 0;&#125;void tarjan(int u)&#123; stk[++stk[0]]=u; low[u]=dfn[u]=++dfst; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!Belong[v]) low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u])&#123; CntBlocks++; while(stk[stk[0]]!=u)&#123; Belong[stk[stk[0]]]=CntBlocks; Blocksize[CntBlocks]++; stk[0]--; &#125; Belong[u]=CntBlocks; Blocksize[CntBlocks]++; stk[0]--; &#125;&#125;LL qkpow(LL p)&#123; LL res=1; LL now=2; while(p)&#123; if(p&amp;1)res=(res*now)%mod; (now*=now)%=mod; p&gt;&gt;=1; &#125; return res-2;&#125; DetectiveDescription 小W最近沉迷一个侦探游戏，在这个游戏中会不断出现命案，而小W作为主角，需要不断地收集各种关键证据，只有当所有的关键证据都被找到，你才能驳倒所有人错误的判断，找出真正的凶手。 一共有N个关键证据以及M条信息，每条信息如下所示 : 如果你已经掌握了证据 i ，那么你可以通过 k 个时间的搜索和推理得到证据 j ，同样的，如果你掌握了证据 j 你也可以通过 k 个时间得到证据 j 。 游戏开始时玩家通过初步观察现场已经得到了证据1，于此同时，每个玩家在游戏开始阶段时都能获得一个特殊技能来加快游戏进度，增加趣味性。小 W 选了一个他以前从来没用过的技能 : 好运。这是一个被动技能，系统会在游戏开始时选定一对证据（a，b）当小W发现其中一个证据的时候，他会很好运地立即获得另外一个证据（不计入时间）。 但是这个技能是完全随机的，小W完全不知道进入游戏后系统会挑选哪一对证据，他希望你能帮助他算出他花在本轮游戏上的时间的期望值，这样他心里能有点B数。 提供的信息保证 : i不会等于j，每个k值都互不相同，N个证据都能被得到。 Input 一共M+1行。 第一行两个正整数N,M，表示证据数量和信息数量。 接下来M行，每行三个数字i,j,k表示一个信息 Output 一共1行，1个整数（期望值是实数，但这里请直接保留0位小数输出） Analysis​ 如果说没有这个讨厌的被动技能的话，那么也就不会有这该死的期望了，那么也就是一个最小生成树就好了。 ​ 但这是不可能的，这辈子都不可能的。 ​ 首先来想一想，找到所有的证据之后，形成的那一张图，应当是一棵树，没有错吧，这一个神奇的被动技能，能都把其中一条边替换为0，这样的话通过枚举点对，我们就可以很轻松的得到错误的解法了 ​ 换一个思路，考虑在$Kruscal$制造这一棵树的时候来进行统计，每当我们选择一条边的时候，那么它所连接的两棵子树内所有的边，是不是都比它小，那么此时替换它为0的话，无疑就会使最划算的，也就是符合要求的。此时替换会减少的值为这一条边的权值乘以旁边的两棵子树的大小再来除以选择它的概率。那么答案就等于$$Ans=W-\\sum\\frac{2dsize(u)size(v)}{N(N-1)}$$其中W是最小生成树的值，d是选择的边的权值，size(u),size(v)是选择的时候两棵子树的大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 20005#define db doubleint N,M;int fa[maxn],size[maxn];struct edge&#123; int u; int v; int d; bool operator &lt;(const edge &amp;cmp)const&#123; return d&lt;cmp.d; &#125;&#125;E[maxn*5];void Kruscal();int Seek(int x);void Union(int x,int y); int main()&#123; freopen(&quot;detective.in&quot;,&quot;r&quot;,stdin); freopen(&quot;detective.out&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(false); cin&gt;&gt;N&gt;&gt;M; for(int i=1;i&lt;=M;i++)&#123; int u,v,d;cin&gt;&gt;u&gt;&gt;v&gt;&gt;d; E[i]=(edge)&#123;u,v,d&#125;; &#125; sort(E+1,E+1+M); Kruscal(); fclose(stdin); fclose(stdout); return 0;&#125; int Seek(int x)&#123; if(x!=fa[x])return fa[x]=Seek(fa[x]); return fa[x];&#125;void Union(int x,int y)&#123; fa[x]=y; size[y]=size[y]+size[x];&#125;void Kruscal()&#123; for(int i=1;i&lt;=N;i++)fa[i]=i,size[i]=1; int cnt=0; db off=0; long long ans=0; for(int i=1;i&lt;=M;i++)&#123; int u=E[i].u; int v=E[i].v; int d=E[i].d; int fu=Seek(u); int fv=Seek(v); if(fu!=fv)&#123; cnt++; ans+=d; off+=((2*(double)d*(double)size[fu]*(double)size[fv])/(double)(N*(N-1)+0.0)); Union(fu,fv); &#125; if(cnt==N-1)break; &#125; printf(&quot;%.2lf&quot;,ans-off);&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"},{"name":"期望","slug":"期望","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"K-D tree入门","slug":"K-D tree","date":"2021-09-05T02:20:22.239Z","updated":"2021-09-05T02:20:22.644Z","comments":true,"path":"2021/09/05/K-D tree/","link":"","permalink":"http://example.com/2021/09/05/K-D%20tree/","excerpt":"","text":"KNN问题​ K-Nearest Neighbor，我也不知道应该说是问题还是算法，也就不要管这个了。我们想象这样一个场景，在一个平面直角坐标系上面，有很多很多个点。现在我们随机地选择一个点，想要知道离他最近的$k$个点是哪些，怎么办。如果使用肉眼观察的话，那么我们是可以大致判断出来有哪些的。可是在很多时候，我们拿到的并不是图像，而是数据，而这些数据要让计算机来处理，怎么办？？ ​ 对于这一个问题，我们可以用时间复杂度为$\\Theta(n^2)$的方法，处理出所有的距离，询问到处理的距离里面来看，但是我们还可以有别的方法。 K-D tree概念​ K-D tree 是一棵二叉查找树,它可以用来维护有多维信息的数据。因为在做题的时候，遇到的一般都是$2$维,所以说下面的例子我就以二维的来看了 建立解释​ 平常的二叉查找树，建立的时候，在每一个中间节点，会比较值的大小，比他小的就到他的左儿子那边，比他大的就到他的右儿子那边。但是K-D tree 有多维信息，这种情况下应该怎么办？既然他是有K维的信息，那么我们就任意选择其中以为来进行分割就可以了。这就好像是在平面中画了一条线一样，将它们分成了两个部分​ 比如下面的这一个，这是一个这个平面上有很多点，我们先选取其中一维进行分割，分成了两块，然后我们换一维继续分割 ​ 就这个样子交替分割下去就可以了，听着是不是就像切蛋糕一样？ ​ 那么怎么来进行分割呢，有下面两种方法： 根据深度，轮流来选择一个维度，依据这一个维度来进行划分。在划分的时候将区间内的值依照这一维的大小来进行排序，然后将中位数存下来，然后再递归的处理 我们计算一下每一维的方差，然后选择方差最大的那一维来进行划分。为什么要这样来进行划分，举个例子，如果说是一块方方正正的豆腐，那么不无论选择那一维来切，效果都是很好的。但是呢，如果说是一根细长木条呢？你轮流切未必就有一个好效果。选择计算每一维的方差，选择方差最大的那一维来的话，能够在构建树上起到很好的效果。 (假)代码首先，我们需要一个结构体 12345678struct K_D_Tree&#123; node d[maxn]; int lc[maxn]; int rc[maxn];#define D(i,j) d[i].databank[j]#define Minp(i,j) d[i].minpos[j]#define Maxp(i,j) d[i].maxpos[j]&#125; ​ 其中$node$是用来储存信息的结构体，然后来看看第一种方法如何来进行$build$ 1234567891011int build(int L,int R,int deps)&#123; if(L&gt;R)return 0; int mid=(L+R)&gt;&gt;1; keyd=deps%maxk; nth_element(point+L,point+mid,point+R+1); d[mid]=point[mid]; lc[mid]=build(L,mid-1,deps+1); rc[mid]=build(mid+1,R,deps+1); pushup(mid); return mid; &#125; ​ 这里$pushup$这个函数在接下来会讲，所以说先看着。nth_element 这一个函数第一个和第三个参量是左右区间，左闭右开，而中间的这一个则是你要排的值。像是上面代码中的那个例子，在point+mid这个位置，一定就是这个区间的中位数，前面都比它小，后面都比他大，但是前面后面未必就排好了序。 ​ 第二种方法（假代码） 1234567891011121314for(int i=0;i&lt;maxk;i++)&#123; double aver=var[i]=0.0; for(int j=L;j&lt;=R;j++) aver+=D(j,i); aver/=(R-L+1); for(int j=L;j&lt;=R;j++)&#123;&#125; var[i]+=((D(j,i)-aver)*(D(j,i)-aver)); &#125;//计算方差 dim[now]=0; for(int i=1;i&lt;k;i++)&#123; if(var[dim[now]]&lt;var[i])dim[now]=i; &#125; nth_element(……) //还要记录一下维度,然后和上面一样递归处理就可以了 查询K-D tree 的K近邻查询​ 我们之前提到了，要查询离某一个节点第$k$远（当然也可能是第$k$近）的节点的编号，或者是这一个距离。首先，这个第$k$远怎么办，怎么来记录，这个时候就可以想到优先队列了，每一次询问的时候，我们在优先队列里面先$push$ k个值进去，然后呢，查询的时候，遇到符合要求的数值，就把队首$pop$出来，然后再$push$进去，这样就可以保证我们总是维护好了第$k$远或者第$k$近了。 ​ 接下来来谈一谈如何查询，首先我们遍历到某一个节点，然后计算一下这一个节点和目标节点之间的距离，看看这一个距离是否符合要求，如果符合我们的要求，那么我们就更新一下，接着，以目标节点作为圆心，现在的答案的距离作为半径，然后做一个圆（三维的情况下是一个球，如果更多的话，那么就是超球体了）然后看看这一个圆有没有和我们遍历到的节点划分的左右平面(多维的话，按照网上的叫法就是超平面了)相交。如何判断？我们计算一下目标节点到左右平面的最小距离(注意，这里是在说第k近的情况)，如果说这个距离要比我们现在所说的这一个答案要小的话，那么就到这个平面里面去搜索，而如果是第k远的的情况下面，就是计算最远的距离是多少，然后再来判断了 ​ 可是现在还有一个问题，怎么来确定离左右平面的距离？这个时候就可以记录下每一个节点的子树下面，某一维最大最小的值是多少，建立的时候$pushup$一下，计算的时候就可以用了 123456789101112131415161718192021222324252627282930313233struct node&#123; double databank[2]; double minpos[2]; double maxpos[2]; bool operator &lt;(const node &amp;cmp)const&#123; return databank[keyd]&lt;cmp.databank[keyd]; &#125;&#125;point[maxn]; struct K_D_Tree&#123; node d[maxn]; int lc[maxn]; int rc[maxn];#define D(i,j) d[i].databank[j]#define Minp(i,j) d[i].minpos[j]#define Maxp(i,j) d[i].maxpos[j] inline void pushup(int now)&#123; if(lc[now])&#123; for(int i=0;i&lt;maxk;i++)&#123; Minp(now,i)=min(Minp(now,i),Minp(lc[now],i)); Maxp(now,i)=max(Maxp(now,i),Maxp(lc[now],i)); &#125; &#125; if(rc[now])&#123; for(int i=0;i&lt;maxk;i++)&#123; Minp(now,i)=min(Minp(now,i),Minp(rc[now],i)); Maxp(now,i)=max(Maxp(now,i),Maxp(rc[now],i)); &#125; &#125; &#125; &#125;; ​ 如果是计算最远的距离的话，那么每一维直接就是求距离的公式累加起来就可以了，最近的情况下面，则是如果处于最大最小区间以内，则是不用加，否则这一维取最小的来 ​ 用图片来表示的话，大概就是这样 上面的图就分别对应了第$k$近和第$k$远了 12345678inline double getrange(int p,int pos)&#123; double res=0; if(Minp(pos,0)&gt;D(p,0))res+=sqar(Minp(pos,0)-D(p,0)); if(Maxp(pos,0)&lt;D(p,0))res+=sqar(Maxp(pos,0)-D(p,0)); if(Minp(pos,1)&gt;D(p,1))res+=sqar(Minp(pos,1)-D(p,1)); if(Maxp(pos,1)&lt;D(p,1))res+=sqar(Minp(pos,1)-D(p,1)); return res;&#125;//第k近 123456inline ll disrange(node pos,int nowp)&#123; ll res=0; for(int i=0;i&lt;maxk;i++) res+=max(sqar(pos.databank[i]-Minp(nowp,i)),sqar(pos.databank[i]-Maxp(nowp,i))); return res;&#125; 数据类型不一样是因为不是从同一道题目上摘下来的，不要在意 那么这样一来，查询的代码就差不多可以写出来了 123456789101112131415161718192021222324void query(int L,int R,int p)&#123; if(L&gt;R)return; int mid=(L+R)&gt;&gt;1; if(mid!=p)&#123; ll res=0; for(int i=0;i&lt;maxk;i++) res+=sqar(D(mid,i)-D(p,i)); if(res&gt;que.top())&#123; que.pop(); que.push(res); &#125; &#125; ll disl=0,disr=0; disl=range(p,lc[mid]); disr=range(p,rc[mid]); if(disl&gt;disr)&#123; if(disl&gt;que.top())query(L,mid-1,p); if(disr&gt;que.top())query(mid+1,R,p); &#125; else&#123; if(disr&gt;que.top())query(mid+1,R,p); if(disl&gt;que.top())query(L,mid-1,p); &#125; &#125; 这里就只写贴一个查询第$k$远的了 K-D tree 的查询时间复杂度据说是 $\\Theta(\\sqrt N)$ 但是在某一些情况下面，它的时间复杂度还是会退化到接近$\\Theta(N)$来，比如说 所有的节点分布大致构成了一个圆，而你查询的节点差不多就是在圆心位置。 当然，设节点数为$K$,维度为$D$,只有当$K &gt;&gt; 2^D$的时候，K-D tree的效率才可以保证，当然，维数如果说高了的话，效率也是无法保证的。想K-D tree这样可以解决多维信息的树还有别的，比如说球树等等，我就不说了。因为我不会用。而如果想要解决更高维的信息，还想要保证效率的话，那么还有一种方法 BBF 算法​ 首先，我们需要另外一个优先队列。同时还需要一个对回溯次数限制的值，这个值是依据大量的结果取定的，我也不知道应该给你一个多少比较好。这个$BBF$算法的核心就在于决定一个优先级和最大回溯次数。这个优先级还是之前所说的距离来当。每一次查询到某一个节点的时候，还是计算出左右儿子和目标节点距离，然后进入其中一个查询，把另一个连同树上的位置和优先级一起放进优先队列里面来。然后查询一直到达叶子结点。如果队列不为空且没有到达最大回溯次数，那么就从队列里面拿出队首来进行查询。 插入，删除和重构插入这个时候，到达某一个节点，然后根据这个节点划分的维度，依次往下去，知道叶子节点为止，然后加上来就可以了 12345678910111213141516171819void insert(int now,node p,int deps)&#123; //插入操作，常规 keyd=deps%maxk; if(p.databank[keyd]&lt;=D(now,keyd))&#123; if(lc[now]==0)&#123; lc[now]=++tot; d[tot]=p; &#125; else insert(lc[now],p,deps+1); &#125; else&#123; if(rc[now]==0)&#123; rc[now]=++tot; d[tot]=p; &#125; else insert(rc[now],p,deps+1); &#125; pushup(now);&#125; 差不多，就这样吧…… 删除K-D tree的删除操作，对于没有后继节点的节点，那么就直接删除了就好，但是如果说有后继节点的话，你就从它的左子树中，找出这一维最小的那一个值，或者是右子树中找出最大的那一个值，然后再把把那一个值从原来的树中删除了……这是一个递归实现的过程。 重构当插入删除操作进行了一定次数以后，重新用一次$build$就好了。当然也可以类似替罪羊树那样，选择一个规定的$\\alpha$，如果说不符合要求再使用一次$build$,不过我觉得还是一种方法更好 参考oi-wiki KD树（网易游戏笔试） Kd-Tree算法原理和开源实现代码 K-D tree 数据结构","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"K-D tree","slug":"K-D-tree","permalink":"http://example.com/tags/K-D-tree/"}]},{"title":"LuoguP1005","slug":"LG1005","date":"2021-09-05T02:20:22.189Z","updated":"2021-09-05T02:20:22.756Z","comments":true,"path":"2021/09/05/LG1005/","link":"","permalink":"http://example.com/2021/09/05/LG1005/","excerpt":"","text":"LG1005十年以前，提高组的题目居然要写高精度！！！！ 这不是摆明了刁难人吗！！！！！！！ Analysis你需要写的高精度： 高精度加法 高精度比较大小 高精度乘高精度 高精度乘低精度 高精度赋初值 虽然这一道题目是一道$dp$，但是高精度完全抢走了所有的风头 关于着一道题目的$dp$，首先，就是在于每一行都是独立的，互相影响，所以说每一行单独来$dp$就可以了。 我们设$f[i][j]$来表示$[i,j]$区间里面的最优情况，他可能是是从$[i+1,j]$和$[i,j-1]$两种情况推过来的，所以说因此就可以得出他的方程了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define maxn 85#define carry 1000using namespace std;int N,M;int matrix[maxn][maxn];struct Largenum&#123; int val[maxn]; int operator [](const int &amp;ref)const&#123; return val[ref]; &#125; Largenum(int a)&#123; memset(val,0,sizeof(val)); int pos=1; while(a)&#123; val[pos]=a%carry; a/=carry; pos++; &#125; val[0]=pos; &#125; Largenum(void)&#123; memset(val,0,sizeof(val)); &#125; inline void output()&#123; printf(&quot;%d&quot;,val[val[0]]); for(int i=val[0]-1;i&gt;=1;i--) printf(&quot;%03d&quot;,val[i]); //大家都懂的，我这里是每一位存了一个三位数 &#125; Largenum operator +(const Largenum &amp;obj)const&#123; Largenum cmp; int add=0,pos=max(val[0],obj.val[0]); for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=obj.val[i]+val[i]+add; add=cmp.val[i]/carry; cmp.val[i]%=carry; &#125; if(add&gt;0)cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; bool operator ==(const Largenum &amp;obj)const&#123; if(val[0]!=obj[0])return false; for(int i=1;i&lt;=val[0];i++)if(val[i]!=obj[i])return false; return true; &#125; bool operator &lt;(const Largenum &amp;obj)const&#123; if(val[0]&gt;obj[0])return false; if((*this)==obj)return false; if(val[0]&lt;obj[0])return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i])return false; if(val[i]&lt;obj[i])return true; &#125; return true; &#125; //这个是状态转移比较大小用的 Largenum operator *(const Largenum &amp;obj)const&#123; Largenum cmp; int pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/carry; cmp.val[i+j-1]=cmp.val[i+j-1]%carry; &#125; &#125; while(cmp.val[pos]==0&amp;&amp;pos&gt;1)pos--; cmp.val[0]=pos; return cmp; &#125; Largenum operator *(const int &amp;obj)const&#123; Largenum cmp; int pos=val[0];int add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/carry; cmp.val[i]=cmp.val[i]%carry; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%carry; add/=carry; &#125; while(cmp.val[pos]==0&amp;&amp;pos&gt;1)pos--; cmp.val[0]=pos; return cmp; &#125;&#125;two[maxn],f[maxn][maxn],ans(0);void init(int M)&#123; two[0]=Largenum(1); for(int i=1;i&lt;=M;i++) two[i]=two[i-1]*2;//预处理一下 &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++) scanf(&quot;%d&quot;,&amp;matrix[i][j]); //f[i][j]表示选择[i,j]区间时的最大值，它从f[i+1][j]和f[i][j+1]这两步枚举过来 init(M); for(int k=1;k&lt;=N;k++)&#123; memset(f,0,sizeof(f)); for(int t=0;t&lt;M;t++)&#123; for(int i=1;i+t&lt;=M;++i)&#123; int j=i+t; int pw=M-t; //因为f[i][j]的定义，所以说这里是从短到长的来推的 //短的时候呢，乘的那一个数也要大一点 Largenum fir=(f[i+1][j]+two[pw]*matrix[k][i]); Largenum sec=(f[i][j-1]+two[pw]*matrix[k][j]); if(fir&lt;sec)f[i][j]=sec; else f[i][j]=fir; &#125; ans=ans+f[1][M]; &#125; &#125; ans.output(); return 0;&#125;","categories":[{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"区间dp","slug":"区间dp","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4dp/"}]},{"title":"LuoguP1373","slug":"LGP1373","date":"2021-09-05T02:20:21.881Z","updated":"2021-09-05T02:20:22.324Z","comments":true,"path":"2021/09/05/LGP1373/","link":"","permalink":"http://example.com/2021/09/05/LGP1373/","excerpt":"","text":"LGP1373Analysis这一道题目，首先，因为是交替进行，所以要有一维来表示是两个人中的哪一个，其次，这是一个矩阵，还要有矩阵的位置，最后，因为只有双方的魔液数量相同的时候才可以活下来，所以说应该还有一维来记录双方魔液的差值。对于状态转移方程，先做出如下约定： 1-&gt;小A, 0-&gt;uim 差值为：小A的魔液减去uim的魔液 对于小A:$$f[i][j][k][1]+=f[i-1][j][(k-mat[i][j]+md)\\mod md][0]\\\\f[i][j][k][1]+=f[i][j-1][(k-mat[i][j]+md)\\mod md][0]$$对于uim:$$f[i][j][k][0]+=f[i-1][j][(k+mat[i][j])\\mod md][1]\\\\f[i][j][k][0]+=f[i][j-1][(k+mat[i][j])\\mod md][1]$$ 对于差值，如果说这一步是小A拿到魔液的话，那么双方的差值就应该增大，所以说这一步应该是从减去这么多魔液的地方转移过来的，同样如果说是uim拿到了魔液的话，双方的差值就会减少，所以说因该就是从增加了这么多魔液的地方转移过来的 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define mod 1000000007#define maxn 802using namespace std;int mat[maxn][maxn];int f[maxn][maxn][18][2];int N,M,K;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++)&#123; scanf(&quot;%d&quot;,&amp;mat[i][j]); mat[i][j]%=(K+1); f[i][j][mat[i][j]][1]=1; &#125; const int md=K+1; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=M;j++)&#123; for(int del=0;del&lt;=K;del++)&#123; (f[i][j][del][1]+=f[i-1][j][(del-mat[i][j]+md)%md][0])%=mod; (f[i][j][del][1]+=f[i][j-1][(del-mat[i][j]+md)%md][0])%=mod; (f[i][j][del][0]+=f[i-1][j][(del+mat[i][j])%md][1])%=mod; (f[i][j][del][0]+=f[i][j-1][(del+mat[i][j])%md][1])%=mod; &#125; &#125; &#125; long long ans=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=M;j++)&#123; (ans+=f[i][j][0][0])%=mod; &#125; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"}]},{"title":"LuoguP4377","slug":"LGP4377","date":"2021-09-05T02:20:21.841Z","updated":"2022-04-24T08:58:18.250Z","comments":true,"path":"2021/09/05/LGP4377/","link":"","permalink":"http://example.com/2021/09/05/LGP4377/","excerpt":"","text":"LGP4377Analysis今天考试，$Mr.Yu$疯狂暗示，难道不是递增的哦 所以说我一来就开始看第三题，显示贪心错了大样例，然后就决定$dp$了，想不到居然对了，开心。 后面到网上来看题解，全部都是0/1分数规划，我震惊了，嗯，想不到啊。 这里来谈一谈我的做法，设$f[i]$表示才艺之的总之为$i$的时候最小的重量是多少，之所以要这么来设计是因为才艺值是固定的，重量值越小的时候，才艺值就越大，然后每一头奶牛只能够选一次，那么不就是一个0/1背包的模板题，最后来扫一遍得到答案吗 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445/* *学学背包问题： *f[i]表示总才艺值为i时，最小的重量是多少 *f[i]=min(f[i],f[i-t[i]]+w[i]); */ #include&lt;bits/stdc++.h&gt;#define maxn 255#define inf 1e-6using namespace std; struct cow&#123; int w;//重量 int t; &#125;fj[maxn];int f[maxn*1000];int N,W; int main()&#123; freopen(&quot;show.in&quot;,&quot;r&quot;,stdin); freopen(&quot;show.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;N,&amp;W); int maxt=0; for(register int i=1;i&lt;=N;i++)&#123; scanf(&quot;%d%d&quot;,&amp;fj[i].w,&amp;fj[i].t); maxt+=fj[i].t; &#125; memset(f,0x3f,sizeof(f)); //0x3f3f3f3f很大，f[i]里面的值并不会很大，所以说不会影响结果 f[0]=0; for(register int i=1;i&lt;=N;i++)&#123; for(register int j=maxt;j&gt;=fj[i].t;j--)&#123; f[j]=min(f[j],f[j-fj[i].t]+fj[i].w); &#125; &#125; double ans=0; for(register int i=1;i&lt;=maxt;i++)&#123; if(f[i]&gt;=W)ans=max(ans,i/(f[i]+0.0)); &#125; ans*=1000; printf(&quot;%d&quot;,(int)ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"Polya定理","slug":"Polya定理和母函数","date":"2021-09-05T02:20:21.823Z","updated":"2021-09-05T04:36:02.769Z","comments":true,"path":"2021/09/05/Polya定理和母函数/","link":"","permalink":"http://example.com/2021/09/05/Polya%E5%AE%9A%E7%90%86%E5%92%8C%E6%AF%8D%E5%87%BD%E6%95%B0/","excerpt":"","text":"群论今天学习了一点很厉害的知识，我简要记录一下，方便日后再来复习，不过并不是十分地详尽。在了解什么是$Polya$定理之前，先让我们来看一看什么是群。这个知识可以是为后面奠基的。 定义群是一个集合，它满足运算$*$，这个运算是经过定义的，可以是加法，可以是乘法，也可以是其它的运算法则。作为一个群，它具有以下的性质: 封闭性:$\\forall a,b\\in G,\\exists c\\in G,a*b=c$ 结合律: $\\forall a,b,c\\in G,(ab)c=a(bc)$ 单位元: $\\exists e\\in G,\\forall a\\in G,ae=ea=a$ 逆元: $\\forall a\\in G,\\exists b\\in G,ab=ba=e,b=a^{-1}$ 举个例子，所有的整数就可以算作是一个群，这里的运算就是加法，我们带进去看一看，会发现所有的性质是满足的。没错就这样 置换$N$个元素$1,2,3,\\cdots,N$之间的置换，然后把它换成$1,2,3,\\cdots,N$的一个全排列就对了，就是这么理解的，写作：$$\\begin{pmatrix}1&amp;2&amp;3&amp;\\cdots&amp;N\\\\a_1&amp;a_2&amp;a_3&amp;\\cdots&amp;a_n\\end{pmatrix}$$就是长成这个样子的了 置换群这是一个元素是置换的群，它的运算是置换的连接。这个东西听起来很玄对不对，对了，这个东西听起来就是很玄的，因为它本来就是这么的玄，下面我们看一个例子来理解一下，比如下面两个群我们来运算一下：$$\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\3&amp;1&amp;2&amp;4\\end{pmatrix}\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\4&amp;3&amp;2&amp;1\\end{pmatrix}=\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\3&amp;1&amp;2&amp;4\\end{pmatrix}\\begin{pmatrix}3&amp;1&amp;2&amp;4\\\\2&amp;4&amp;3&amp;1\\end{pmatrix}=\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\2&amp;4&amp;3&amp;1\\end{pmatrix}$$下面解释一下这个运算，首先，先把第二个置换换一换位置，这一下他的第一行顺序是不是就和第一个置换的第二行一样了？然后这个时候再来看，第一个置换里面，1置换成了3，到了第二个置换里面，3又是置换成了2，对不对？这就相当于是1置换成了2，其他的元素我们以此类推，就可以得到最后一个置换了。 而这一个置换群，也是满足四个性质的，为什么？我想封闭性是显然的吧，至于其他的？我怎么可能知道？我都是不知道的了，那么我还讲什么 一个神奇的式子和概念$$|Z_k|*|E_k|=|G|$$ 首先，这个并不是绝对值的意思，而是说这几个分别是有多少的个数，下面一一说明每一个的意义是什么 $|Z_k|$:设$G$是$1,2,3,\\cdots,N$的置换群，$k$是$1,2,3,\\cdots,N$中的某一个元素，$G$中使$k$不变的置换，记作$Z_k$ $|E_k|$:等价类。$k$在$G$作用下的轨迹，即$k$在$G$作用下，产生的所有元素集合 证明： 请自行百度，谷歌，或者必应。 Polya定理Burnside引理我们不妨假设$D(a_j)$是置换$a_j$下面不变的元素个数，那么就很容易就有一个式子$$\\sum_{i=1}^{n}|Z_j|=\\sum_{i=1}^{s}|D(a_i)|$$我们接着往下面推$$\\sum_{i=1}^{n}|Z_j|=\\sum_{i=1}^{s}|D(a_i)|\\\\=\\sum_{i=1}^{L}\\sum_{k\\in|E_i|}|Z_k|$$这里不难理解吧，我们假设一共有$L$个等价类，各个等价类加起来实际上和原来是一样多的，对吧,然后 $$=\\sum_{i=1}^{L}|E_i||Z_i|\\\\=\\sum_{i=1}^{L}|G|=L|G|\\\\L=\\frac{1}{|G|}\\sum_{i=1}^{n}|Z_i|=\\frac{1}{|G|}\\sum_{i=1}^{n}|D(a_i)|$$ 可是，虽然我们得到了这一个式子，但是啊，难道这一个$|Z_i|$,或者$D(a_j)$什么的，难道很好算吗？，一点都没有啊，所以说接下来还是得来看一看$Polya$定理 Polya定理循环这个真的就是一个很神奇的东西，简单的来说就是一种来表示置换的方法，来看看下面这一个例子$$\\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;5\\\\3&amp;5&amp;1&amp;4&amp;2\\end{pmatrix}=(13)(25)(4)$$这样的表示是唯一的，每一个置换都可以写成若干个互不相交的循环的乘积（我想这里肯定又是重新定义了一下），对于这些循环的个数就叫做循环节数（名字听起来和小学学的小数的循环节差不多，但是要难的多） Polya定理的表达式既然我们已经是知道了什么是循环，那么我们终于是可以写出这个该死的$Polya$定理的表达式了$$L=\\frac{1}{|G|}(m^{c(g1)}+m^{c(g2)}+\\cdots+m^{c(g_n)})$$其中$G$是${g_1.g_2,g_3\\cdots,g_n}$,$c(g_i)$表示置换$g_i$的循环节个数，这一个式子看起来很神奇对吧，实际上和上面的$Burnside$引理是差不多的，只是换了一种表达的方式，这是前人们通过观察证明得出来的结论，这意味着我并不知道如何从$Burnside$引理推到$Polya$定理。 Polya定理的运用下面让我们来看一道题目，这一道题目和方格子着色有关 对于一个2*2的矩阵，选择用黑白两种颜色来进行着色，如果说经过了旋转以后，得到的图形是相同的话，那么认为是同一种染色的方案。 因为数据很小，所以说可以通过枚举的方式得出所有的可能性： 我们可以看出，如果说是不重复的话，那么一共就有16种方案，但是如果说是要去除掉重复的方案的数量的话，那么就是一共有6种了。尽管说从目前的数据规模来看，这一道题目十分简单，但是如果说数据在扩大个几十倍甚至是上百倍的话，那么就十分不容易解决这一个问题了 因此这里我们就必须要用到刚才的知识来解决现在的问题了 设置换群$G={转0度，转90度，转180度，转270度}$ 来标号分别写出四个变化的置换。然后看看，在第一个置换下面，每一个都是不会变的，而对于第二个和第四个置换，第一种和第二种图都是不会变的，对于第三个置换，则是增加了两个对角线填色的图，因此就可以直接代入到式子当中直接得到答案了。 好了，心里面大概也算的上是有一点谱了，差不多就是这么多内容了。（实际上还有一个母函数的内容，但是我自己并不是很懂。）","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"群论","slug":"群论","permalink":"http://example.com/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"Polya定理","slug":"Polya定理","permalink":"http://example.com/tags/Polya%E5%AE%9A%E7%90%86/"}]},{"title":"博弈论入门","slug":"博弈论入门","date":"2021-09-05T02:20:21.804Z","updated":"2021-09-05T02:20:22.158Z","comments":true,"path":"2021/09/05/博弈论入门/","link":"","permalink":"http://example.com/2021/09/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%85%A5%E9%97%A8/","excerpt":"","text":"博弈论（Game Theory）首先先说两个定义N状态:前面的一个玩家必胜P状态: 后面一个玩家必胜 巴什博弈 （Bush Game）有一堆数量为n的物体，轮流拿，至少拿1个，至多拿k个(N&gt;K);如果n%（k+1）==0，那么先手必败。这一切是显而易见，毫无疑问的 一道例题Tang and Jiang are good friends. To decide whose treat it is for dinner, they are playing a game. Specifically, Tang and Jiang will alternatively write numbers (integers) on a white board. Tang writes first, then Jiang, then again Tang, etc… Moreover, assuming that the number written in the previous round is X, the next person who plays should write a number Y such that 1 &lt;= Y - X &lt;= k. The person who writes a number no smaller than N first will lose the game. Note that in the first round, Tang can write a number only within range [1, k] (both inclusive). You can assume that Tang and Jiang will always be playing optimally, as they are both very smart students. 这一道题目大意上和Bush Game 差不多，但是不同的是它里面说的是写不出不小于n的就输了，那么必胜的时候就是你已经写出了n-1的时候。所以此时如果(n-1)%(k+1)==0那么先手必定输，否则就是后手输，因为先手那一次后可已转换为第一种情况 尼姆博弈 （Nim Game）有n堆物体，每一堆的数量为a[i]个，每一次一个人任选一堆取出任意个（不能为0）设k为每一堆异或的结果，如果k==0，那么先手必定失败，否则先手必定胜利。这样来想，把每一堆的数量转换成二进制然后竖着来最低位对齐。如果说k==0,那么这意味这每一个列的1的个数一定会是偶数个。而第一个人取走了一些以后呢，这意味着一定一些列的1的个数为变成奇数个，那么k一定就不再等于0了。而此时后手的人只要把异或的值修正为0就可以了。因为k不等于0了，那么这就说明k的最高位一定会是1，而这个最高位的1一定会是a[i]中的对应位上的1提供的。而根据异或的性质，k和a[i]异或结果为其他的异或结果。我们可以在a[i]中减去一些值，是a[i]最终等于k和a[i]异或的结果，又因为k最高位的1是由a[i]提供的，那么那里一定会变成0，就一定会比a[i]小，而只要把这里减掉，k就又会等于0了 SG函数公平组合游戏1.双方交替来进行；2.游戏进行的任意时刻，可以执行的合法行动与哪一个玩家执行无关；3.当玩家无法行动的时候，就判负 mex运算$$mex(S)=min{x|x\\in N,x\\notin S}$$ SG函数对于任意状态下的x$$SG(x)=mex{SG(y)|y是x的后继状态}$$对于终止状态，SG值为0。 如果某一状态后继SG有0，则当前状态为N如果当前状态所有后继SG不为0，则当前为P; 好的，既然已经知道了SG函数是什么，那么就有一道题了。 移棋子游戏 Description 给定一个有N个节点的DAG图，图上某些节点上面有棋子。两名玩家交替移动棋子，玩家每一次可以将任意一颗棋子沿着有向边移动到下一个节点，当无法移动的时候，就输掉了游戏，假设双方都足够聪明，问先手必胜还是后手必胜。 Input 第一行三个整数N,M,K,表示N个节点M条边K个棋子。接下来M行，每行两个整数x,y,代表x节点到y节点的有向边再接下来K行，表示K个棋子所在的节点编号。 output 先手胜输出”win”,否则输出”lose” Sample Input 123456789106 8 42 12 41 41 54 51 33 53 61 2 4 6 Sample Output 1win 这应该是我第一次这么抄题吧。DAG图，看到这个应该回想起拓扑排序，其次，因为没有后继的点$SG$值为0，而每一个点的$SG$值又是有它的后继决定的。如果它的后继没有弄完，那么就不可以算。这很像拓扑排序把入度为0的点push进队列。因此不难想到这一题可以用类似于拓扑排序的方法来做。我们需要存两个图，正向的和反向的。正向的图用来寻找这一个点的后继获取这一个点的$SG$值，反向的用来找祖宗，修改祖宗的出度，并把出度为0的祖宗push进入队列因为有拓扑排序的基础，所以这一道题可以比较容易的做出来了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define maxn 2003using namespace std;queue&lt;int&gt;Q;vector&lt;int&gt;G[maxn];//正着存图vector&lt;int&gt;G_[maxn];//反着存图int chess[maxn],SG[maxn];//记录棋子的位置 ,SG函数值 bool vis[maxn*3];int n,m,outdgr[maxn];//记录点，边，出度 int k; void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; if(!outdgr[i])&#123; Q.push(i); &#125; &#125; while(!Q.empty())&#123; memset(vis,0,sizeof(vis)); int u=Q.front();Q.pop(); vector&lt;int&gt;::iterator iter=G[u].begin(); int maxsg=0; while(iter!=G[u].end())&#123; maxsg=max(maxsg,SG[*iter]); vis[SG[*iter]]=true; iter++; &#125; int j; for(j=0;j&lt;=maxsg+1;j++)if(!vis[j])break; SG[u]=j;//得到这一个点的SG值 vector&lt;int&gt;::iterator iter_=G_[u].begin(); while(iter_!=G_[u].end())&#123; outdgr[*iter_]--; if(!outdgr[*iter_])Q.push(*iter_); iter_++; &#125; &#125; int ans=SG[chess[1]]; for(int i=2;i&lt;=k;i++)ans^=SG[chess[i]]; if(!ans)printf(&quot;lose\\n&quot;); else printf(&quot;win\\n&quot;); return ; &#125;int main()&#123; memset(outdgr,0,sizeof(outdgr)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].push_back(v); G_[v].push_back(u); outdgr[u]++; &#125; for(int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d&quot;,&amp;chess[i]); &#125; solve(); return 0;&#125; 那么，That’s all.","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"博弈论","slug":"博弈论","permalink":"http://example.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"SG函数","slug":"SG函数","permalink":"http://example.com/tags/SG%E5%87%BD%E6%95%B0/"}]},{"title":"dp review (1)","slug":"递推复习 (1)","date":"2021-09-05T02:20:21.442Z","updated":"2021-09-05T02:20:21.791Z","comments":true,"path":"2021/09/05/递推复习 (1)/","link":"","permalink":"http://example.com/2021/09/05/%E9%80%92%E6%8E%A8%E5%A4%8D%E4%B9%A0%20(1)/","excerpt":"","text":"实际上我只是贴我做的题而已不仅如此，我还是一两道题就给一篇博客 骨牌问题(yzoj1366)Description 有 2 行 N 列的长方形，可以用 N 个 1*2 的骨牌铺满，但可能有很多种不同的铺法。现在给出自然数n，请回答当长方形为 2 行 n 列时，有多少种不同的铺设方法。 Input 第一行一个整数t表示测试数据组数。下面的t行，每行一个整数n。 Output 每组数据输出一行一个整数，表示方案总数，这个数可能很大，所以只需输出模10007后的结果。 Sample Input Sample Output 3 2 5 7 2 8 21 难得换行了，但是实际上答案是要求换行的这一个比较的简单，可以看出来就是斐波那契数列所以直接打表法 Code 1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define maxn 100003#define Mod 10007using namespace std;int f[maxn];int main()&#123; f[1]=1;f[2]=2; for(int i=3;i&lt;maxn;i++)f[i]=(f[i-1]+f[i-2])%Mod; int n; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; int t; cin&gt;&gt;t; cout&lt;&lt;f[t]&lt;&lt;endl; &#125; return 0;&#125; 爬楼梯(yzoj1367) Description 何老师爬楼梯，他可以每步上 1 、2或3 级，输入楼梯的级数，求不同的走法数。例如：楼梯一共有3级，他可以每步都走一级，或者第一步走一级，第二步走两级，也可以第一步走两级，第二步走一级，还有就是第一步就上3级，所以一共4种方法。 Input 第一行：N、K。 第二行：K个整数h[i]，表示坏了的楼梯的级数(1&lt;=h[i]&lt;=N)。 Output 不同的走法数，这个数字可能很巨大，所以输出最后答案mod 1234567 我懒得给样例了，说实话我不喜欢抄题 Analysis 这个的话把坏掉的楼梯直接变成方案数0就可以了，注意边界要特殊处理。方程的话经过推理事$$f[n]=f[n-1]+f[n-2]+f[n-3]$$ Code 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define Mod 1234567#define maxi 1007using namespace std;int f[maxi];bool is_broken[maxi];int main()&#123; memset(is_broken,0,sizeof(is_broken)); memset(f,0,sizeof(f)); int n,k; f[1]=1;f[2]=2;f[3]=4; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=k;i++)&#123; int x; scanf(&quot;%d&quot;,&amp;x); is_broken[x]=true; &#125; if(is_broken[1])&#123; f[1]=0;f[2]-=1;f[3]-=2; &#125; if(is_broken[2])&#123; f[2]=0; if(is_broken[1])&#123; f[3]-=1; &#125; else f[3]-=2; &#125; if(is_broken[3])&#123; f[3]=0; &#125; for(int i=4;i&lt;=n;i++)&#123; if(is_broken[i])f[i]=0; else f[i]=(f[i-1]+f[i-2]+f[i-3])%Mod; &#125; printf(&quot;%d&quot;,f[n]); return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://example.com/tags/%E9%80%92%E6%8E%A8/"}]},{"title":"二分图匹配","slug":"二分图","date":"2021-09-05T02:20:21.395Z","updated":"2021-09-05T02:20:21.758Z","comments":true,"path":"2021/09/05/二分图/","link":"","permalink":"http://example.com/2021/09/05/%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"二分图的匹配二分图的最大匹配增广路一条匹配边与非匹配边交替出现的路径叫做增广路 匹配边：两个点已经处于已选集合里面的边 非匹配边：这条边有个点不属于已经选过的集合里面的边 匈牙利算法在二分图里面交替找增广路的算法，然后把增广路取反直到不存在增广路为止 1234567891011121314151617181920bool dfs(int u)&#123; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!vis[v])&#123; vis[v]=1; if(!match[v]||dfs(match[v]))&#123; //这里对应着两种情况，一种是还没有匹配，另一种是可以腾出空间 match[v]=u; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int ans=0; for(int i=1;i&lt;=N;i++) //这个N是左边的端点 if(dfs[i])ans++;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"}]},{"title":"概率和期望入门","slug":"概率期望","date":"2021-09-05T02:20:21.380Z","updated":"2021-09-05T02:20:21.782Z","comments":true,"path":"2021/09/05/概率期望/","link":"","permalink":"http://example.com/2021/09/05/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/","excerpt":"","text":"概率与期望期望概率这一个词语在生活中实际上是经常会碰见的，所以说这里我就来说一说相对而言遇到的要少一些的期望。这个期望啊，可以理解为某些事件大量发生以后的平均的结果。这就好比一个六面的色子扔了很多很多次以后，色子平均值会趋近于3.5。这个原因啊，是显而易见，毫无疑问的，就不需要再多解释了。 例题好的，有一道例题可以看看洛谷P4316这一道题啊，读完了我就想到了拓扑排序，，同时用两个变长数组来存就可以了最开始我想用边集，可是我不知道怎么用边集来拓扑排序啊，于是ZhuFN大佬提醒我用两个变长数组。因此，我们只需要用两个变长数组，一个用来存点,一个用来存权值就OK了。而这一个拓扑排序的过程中，相对与普通的拓扑排序，增加上对于期望长度的累加就可以了这是因为期望具有可加性$probab(u)$来的那一个点的期望长度，w为这一条边的权值，$outdgr(v)$为有几条路进来，那么可以得到$$probab(v)=[probab(u)+w]/outdgr(v)$$我们这里可采用正着来或反着来（应该是吧），就像是$USACO$的数字金字塔一样吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;queue&lt;int&gt; Q; vector&lt;int&gt;G[maxn];vector&lt;int&gt;W[maxn];int n,tmp=0;int indgr[maxn];int outdgr[maxn];double probab[maxn];int m;void topsort()&#123; Q.push(n); while(!(Q.empty()))&#123; int u=Q.front(); Q.pop(); vector&lt;int&gt;::iterator iterG=G[u].begin(); vector&lt;int&gt;::iterator iterW=W[u].begin(); while(iterG!=G[u].end())&#123; int v=*iterG,w=*iterW; indgr[v]--; probab[v]+=(probab[u]+w)/(outdgr[v]); if(!indgr[v])&#123; Q.push(v); &#125; iterW++;iterG++; &#125; &#125;&#125;int main()&#123; memset(indgr,0,sizeof(indgr)); memset(outdgr,0,sizeof(outdgr)); memset(probab,0,sizeof(probab)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; indgr[a]++;outdgr[a]++; G[b].push_back(a); W[b].push_back(c); &#125; topsort(); printf(&quot;%.2lf&quot;,probab[1]); return 0;&#125; 这里再附上另外的大佬这道题的链接，我是看了dyx大佬代码以后才发现自己累加的地方做错了的对，没错，我最开始错了,而 ZhuFN则是用的dfs做的。dyxzfn那么就可以了","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"高精度压位","slug":"高精度压位","date":"2021-09-05T02:20:21.066Z","updated":"2021-09-05T02:20:21.847Z","comments":true,"path":"2021/09/05/高精度压位/","link":"","permalink":"http://example.com/2021/09/05/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8E%8B%E4%BD%8D/","excerpt":"","text":"压位的原因正常的高精度计算中，每一位只存了一位数字，可是当面对比较大的计算的时候呢，如果说每一位都只存一位数字，那么计算的时间就会比较地长。这个时候可以通过每一位高精度中存储多位数字的方法来降低运算的时间 例题引入简单的来说就是 一个高精度的开根号，只要求开到整数向下取整就可以了。数据范围是$10^{1000}$;首先就是开高精度根号的方法，很容易想到的方法就是二分或者是手动开根号。我这里使用的是二分的方法。这一道题最开始我是直接高精度来的,然后TLE了，接着我压了四位，还是TLE了，然后直接$10000000$一位了，终于A了。那么接下来我来一点点解析代码(实际上我只解析读入而已了) 12345678910111213141516inline void input()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); int j=0; for(int i=lenS-1;i&gt;=0;i-=7)&#123;//因为是10^8的进制，所以给7位 int t=max(i-6,0),res=0;//i-6~i一共七位， while(t&lt;=i)&#123; res=res*10+S[t]-&#x27;0&#x27;; t++; &#125; val[++j]=res; &#125; val[0]=j; &#125; 我的解析全写注释了，实际上总共我也只有两句解析，因为我在这两个地方没怎么注意，所以最开始我……至于这一个高精度的其他部分，那么就直接把10改成对应的大小就可以了，我这里是$10^8$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;#define Int64 long long#define carries 10000000#define maxn 1003using namespace std;struct largenum&#123; Int64 val[maxn]; Int64 operator [](const int &amp;ref)const&#123; return val[ref]; &#125; inline void input()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); int j=0; for(int i=lenS-1;i&gt;=0;i-=7)&#123; int t=max(i-6,0),res=0; while(t&lt;=i)&#123; res=res*10+S[t]-&#x27;0&#x27;; t++; &#125; val[++j]=res; &#125; val[0]=j; &#125; /*inline void StrIn(char *S)&#123; memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125;*/ inline void output()&#123; // 输出 printf(&quot;%ld&quot;,val[val[0]]); for(int i=val[0]-1;i&gt;=1;i--) printf(&quot;%07ld&quot;,val[i]); &#125; bool operator ==(const largenum &amp;obj)const&#123; // 判断是否等于 if(val[0]!=obj[0]) return false; for(int i=1;i&lt;=val[0];i++) if(val[i]!=obj[i]) return false; return true; &#125; bool operator &lt;(const largenum &amp;obj)const&#123; // 判断是否小于 if(val[0]&gt;obj[0]) return false; if((*this)==obj) return false; if(val[0]&lt;obj[0]) return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i]) return false; if(val[i]&lt;obj[i]) return true; &#125; return true; &#125; bool operator &gt;(const largenum &amp;obj)const&#123; // 判断是否大于 largenum cmp=*this; if(cmp &lt; obj || cmp == obj) return false; return true; &#125; largenum operator +(const largenum &amp;obj)const&#123; // 加法运算 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=max(val[0],obj.val[0]),add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]+obj[i]+add; add=cmp.val[i]/carries; cmp.val[i]=cmp.val[i]%carries; &#125; if(add&gt;0) cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; largenum operator -(const largenum &amp;obj)const&#123; // 减法运算 只能减出正数 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0],rent=0; // rent 借位 for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]-obj[i]-rent; if(cmp.val[i]&lt;0) &#123;cmp.val[i]+=carries;rent=1;&#125; else rent=0; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator *(const int &amp;obj)const&#123; // 高精度 ×低精度 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0]; // 进位 long long add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/carries; cmp.val[i]=cmp.val[i]%carries; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%carries; add/=carries; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator *(const largenum &amp;obj)const&#123; // 高精度 ×高精度 // 对于高精度数 a 和高精度 b // 这个算法不能写成 a=a*b largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/carries; cmp.val[i+j-1]=cmp.val[i+j-1]%carries; &#125; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator /(const int &amp;obj)const&#123; // 高精度 ÷低精度 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0],div=0; for(int i=pos;i&gt;=1;i--)&#123; cmp.val[i]=(div*carries+val[i])/obj; div=(div*carries+val[i])%obj; &#125; while(cmp[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; int operator %(const int &amp;obj)const&#123; // 高精度 % 低精度 int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--) div=(div*carries+val[i])%obj; return div; &#125; largenum operator /(const largenum &amp;obj)const&#123; // 高精度 ÷高精度 largenum cmp,t_cmp; memset(cmp.val,0,sizeof(cmp.val)); memset(t_cmp.val,0,sizeof(t_cmp.val)); Int64 pos=val[0]; cmp.val[0]=1;cmp.val[1]=0; t_cmp=cmp; if((*this)&lt;obj) return cmp; // 小于除数直接返回 0 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*carries; t_cmp.val[1]=val[i]; int k=0; while(t_cmp&gt;obj || t_cmp==obj) &#123; t_cmp=t_cmp-obj; k++; &#125; cmp.val[i]=k; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator %(const largenum &amp;obj)const&#123; // 高精度 % 高精度 largenum t_cmp; memset(t_cmp.val,0,sizeof(t_cmp.val)); Int64 pos=val[0]; t_cmp.val[0]=1;t_cmp.val[1]=0; if((*this)&lt;obj) return (*this); // 小于除数直接返回本身 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*carries; t_cmp.val[1]=val[i]; while(t_cmp&gt;obj || t_cmp==obj) t_cmp=t_cmp-obj; &#125; return t_cmp; &#125; void lgnsqrt()&#123; largenum one=&#123;&#123;1,1&#125;&#125;; largenum l=&#123;&#123;1,1&#125;&#125;; largenum r=*this; largenum cmp=*this; largenum mid=(l+r)/2; largenum tmp=mid*mid; while(l&lt;r)&#123; if(tmp&lt;cmp||tmp==cmp)&#123; l=mid+one; &#125; else r=mid; mid=(l+r)/2; tmp=mid*mid; &#125; if(mid*mid&gt;cmp&amp;&amp;((mid-one)*(mid-one)&lt;cmp||(mid-one)*(mid-one)==cmp)) mid=mid-one; for(int i=0;i&lt;=mid.val[0];i++)&#123; val[i]=mid.val[i]; &#125; &#125; 在这一段高精度的最后是自己写的二分开方这里就按正常的开方来就可以了，因为是向下取整，所以呢我就在在后面加了一个if语句。那么，That’s all.","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于质数和约数的一个小总结","slug":"关于质数和约数的总结","date":"2021-09-05T02:20:21.030Z","updated":"2021-09-05T02:20:21.348Z","comments":true,"path":"2021/09/05/关于质数和约数的总结/","link":"","permalink":"http://example.com/2021/09/05/%E5%85%B3%E4%BA%8E%E8%B4%A8%E6%95%B0%E5%92%8C%E7%BA%A6%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"约数定义​ 若整数n能够整除d，则d是n的约数，n是d的倍数，记作d|n 基本性质 唯一分解定理：任何一个正整数都可以分解为$p_1^{b_1}*p_2^{b_2}*p_3^{b_3}……p_n^{b_n}$（为了后面的叙述，若$i&lt;j,p_i&lt;p_j$） 它的正约数个数：$\\prod_{i=1}^{m}(b_i+1)$ $lcm(a,b)gcd(a,b)=ab$ 基本算法和板子 试除法： 用来求解一个数的正约数集合，时间复杂度：$\\Theta(\\sqrt n)$ 更相减损术： 当使用高精度的时候，使用它来求解最大公约数很方便 123int gcd(int x,int y)&#123; return (!y)?x:gcd(y,x-y);&#125; 辗转相除法：比更相减损术更快 123int gcd(int x,int y)&#123; return (!y)?x:gcd(y,x%y);&#125; 当然了，有一个速度更快的二进制版本 12345678910111213inline int gcd(int x,int y)&#123; int i,j; if(x==0)return y; if(y==0)return x; for(i=0;(x&amp;1)==0;i++)x&gt;&gt;=1; for(j=0;(y&amp;1)==0;j++)y&gt;&gt;=1; if(i&gt;j)i=j; while(true)&#123; if(x&lt;y)&#123;x^=y;y^=x;x^=y;&#125; if(!(x%=y))return y&lt;&lt;i; while(!(x&amp;1))x&gt;&gt;=1; &#125;&#125; 素数定义这个很简单吧，小学就学过的 基本定理 唯一分解定理（同上） 威尔逊定理：如果$(p-1)!\\equiv-1(mod\\ p)$，则p为质数 质数有无穷多个 欧拉定理这些的就放在同余那一块来讲了 数论的板子都在这里面来看吧 数论板子","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"质数","slug":"质数","permalink":"http://example.com/tags/%E8%B4%A8%E6%95%B0/"},{"name":"约数","slug":"约数","permalink":"http://example.com/tags/%E7%BA%A6%E6%95%B0/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"}]},{"title":"矩阵","slug":"矩阵","date":"2021-09-05T02:20:20.988Z","updated":"2021-09-05T02:20:21.414Z","comments":true,"path":"2021/09/05/矩阵/","link":"","permalink":"http://example.com/2021/09/05/%E7%9F%A9%E9%98%B5/","excerpt":"","text":"用矩阵来祭我的第一篇博客感谢朱枫苓，WYX大佬为本人博客的建设做出的巨大贡献再次特别发出大佬博客的地址，表示我对与朱枫苓大佬的敬佩大佬自己的博客大佬在博客园的博客 好了，来看看矩阵 加法。只有同型的矩阵才可以相加，对应的位置上面相加就可以了。 数乘。把一个矩阵拿来和一个常数相乘，每一位都乘上来就行了，没有什么多的了。 倒置。直接行列倒过来就行了。还有一个定理：A*B的倒置等于A的倒置乘以B的倒置 然后就到了重点了 乘法矩阵乘法$A*B$ 可以做乘法的条件是A的列数要等于B的行数 然后呢乘法就是A的第几行和B的第几列对应相乘累加就是答案第几几的位置的值了。这个矩阵啊，作用非常的大，配合快速幂，可以加速状态转移，实现很多的骚操作。 下面让我们看看矩阵是如何骚操作斐波那契数列的 题目背景 大家都知道，斐波那契数列是满足如下性质的一个数列： $f(1) = 1$ $f(2) = 1$ $f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数)$ 题目描述 请你求出$ f(n) mod 1000000007$ 的值。 设一个有两个元素的$1*2$的矩阵 $A[n]=[f(n),f(n-1)]$然后这样的话$A[n-1]=[f(n-1),f(n-2)]$那么的设话 $A[n-1]*B=A[n]$ ,易得 B为$$\\begin{bmatrix}1&amp;1\\1&amp;0\\end{bmatrix}$$ 则 $f(n)$ 为 $A[1][1]*(B 的 n 次方时的第二个元素）$ 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Matrix F[n]=&#123;f[n],f[n-1]&#125;//A=&#123;1,1// 1,0&#125;#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll A[2][2];const ll Mod=1000000007;void mul(ll *a,ll b[2][2])&#123; ll tmp[2]; memset(tmp,0,sizeof(tmp)); for(int j=0;j&lt;=1;j++)&#123; for(int k=0;k&lt;=1;k++)&#123; (tmp[j]+=(a[k]*b[k][j]))%=Mod; &#125; &#125; memcpy(a,tmp,sizeof(tmp));&#125;void mulsel(ll (*f)[2])&#123; ll tmp[2][2]; memset(tmp,0,sizeof(tmp)); for(int i=0;i&lt;=1;i++)&#123; for(int j=0;j&lt;=1;j++)&#123; for(int k=0;k&lt;=1;k++)&#123; (tmp[i][j]+=(f[i][k]*f[k][j]))%=Mod; &#125; &#125; &#125; memcpy(f,tmp,sizeof(tmp));&#125;ll pw(ll b)&#123; ll ans[2]=&#123;1,0&#125;; while(b)&#123; if(b&amp;1)mul(ans,A); mulsel(A); b&gt;&gt;=1; &#125; return ans[1];&#125; int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif A[0][0]=1;A[0][1]=1; A[1][0]=1;A[1][1]=0; ll k; cin&gt;&gt;k; printf(&quot;%lld&quot;,pw(k));//快速幂 return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"Catalan Number入门","slug":"卡特兰数","date":"2021-09-05T02:20:20.864Z","updated":"2021-09-05T02:20:21.357Z","comments":true,"path":"2021/09/05/卡特兰数/","link":"","permalink":"http://example.com/2021/09/05/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"定义这个cn啊，是组合数学里面经常会用到的东西，比如说： 让你算算二叉树的形态 又让你算算合法的括号序列 又或者让你算算出入栈的合法顺序 还可能让你去说说把多边形割成三角形方法 综上所述就是18年初赛的第8题 于是有的人弄出来了它的式子我们设为f(n),那么有$$f(n)=\\sum^{n-1}{i=0}f(i)\\cdot f(n-i-1)$$当然人们并不会满足一个式子，于是就有了第二个$$f(n)=f(n-1)\\cdot \\frac{4n-2}{n+1}$$但是因为我们没有通项式，所以必须要一个一个的算与是通项式就来了$$f(n)=\\frac{C^{n}{2n}}{n+1}$$当然如果我们进行一点变换的话就可以得到它：$$f(n)=C^{n}{2n}-C^{n-1}{2n}$$ 这个式子是一个好式子，面对问题是往往很容易就可以化成这一个形式，然后就发现了这是卡特兰数的题 例题1.栈（洛谷P1044）洛谷P1044这一道题很容易就可以看出来这一个是Cn的模板题那么就是这样的了贴代码(用的是第二个式子) 12345678910111213141516171819//洛谷的卡特兰数模板题 #include&lt;bits/stdc++.h&gt;using namespace std;long long f[20];void getcn(int n)&#123; f[1]=1; for(int i=2;i&lt;=n;i++)&#123; f[i]=((4*i-2)*f[i-1])/(i+1); &#125; printf(&quot;%lld\\n&quot;,f[n]); return ;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); getcn(n); return 0; &#125; 2.矩阵（洛谷P1722）洛谷P1722这一道题啊，可以看出来是一道卡特兰数的题，要求我们去模100，那么向第一个式子那样没有除法，只有加和乘的方法自然就是首选了，既然如此就用第一种方法写Cn就行了 123456789101112131415161718192021//矩阵 洛谷P1722 #include&lt;bits/stdc++.h&gt;#define Mod 100using namespace std;int n;long long f[105];void solve()&#123; f[0]=f[1]=1; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i-1;j++)&#123; (f[i]+=f[j]*f[i-j-1])%=Mod; &#125; &#125; printf(&quot;%lld&quot;,f[n]); return;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); solve(); return 0;&#125; 3.树屋阶梯(洛谷P2532)洛谷P2532这一道题啊，首先你这么考虑，任意选中其中一阶阶梯，然后呢就把整个阶梯分成了它上面的阶梯和它右面的阶梯。每一阶阶梯都这么去考虑，写出整个式子就会发现是卡特兰数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//洛谷P2532 树屋//这道题不得不用高精度了 #include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;struct Ln&#123; // 整数，最大可存储一万位数字 int val[maxn]; int operator [](const int &amp;ref)const&#123; return val[ref]; &#125; inline void Lin()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125; inline void StrIn(char *S)&#123; memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125; inline void Lout()&#123; // 输出 for(int i=val[0];i&gt;=1;i--) putchar(val[i]+&#x27;0&#x27;); &#125; bool operator ==(const Ln &amp;obj)const&#123; // 判断是否等于 if(val[0]!=obj[0]) return false; for(int i=1;i&lt;=val[0];i++) if(val[i]!=obj[i]) return false; return true; &#125; bool operator &lt;(const Ln &amp;obj)const&#123; // 判断是否小于 if(val[0]&gt;obj[0]) return false; if((*this)==obj) return false; if(val[0]&lt;obj[0]) return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i]) return false; if(val[i]&lt;obj[i]) return true; &#125; return true; &#125; bool operator &gt;(const Ln &amp;obj)const&#123; // 判断是否大于 Ln cmp=*this; if(cmp &lt; obj || cmp == obj) return false; return true; &#125; Ln operator +(const Ln &amp;obj)const&#123; // 加法运算 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=max(val[0],obj[0]),add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]+obj[i]+add; add=cmp.val[i]/10; cmp.val[i]=cmp.val[i]%10; &#125; if(add&gt;0) cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; Ln operator -(const Ln &amp;obj)const&#123; // 减法运算 只能减出正数 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0],rent=0; // rent 借位 for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]-obj[i]-rent; if(cmp.val[i]&lt;0) &#123;cmp.val[i]+=10;rent=1;&#125; else rent=0; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator *(const int &amp;obj)const&#123; // 高精度 ×低精度 // 对于高精度数 a 和低精度数 b // 这个算法可以写成 a=a^b Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0]; // 进位 long long add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/10; cmp.val[i]=cmp.val[i]%10; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%10; add/=10; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator *(const Ln &amp;obj)const&#123; // 高精度 ×高精度 // 对于高精度数 a 和高精度 b // 这个算法不能写成 a=a*b Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/10; cmp.val[i+j-1]=cmp.val[i+j-1]%10; &#125; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator /(const int &amp;obj)const&#123; // 高精度 ÷低精度 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--)&#123; cmp.val[i]=(div*10+val[i])/obj; div=(div*10+val[i])%obj; &#125; while(cmp[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; int operator %(const int &amp;obj)const&#123; // 高精度 % 低精度 int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--) div=(div*10+val[i])%obj; return div; &#125; Ln operator /(const Ln &amp;obj)const&#123; // 高精度 ÷高精度 Ln cmp,t_cmp; memset(cmp.val,0,sizeof(cmp.val)); memset(t_cmp.val,0,sizeof(t_cmp.val)); int pos=val[0]; cmp.val[0]=1;cmp.val[1]=0; t_cmp=cmp; if((*this)&lt;obj) return cmp; // 小于除数直接返回 0 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*10; t_cmp.val[1]=val[i]; int k=0; while(t_cmp&gt;obj || t_cmp==obj) &#123; t_cmp=t_cmp-obj; k++; &#125; cmp.val[i]=k; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator %(const Ln &amp;obj)const&#123; // 高精度 % 高精度 Ln t_cmp; memset(t_cmp.val,0,sizeof(t_cmp.val)); int pos=val[0]; t_cmp.val[0]=1;t_cmp.val[1]=0; if((*this)&lt;obj) return (*this); // 小于除数直接返回本身 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*10; t_cmp.val[1]=val[i]; while(t_cmp&gt;obj || t_cmp==obj) t_cmp=t_cmp-obj; &#125; return t_cmp; &#125;&#125;;Ln f[505]=&#123;&#123;1,1&#125;&#125;;int n;void solve()&#123; f[1]=f[0]; for(int i=2;i&lt;=n;i++)&#123; f[i]=(f[i-1]*(4*i-2))/(i+1); &#125; f[n].Lout();&#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); solve(); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"康托展开","slug":"康托展开","date":"2021-09-05T02:20:20.435Z","updated":"2021-09-05T02:20:21.045Z","comments":true,"path":"2021/09/05/康托展开/","link":"","permalink":"http://example.com/2021/09/05/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"按规矩，祭天 今天加了的内容是康托展开，因为时间原因就不附上题目了而且我也还没有做题，就直接来看内容了 定义它是用来求解一个数列的全排列下面的结果的序号的问题$$∑(pi*(n-i)!)(i是第几个数字)$$ 逆推那么就是根据序号求结果了，方法是类似的首先是把1~n-1的阶乘都算出来，然后呢每一位也是倒着回去，用序号整除这里对应的阶乘，然后看看在剩下的没有选的数字当中哪一个的比它小的数字的个数等于这一个结果就行了 比较简洁，大概就是我对此的理解了 最后还有一个逆元的求法这个求法的推导自己去推，书上也是有的（数学一本通P17）那么我就附上一份代码就行了 1234int inv(int n,int p)&#123; if(n==1)return 1; else return -(p/i)*inv(p%n,p);&#125; 到此为止了。","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"康托展开","slug":"康托展开","permalink":"http://example.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"}]},{"title":"洛谷P2421题解","slug":"洛谷P2421","date":"2021-09-05T02:20:20.416Z","updated":"2021-09-05T02:20:21.007Z","comments":true,"path":"2021/09/05/洛谷P2421/","link":"","permalink":"http://example.com/2021/09/05/%E6%B4%9B%E8%B0%B7P2421/","excerpt":"","text":"洛谷P2421这一道题目是一道同余的题目，进行推理后用扩展欧几里得就可以了，解析我写在了代码里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define Int64 long long#define maxn 17using namespace std;Int64 c[maxn],p[maxn],l[maxn];//出生地，速度，生命长度 int Extend_gcd(Int64 a,Int64 b,int &amp;x,int &amp;y)&#123; //ax+by=gcd(a,b); if(!b)&#123; x=1;y=0; return a; &#125; int d=Extend_gcd(b,a%b,x,y); int tmp=x; x=y;y=tmp-a/b*y; return d;&#125;int n;bool check(int pos)&#123; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; int x,y,t; t=Extend_gcd((p[i]-p[j]),pos,x,y); //t=gcd((p[i]-p[j]),pos) if((c[j]-c[i])%t)continue; /* *因为解的方程是(p[i]-p[j])x+pos*y =c[j]-c[i]; *如果说不整除，那么就没有解 */ Int64 tmp=pos/t; //用pos除以t，得到每一次 x改变多少 tmp=abs(tmp); //保证tmp是正数 x=x%tmp*((c[j]-c[i])/t)%tmp; ((x%=tmp)+=tmp)%=tmp; //对解进行修正 if(!x)x+=tmp; if(x&lt;=min(l[j],l[i]))return false ; &#125; &#125; return true ;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); Int64 pos=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;c[i]&gt;&gt;p[i]&gt;&gt;l[i]; pos=max(pos,c[i]);//寻找最大的序号 &#125; while(true)&#123; if(check(pos))&#123; printf(&quot;%lld&quot;,pos); break; &#125; pos++; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"}]},{"title":"洛谷P3807卢卡斯定理","slug":"洛谷P3807卢卡斯定理","date":"2021-09-05T02:20:20.209Z","updated":"2021-09-05T02:20:20.954Z","comments":true,"path":"2021/09/05/洛谷P3807卢卡斯定理/","link":"","permalink":"http://example.com/2021/09/05/%E6%B4%9B%E8%B0%B7P3807%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/","excerpt":"","text":"这是一道模板题 这里是题目 洛谷P3807卢卡斯定理及题目的阐释卢卡斯定理是用来解决一大很大的组合数来和一个质数求余的问题，它的定义如下如果$p$为素数，设$n=sp+q$,$m=tp+r$则:$$C^{sp+q}_{tp+r}\\equiv C^s_t*C^q_r(mod\\ p)$$ 那么来看看题。首先看这个数据范围，就知道可以用int的类型解决个屁，就是int害的我错了好多次long long 的数据类型解决，这个数据看起来好像是只有 10的5次方,但是中间这么多的计算，突然的就给我溢出了我靠着ZFN大佬的数据测试发现负数才发现的。 1234567891011long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125; ​ 这一段是求组合的函数，拿出来单独讲一讲​ 因为这里面的参数传过来的时候都是已经和p求过余了的，而且p在题目中说了的，是一个质数所以说这里的$n$,$m$都是和$p$互质的。​ 因为公式里面要除掉$m!$，同时有要去对p取模，所以考虑用它的逆元乘来代替用它来除而根据费马小定理可以知道它的逆元是它的$p-2$方 Code那么综上，加上以个快速幂就可以解出这道题了 123456789101112131415161718192021222324252627282930313233343536373839404142434445//洛谷P3807 Lucas 模板题 #include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,m,p;long long qkpow(long long b,int p,int mod)&#123; long long res=1; while(p)&#123; if(p&amp;1)&#123; (res*=b)%=mod; &#125; (b*=b)%=mod; p&gt;&gt;=1; &#125; return res;&#125;long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125;long long Lucas(int n,int m,int p)&#123; if(m==0)return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); n+=m; cout&lt;&lt;Lucas(n,m,p)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"Lucas","slug":"Lucas","permalink":"http://example.com/tags/Lucas/"}]},{"title":"你往何处去-读后感","slug":"你往何处去-读后感","date":"2021-09-05T02:20:19.585Z","updated":"2023-05-31T02:54:23.781Z","comments":true,"path":"2021/09/05/你往何处去-读后感/","link":"","permalink":"http://example.com/2021/09/05/%E4%BD%A0%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"关于显克维奇​ 亨里克显克维奇，出生于十九世纪中叶的一个没落的地主家庭。中学毕业后进入了华沙高等学院进行学习。是波兰十九世纪的著名作家。人们评价他： 作品人物个性鲜明，情节引人入胜，语言优美流畅，深受群众欢迎，素有“波兰语言大师”之称。 ​ 他是最早被介绍到中国的波兰作家。鲁迅曾经翻译过他的短篇小说集。他的作品以炙热的爱国热情，波澜壮阔的战争场面，精致细腻的描写而令人赞叹。 ​ 显克维奇是一个波兰人，这是一个对于大多数人而言，十分陌生的国家，大多数对他的印象，应该就是德国入侵波兰，二战全面爆发和在拜仁慕尼黑踢球的波兰前锋莱万多夫斯基了。实际上关于波兰，有着很多值得一谈的地方，她的黄金自由制，萨尔马提亚主义，历史上著名的瓦尔纳十字军，1683年维也纳城下三千翼骑兵大破奥斯曼帝国十五万军队，以及对俄罗斯的入侵（值得一提的是，蒙古和波兰应当是唯二两个一度攻占了莫斯科的国家，拿破仑占领的莫斯科是俄罗斯人让的，蒙古是没有打进去，俄国人就投降了，而波兰则是在俄国王朝混乱时期攻入了莫斯科），与欧洲其他贵族截然不同的施拉赤塔。马克思曾经评价波兰是斗争的民族，认为波兰应当是实现共产主义的先驱（然而有趣的是，当1919年的时候，苏俄红军向着西方进军，准备进行世界革命，欧洲各国统治危在旦夕的时候，波兰人创造了维斯瓦河畔的奇迹，逼得苏俄人割地赔款） ​ 我们谈回到显克维奇身上来。他出身的年代，曾经一度称霸东欧的波兰已经被她曾经的附庸普鲁士，被她从奥斯曼帝国手中救下来的奥地利，以及宿敌俄国所瓜分殆尽。华沙起义的失败，更是给波兰民族的前程蒙上了一层阴影。俄国人的民族同化政策进一步加剧,上层贵族走向了对俄罗斯的妥协，而下层的民众则是看不到波兰民族的方向。 十九世纪六十年代末，一批受实证主义影响的知识分子便掀起了一场意识形态方面的斗争，他们反对旧的封建主义，主张实业救国……显克维奇虽然没有参与这场实证主义运动，但是却收到它的影响…… 显克维奇知道，在现实社会是很难找到希望和信心的。但是在波兰的历史上，却发生过伟大的事件，出现过伟大的人物，有过令人振奋的东西，伟大的性格，伟大的罪过和伟大的牺牲 ​ -《火与剑 林洪亮译本 译后前言》 ​ 显克维奇自七八十年代开始开始创作。他的哪一部《火与剑》，就是在那一个时间完成的。《火与剑》这一本书，是他历史小说三部曲的第一部。这也有可能是在中国，他最有名气的一部小说。因为在2013年的时候，$taleworlds$ 的骑马与砍杀里面增加了一部以这本书为名的资料片。相信很多人因为这知道了显克维奇。至少我是因此知道的。我必须要说一下，林洪亮翻译的火与剑真的是精彩绝伦，超乎想象，这一本书理所应当有更多的人来读。它受到的关注太少了。 ​ 而我所要说的《你往何处去》，则是他在1895年创作的，一部颇具异域风情的小说。 关于这本书​ 精彩绝伦，妙不可言，难以想象，震撼人心。我认为这一本书很合口味。古罗马距离我们很遥远了，很多人提到她，都是感到无比地陌生。我喜欢罗马，但是我喜欢的，更多的是那一个东方的罗马，是那个君士坦丁堡作为首都的罗马帝国，是那一个和萨珊波斯鏖战百年，教化了斯拉夫人，抵挡了阿拉伯人入侵的罗马。而对于那一个古罗马，我也是感到陌生。 ​ 显克维奇的笔下，这个古老的国度仿佛就已经展现在了眼前。我看到了暴君尼禄的荒淫无道，恬不知耻，滑稽可笑，我看见了众多的大臣不过是腐败堕落的怕马屁之徒（想到了语文课上讲的，如果说这些人都是一群追逐利益的人，那么这个国家也就离灭亡不远了），我看见了那些见利忘义的小人，我看见了基督徒们不畏强权，坦然受死，我看见了一个叛徒的悔过和觉悟，我看见了一位信奉基督教的少女虔诚的信仰和自重，我看见了一个残忍的罗马贵族青年如何如何变成一位虔诚善良的基督徒，和另一人共渡难关。当我一页页翻完了这本书，我感觉好像在那一个世界活过了一般（因此我赶紧去玩了一把欧陆风云4的帝国风云mod，享受了罗马帝国征服蛮子的乐趣）。 ​ 在我看来，这本有着五个最为主要的人物，男主角维尼裘斯，女主角黎吉亚，维尼裘斯叔父斐特洛纽斯，罗马皇帝尼禄，希腊哲学家基罗。维尼裘斯的转变是作者花了大量篇幅描写的一处，也是相当精彩的一部分，最终终于在黎吉亚的影响下，成为了虔诚的基督徒。斐特洛纽斯，尼禄，基罗则是主要在推动剧情。基罗无论是在前期还是后期，他的作用都是非常明显，文章重大事件的推动，甚至翻转，都是少不了他的参与。他本人或许很难给读者留下很好的印象，但是我相信在竞技场他所做的事情，无疑震撼了无数人： ……他们没有在笑，因为那个希腊人脸上的表情是那么令人害怕，就像是他自己被大火烧着了一般，那样的痛苦和害怕，他的脸已经扭曲得不成样子了，只见他猛地站了起来，向上伸展自己的胳膊，口中发出悲痛欲绝的圣耀魂，叫道：“主啊，宽恕我吧，戈劳库斯” …… “罗马的居民们，你们被骗了，我可以用我的性命担保，这里所有牺牲的人都是无辜的，并且我知道纵火的人，他就是——” ​ 他将自己的手指向皇帝。 ​ 我向这么精彩的场面，是显克维奇小说能够如此受到欢迎的原因。 ​ 我读完这个本书，良久不能平静，黎吉亚和维尼裘斯的爱情令人感慨万分。当我从书中走出的时候，我的的确确有一种重生之感。两个人的感情故事让我觉得真的是万分不易，心情也是有一些沉闷。闭上眼睛，我还能想起书中所描写的场面。显克维奇的小说真的是充满了魅力（就是现在网上买另外几本有一些贵，我三年前68买的火与剑小说现在涨了好多）。 或许，暂时就这么多可说的了吧","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"显克维奇作品选读","slug":"显克维奇作品选读","permalink":"http://example.com/tags/%E6%98%BE%E5%85%8B%E7%BB%B4%E5%A5%87%E4%BD%9C%E5%93%81%E9%80%89%E8%AF%BB/"}]},{"title":"排列组合复习","slug":"排列组合复习","date":"2021-09-05T02:20:18.890Z","updated":"2021-09-05T02:20:20.810Z","comments":true,"path":"2021/09/05/排列组合复习/","link":"","permalink":"http://example.com/2021/09/05/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"排列","slug":"排列","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://example.com/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"}]},{"title":"数论test","slug":"数论test","date":"2021-09-05T02:20:18.585Z","updated":"2021-09-05T02:20:19.593Z","comments":true,"path":"2021/09/05/数论test/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BAtest/","excerpt":"","text":"有趣的序列洛谷链接这一道题是一道卡特兰数的题，但是因为数据量以及要进行模运算的原因，要采用我先前博客中写到的通项式。当然因为不可以直接算阶乘，因此采取分解阶乘的方法转换成乘法。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define maxn 1000002#define Int64 long longusing namespace std;int primes[2*maxn];int sum[2*maxn];bool isp[2*maxn];int newp=0;void Eular_Sieve()&#123; for(int i=2;i&lt;2*maxn;i++)&#123; if(!isp[i])&#123; primes[++newp]=i; &#125; for(int j=1;j&lt;=newp&amp;&amp;primes[j]*i&lt;2*maxn;j++)&#123; isp[primes[j]*i]=true; if(!(i%primes[j]))break; &#125; &#125; return;&#125;Int64 qkpow(int a,int b,int p)&#123; //a的b次方mod p if(b==1)return a; if(b%2)&#123; Int64 t=qkpow(a,b/2,p); t=t*t%p; t=t*a%p; return t; &#125; else &#123; Int64 t=qkpow(a,b/2,p); t=t*t%p; return t; &#125;&#125;int n,p;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); Eular_Sieve(); for(int i=1;i&lt;=newp;i++)&#123; Int64 t=primes[i]; Int64 cnt1=0,cnt2=0,cnt3=0; while(t&lt;=2*n)&#123; cnt1+=(2*n/t);cnt2+=((n+1)/t);cnt3+=(n/t); t*=primes[i]; &#125; sum[i]=cnt1-cnt2-cnt3; &#125; Int64 ans=1; for(int i=1;i&lt;=newp;i++)&#123; if(sum[i])&#123; (ans*=qkpow(primes[i],sum[i],p))%=p; &#125; &#125; printf(&quot;%lld&quot;,ans); return 0; &#125; 打气球这道题我就不给网址了，yzoj上面最后一页找 题目描述 Descrition 周末何老板到磁器口游玩。街边有小贩在组织一种打气球游戏，何老板很感兴趣。 店家立了一块布，布上画了N*N的方格，有的方格里挂上了气球，有的没有。 游戏规则如下： 第1步.观察。如果每一行都至少有一个方格没有气球，并且每一列都至少有一个方格没有气球，游戏结束。否则进行第2步。 第2步.抛骰子。店家拿出一个特制的骰子，该骰子有N个面，上面依次有1到N这N 个数字。玩家先后抛两次骰子，设第一次抛出的数字为x，设第二次抛出的数字为y (注：抛出的数字是随机的)。 第3步.打气球。若坐标为(x,y)的格子里有气球，玩家必须将其打爆。子弹1块钱一发。 如果该格子没有气球，忽略该格子，玩家不用开枪，但玩家也需要支付给店家1块钱。 第4步.继续。执行第1步。 何老板是个神枪手，他能做到百发百中。他想你帮他算算，对于当前给出的这局游戏，预计要花多少钱才能结束。 Input 第一行，两个整数N和M，N表示方格的尺寸,M表示游戏开始时，有M个格子里是没有气球的。 接下来M行，每行两个整数x,y,表示坐标为x,y的格子里没有气球。 Output 一行，一个实数，完成游戏预计花费，保留2个小数位。 Sample Input 1235 2 2 3 4 1 Sample Output 111.77 如果你想看更多的样例输出，可以去WYX大佬的博客 分析这一道题啊，实际上啊，就是一道期望的题，如果你点开了上面的那一个链接，多半也看见了YB说的话了吧，那么接下来要做的事情就是找出递归的关系首先，我们都知道每一个格子概率为$\\frac{1}{n^2}$我们设有$r$行已经打掉，$c$列已经打掉，函数为$f[r][c]=……$那么分类讨论1.如果说没有抽到有气球的地方，那么就是他自己乘上没有气球的地方的概率2.如果说打掉的地方只能消除行，那么就是乘上$f[r-1][c]$以及这些地方的概率，只能消除列同理3.如果可以同时消去的话，那么就可以类比上面的，写出式子来。4.当然最后你应该加上1，因为每打一次收费1 式子和化简如下$$f[r][c]=\\\\ \\frac{f[r-1][c]\\times r(n-c)+f[r][c-1]\\times c(n-r)+f[r-1][c-1]\\times r\\times c+f[r][c]\\times(n-r)(n-c)+n^2}{n^2(n-r)(n-c)}$$好了，既然已经知道了式子，那么就可以比较容易的做出来了，至于边界，那你也可以自己推出来，你可以选择两种方法，$dfs$ or$ dp$我的代码里面把$dfs$的注释掉了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define maxn 2003using namespace std;double f[maxn][maxn];bool row[maxn],col[maxn];//行 列 int n,m;double dfs(int r,int c)&#123; double ans=0; if(!r&amp;&amp;!c)return 0; if(f[r][c]!=-1)return f[r][c]; if(r)ans+=dfs(r-1,c)*r*(n-c); if(c)ans+=dfs(r,c-1)*c*(n-r); if(r&amp;&amp;c)ans+=dfs(r-1,c-1)*r*c; return f[r][c]=(double)(ans+n*n)/(n*(c+r)-c*r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int r=n,c=n; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(!row[x])r--,row[x]=true; if(!col[y])c--,col[y]=true; &#125; /*for(int i=0;i&lt;=r;i++)&#123; for(int j=0;j&lt;=c;j++)f[i][j]=-1; &#125; dfs(r,c);*/ for(int i=1;i&lt;=n;i++)&#123; f[i][0]=f[i-1][0]+n/(i+0.0); f[0][i]=f[0][i-1]+n/(i+0.0); &#125; for(int i=1;i&lt;=r;i++)&#123; for(int j=1;j&lt;=c;j++)&#123; double tmp=f[i-1][j]*i*(n-j)+f[i][j-1]*(n-i)*j+f[i-1][j-1]*i*j+n*n; f[i][j]=tmp/(n*(i+j)-i*j); &#125; &#125; printf(&quot;%.2lf&quot;,f[r][c]); return 0;&#125; 还有一道题，不过比较水，居然用暴力枚举就可以做出来了，早知道我当时就直接枚举了，题目与韩信点兵类似","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"数论题目两道","slug":"数论的两道题","date":"2021-09-05T02:20:17.380Z","updated":"2021-09-05T02:20:19.565Z","comments":true,"path":"2021/09/05/数论的两道题/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%A4%E9%81%93%E9%A2%98/","excerpt":"","text":"错位排列这是一道水题，名字就直接告诉了题的内容和做题的方法，那么直接使用公式就可以了 12345678910111213141516171819202122232425262728//错排问题//就是不可以放在自己原来的位置上 //那么直接根据公式来就可以了//D=n!*(1-1/1!+1/2!+...) #include&lt;bits/stdc++.h&gt;using namespace std;long long fact[15];inline void init()&#123; fact[0]=1; for(int i=1;i&lt;=12;i++)fact[i]=fact[i-1]*i;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif init(); long long res; int n; scanf(&quot;%d&quot;,&amp;n); res=fact[n]; double tmp=1; for(int i=1;i&lt;=n;i++)&#123; tmp+=(pow(-1,i)/(fact[i]+0.0)); &#125; printf(&quot;%.0lf\\n&quot;,res*tmp); return 0;&#125; 计数器大概就是统计1~n中每一个数字出现了多少次。有10^9的数量级，所以不可以枚举的。因此要采取把每一位的数字分开来进行计算，即分解每一位，然后这一位前面的数字乘以这一位的权值(它在十的第几位，权值就是十的第几次方)，如果说这一位数字大于我们统计的数字，那么还可以再加上一次权值，而如果等于，则应该加上它后面的位数组成的数字+1，+1是因为后面的组成的还有全0。比如2533，再统计5时，统计到第三位，因为这这一位等于5，后面的位数组成的数字是33，但是漏了2500，所以要+1(注意0要进行特殊的判定，因为0在最前面是不符合计数的规则的)。那么代码如下洛谷的链接 123456789101112131415161718192021222324252627282930313233343536//计数器 #include&lt;bits/stdc++.h&gt;using namespace std;int data[11];void calc(int num,int tot)&#123; int cnt=0,k=1,upp,low,now; int tmp=tot; while(k&lt;=tot)&#123; upp=tot/(k*10); low=tot%k; now=tmp%10; cnt+=(upp*k); if(now&gt;num)cnt+=k; if(now==num)cnt+=(low+1); if(num==0)cnt-=k; k*=10; tmp/=10; if(tmp&lt;10&amp;&amp;num==0)break; &#125; data[num]=cnt;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif memset(data,0,sizeof(data)); int n; cin&gt;&gt;n; for(int i=0;i&lt;=9;i++)&#123; calc(i,n); &#125; for(int i=0;i&lt;=9;i++)printf(&quot;%d\\n&quot;,data[i]); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"排列组合","slug":"排列组合","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"数论的板子","slug":"数论的一些板子","date":"2021-09-05T02:20:17.371Z","updated":"2021-10-26T06:08:24.900Z","comments":true,"path":"2021/09/05/数论的一些板子/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%BF%E5%AD%90/","excerpt":"","text":"辗转相除法原始版本123inline int gcd(x,y)&#123; return (y==0)?x:gcd(y,x%y); &#125; 高级版本123456789101112inline void gcd(int x,int y)&#123; int i,j; if(!x)return y;if(!y)return x; for(i=0;!(x&amp;1);i++)x&gt;&gt;=1; for(j=0;!(j&amp;1);j++)j&gt;&gt;=1; i=min(i,j); while(true)&#123; if(x&lt;y)&#123;x^=y;y^=x;x^=y;&#125; if(!(x-=y))return y&lt;&lt;i;//这里也可以减法改成模 while(!(x&amp;1))x&gt;&gt;=1;//消除所有的2 &#125;&#125; 扩展欧几里得123456int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123;x=1;y=0;return a;&#125; int gcd=exgcd(b,a%b,x,y); int t=x;x=y;y=t-b/a*y; return gcd;&#125; 逆元12345int inv(int n,int p)&#123; //这里面求的是n在mod p情况下的逆元 if(n==1)return 1; else return -(p/n)*inv(p%n,p);&#125; 欧拉筛1234567891011int prm[maxn],cnt=0;bool isp[maxn]=&#123;1,1&#125;;//记录哪一些数不是质数void Eular_Sieve()&#123; for(int i=2;i&lt;maxn;i++)&#123; if(!isp[i])prm[++cnt]=i; for(int j=1;j&lt;cnt and i*prm[j]&lt;maxn;j++)&#123; isp[i*prm[j]]=true; if(!(i%prm[j]))break; &#125; &#125;&#125; 欧拉函数12345678910111213141516int prm[maxn],phi[maxn],cnt=0;bool isp[maxn]=&#123;1,1&#125;;//记录哪一些数不是质数void Eular_Sieve()&#123; phi[1]=1; for(int i=2;i&lt;maxn;i++)&#123; if(!isp[i])prm[++cnt]=i,phi[i]=i-1;//质数的phi值等于他自己减去1 for(int j=1;j&lt;cnt and i*prm[j]&lt;maxn;j++)&#123; isp[i*prm[j]]=true; if(!(i%prm[j]))&#123; phi[i*prm[j]]=phi[i]*prm[j] break; &#125; else phi[i*prm[j]]=phi[i]*(prm[j]-1); &#125; &#125;&#125; Lucas非递归形式 12345678910int Lucas(int n,int m,int p)&#123; int res=1,a,b; while(n&amp;&amp;m)&#123; int a=n%p,b=b%p; if(a&lt;b)return 0; (res*=C(a,b,p))%=p; n/=p;m/=p; &#125; return res;&#125; 递归形式 1234567891011121314151617181920212223242526long long qkpow(long long b,int p,int mod)&#123; long long res=1; while(p)&#123; if(p&amp;1)&#123; (res*=b)%=mod; &#125; (b*=b)%=mod; p&gt;&gt;=1; &#125; return res;&#125;long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125;long long Lucas(int n,int m,int p)&#123; if(m==0)return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125; Catalan Number123456f[0]=1for(int i=1;i&lt;=N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; f[i]=f[j]*f[i-1-j]; &#125;&#125; 1234f[0]=1;for(int i=1;i&lt;=N;i++)&#123; f[i]=((4*i-2)*f[i-1])/(i+1);&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://example.com/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://example.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"同余总结","slug":"同余总结","date":"2021-09-05T02:20:17.351Z","updated":"2021-09-05T02:20:18.864Z","comments":true,"path":"2021/09/05/同余总结/","link":"","permalink":"http://example.com/2021/09/05/%E5%90%8C%E4%BD%99%E6%80%BB%E7%BB%93/","excerpt":"","text":"同余定义若对于$a,b$两个整数，除以$m$的余数相等，则称$a$,$b$模$m$同余，记作$a\\equiv b(mod\\ m)$ 基本定理和性质 逆元：若$a*x\\equiv 1(mod\\ p)$,$a$,$b$互质,则称x是a的逆元，记为$a^{-1}$ 欧拉定理：若$a$,$m$互质，则$a^{\\phi(m)}\\equiv 1(mod \\ m)$ 扩展欧拉定理： $a^b\\equiv a^{b\\ mod\\ \\phi(m)+\\phi(m)}(mod\\ m)$ 贝祖定理：对于任意的整数$a,b,\\exists x,y,$使得$ax+by=gcd(a,b)$ 对于方程$ax+by=c$有整数解，当且仅当$gcd(a,b)|c$ 运用和板子 扩展欧几里得算法：可以用来解决线性的同余方程 逆元：可以用来解决有除法有需要取模的问题 欧拉定理：可以通过欧拉函数来进行降幂操作 板子仍然是去数论板子那一篇博客里面来看","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"}]},{"title":"对于质数知识的复习","slug":"质数复习","date":"2021-09-05T02:20:17.339Z","updated":"2021-09-05T02:20:20.181Z","comments":true,"path":"2021/09/05/质数复习/","link":"","permalink":"http://example.com/2021/09/05/%E8%B4%A8%E6%95%B0%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Problem List洛谷4161 洛谷2926 洛谷4397","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"}]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/categories/%E6%9D%82%E8%B0%88/"},{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"周记","slug":"周记","permalink":"http://example.com/categories/%E5%91%A8%E8%AE%B0/"},{"name":"讲座报告","slug":"讲座报告","permalink":"http://example.com/categories/%E8%AE%B2%E5%BA%A7%E6%8A%A5%E5%91%8A/"},{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"},{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"},{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"},{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"},{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://example.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"图","slug":"图","permalink":"http://example.com/tags/%E5%9B%BE/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://example.com/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"name":"排序算法","slug":"排序算法","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"元旦","slug":"元旦","permalink":"http://example.com/tags/%E5%85%83%E6%97%A6/"},{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"南京","slug":"南京","permalink":"http://example.com/tags/%E5%8D%97%E4%BA%AC/"},{"name":"抗日战争","slug":"抗日战争","permalink":"http://example.com/tags/%E6%8A%97%E6%97%A5%E6%88%98%E4%BA%89/"},{"name":"SPFA","slug":"SPFA","permalink":"http://example.com/tags/SPFA/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://example.com/tags/Dijkstra/"},{"name":"Floyd","slug":"Floyd","permalink":"http://example.com/tags/Floyd/"},{"name":"ST表","slug":"ST表","permalink":"http://example.com/tags/ST%E8%A1%A8/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"逆序对数","slug":"逆序对数","permalink":"http://example.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"},{"name":"2-SAT","slug":"2-SAT","permalink":"http://example.com/tags/2-SAT/"},{"name":"染色法","slug":"染色法","permalink":"http://example.com/tags/%E6%9F%93%E8%89%B2%E6%B3%95/"},{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"主席树","slug":"主席树","permalink":"http://example.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"dfs序","slug":"dfs序","permalink":"http://example.com/tags/dfs%E5%BA%8F/"},{"name":"fhq_treap","slug":"fhq-treap","permalink":"http://example.com/tags/fhq-treap/"},{"name":"SLF优化","slug":"SLF优化","permalink":"http://example.com/tags/SLF%E4%BC%98%E5%8C%96/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://example.com/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"},{"name":"期望","slug":"期望","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"K-D tree","slug":"K-D-tree","permalink":"http://example.com/tags/K-D-tree/"},{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"区间dp","slug":"区间dp","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"群论","slug":"群论","permalink":"http://example.com/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"Polya定理","slug":"Polya定理","permalink":"http://example.com/tags/Polya%E5%AE%9A%E7%90%86/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"博弈论","slug":"博弈论","permalink":"http://example.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"SG函数","slug":"SG函数","permalink":"http://example.com/tags/SG%E5%87%BD%E6%95%B0/"},{"name":"递推","slug":"递推","permalink":"http://example.com/tags/%E9%80%92%E6%8E%A8/"},{"name":"二分图","slug":"二分图","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"质数","slug":"质数","permalink":"http://example.com/tags/%E8%B4%A8%E6%95%B0/"},{"name":"约数","slug":"约数","permalink":"http://example.com/tags/%E7%BA%A6%E6%95%B0/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"康托展开","slug":"康托展开","permalink":"http://example.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"Lucas","slug":"Lucas","permalink":"http://example.com/tags/Lucas/"},{"name":"显克维奇作品选读","slug":"显克维奇作品选读","permalink":"http://example.com/tags/%E6%98%BE%E5%85%8B%E7%BB%B4%E5%A5%87%E4%BD%9C%E5%93%81%E9%80%89%E8%AF%BB/"},{"name":"排列","slug":"排列","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://example.com/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"排列组合","slug":"排列组合","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://example.com/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://example.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]}