{"meta":{"title":"Ddmiurge's blog","subtitle":"","description":"","author":"Ddmiurge","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-09-05T04:41:25.000Z","updated":"2021-09-05T05:06:18.856Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2021-09-05T04:40:08.000Z","updated":"2021-09-05T05:05:42.030Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"LGP2471","slug":"LGP2471","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T01:34:48.241Z","comments":true,"path":"2021/11/17/LGP2471/","link":"","permalink":"http://example.com/2021/11/17/LGP2471/","excerpt":"","text":"[LGP2471]([P2471 SCOI2007]降雨量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))Analysis​ 这道题要算到区间的最大值，而且又不需要进行修改，所以说就直接联想到了用ST表来对区间的最大值进行求解。 ​ 我们假设左边的年限$x$对应的序号为$l$,右边$y$为$r$,因为年限是按照顺序输入的，所以说可以直接用lower_bound进行查找，分成四种情况处理 左右区间的降水量都未知 直接输出maybe 左区间已知，右区间未知 如果$r==l+1$输出maybe(二者之间都是未知的) 先计算$[l+1,r]$区间的最大值，然后对于最大值和和左区间进行比较，如果说左区间的值小于最大值，输出false 否则的话就直接输出maybe 左区间未知，右区间已知 如果说$l==r$输出maybe(二者之间都是未知的) 计算$[l,r-1]$区间的最大值，然后最大值和右区间进行比较，如果说右区间的值小于最大值，输出false 否则的话输出maybe 左右区间都已知 如果说$r==l+1$并且$y==x+1$输出true 否则输出maybe 如果说左区间的值小于等于右区间的值的话，直接输出false 计算$[l+1,r-1]$区间的最大值，然后和右区间的值进行比较，如果说大于的话就直接输出false 然后看$r-l==y-x$是否成立（中间没有位置的），成立输出true 否则输出maybe Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 50005#define logn 20void init();inline int read();int N,M;int val[Maxn];int LG[Maxn];int year[Maxn];int ST[Maxn][logn];int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif N=read(); for(int i=1;i&lt;=N;i++)&#123;year[i]=read();val[i]=read();ST[i][0]=val[i];&#125; init(); M=read(); while(M--)&#123; int y=read(),x=read(); int posl=lower_bound(year+1,year+1+N,y)-year; int posr=lower_bound(year+1,year+1+N,x)-year; //二者都不已知 if((posl==N+1||y!=year[posl])&amp;&amp;(posr==N+1||x!=year[posr]))&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; //l已知 r未知 if((posl!=N+1&amp;&amp;y==year[posl])&amp;&amp;(posr==N+1||x!=year[posr]))&#123; if(posl+1==posr)&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; else&#123; int tmp=LG[(posr-1)-(posl+1)+1]; int maxv=max(ST[posl+1][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posl])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; //l未知,r已知 else if((posl==N+1||y!=year[posl])&amp;&amp;(posr!=N+1&amp;&amp;x==year[posr]))&#123; if(posl==posr)&#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; else&#123; int tmp=LG[(posr-1)-posl+1]; int maxv=max(ST[posl][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; //二者都已知 else&#123; if(val[posl]&lt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else if(posl+1==posr)&#123; if(x==y+1)&#123;cout&lt;&lt;&quot;true&quot;&lt;&lt;endl;continue;&#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; else&#123; int tmp=LG[(posr-1)-(posl+1)+1]; int maxv=max(ST[posl+1][tmp],ST[(posr-1)-(1&lt;&lt;tmp)+1][tmp]); if(maxv&gt;=val[posr])&#123;cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;continue;&#125; else if(posr-posl==x-y)&#123; cout&lt;&lt;&quot;true&quot;&lt;&lt;endl; continue; &#125; else &#123;cout&lt;&lt;&quot;maybe&quot;&lt;&lt;endl;continue;&#125; &#125; &#125; &#125; return 0;&#125;inline int read()&#123; int x=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; return x*sign;&#125;void init()&#123; LG[1]=0; for(int i=2;i&lt;Maxn;i++)&#123;LG[i]=LG[i&gt;&gt;1]+1;&#125; for(int i=1;i&lt;logn;i++)&#123; for(int j=1;j+(1&lt;&lt;i)-1&lt;=N;j++)&#123; ST[j][i]=max(ST[j][i-1],ST[j+(1&lt;&lt;i-1)][i-1]); &#125; &#125;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"ST表","slug":"ST表","permalink":"http://example.com/tags/ST%E8%A1%A8/"}]},{"title":"LGP4588","slug":"LGP4588","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T01:55:34.308Z","comments":true,"path":"2021/11/17/LGP4588/","link":"","permalink":"http://example.com/2021/11/17/LGP4588/","excerpt":"","text":"[LGP4588]([P4588 TJOI2018]数学计算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))Analysis​ 最开始拿到这一道题目的时候第一个反应是暴力求解问题。遇见除法的时候就直接乘上逆元来取模 ​ 但是$\\exist x, ax\\equiv1(mod\\ n)\\iff gcd(a,n)=1$ 对于每一组输入，第一行是两个数字 Q,M ​ 这个M是输入给的，不保证上面的条件。 ​ 这个时候就要转换思路了 ​ 我们考虑高精度直接硬算 ​ 两个操作每次就只修改一个数(单点修改)。 ​ 同余的性质：两个数相乘再去模等于两个数分别取模再相乘再取模（可以左右两边的结果合并） ​ 所以说可以考虑用线段树进行操作，选择以时间为轴（能想出来这种方法的真是神仙），这棵线段树应当有$n$个叶子节点，初始值为$1$，假如第$i$次操作是$1$操作，将第$i$个节点转换成为$m$,假如是$2$操作，将$pos$位置改成$1$,每次输出根节点的值就好了 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 100005class Segment_tree&#123; private: Int64 databank[Maxn&lt;&lt;2]; Int64 Mod; public: void SetMod(int M)&#123;Mod=M;&#125; void pushup(int nowpos)&#123; databank[nowpos]=(databank[nowpos&lt;&lt;1]*databank[nowpos&lt;&lt;1|1])%Mod; &#125; void init(int nowpos,int L,int R)&#123; if(L==R)&#123;databank[nowpos]=1;return;&#125; int mid=L+R&gt;&gt;1; init(nowpos&lt;&lt;1,L,mid); init(nowpos&lt;&lt;1|1,mid+1,R); pushup(nowpos); &#125; void modify(int nowpos,int L,int R,int pur,int val)&#123; if(L==R&amp;&amp;L==pur)&#123; databank[nowpos]=val; return; &#125; int mid=L+R&gt;&gt;1; if(pur&lt;=mid)modify(nowpos&lt;&lt;1,L,mid,pur,val); if(pur&gt;mid)modify(nowpos&lt;&lt;1|1,mid+1,R,pur,val); pushup(nowpos); &#125; void output()&#123;cout&lt;&lt;databank[1]&lt;&lt;endl;&#125;&#125;S;inline void read(int &amp;x)&#123; x=0;char c=getchar();while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif int t;read(t); while(t--)&#123; int q,m;read(q);read(m); S.SetMod(m); S.init(1,1,q); for(int i=1;i&lt;=q;i++)&#123; int op,v;read(op);read(v); if(op==1)S.modify(1,1,q,i,v),S.output(); else&#123; S.modify(1,1,q,v,1); S.output(); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"LGP1966","slug":"LGP1966","date":"2021-10-28T02:32:05.305Z","updated":"2021-10-28T02:47:58.587Z","comments":true,"path":"2021/10/28/LGP1966/","link":"","permalink":"http://example.com/2021/10/28/LGP1966/","excerpt":"","text":"LGP1966Analysis观察$\\sum_{1}^{n}(a_i-b_i)^2$,展开发现$a_i^2,b_i^2$的总和是固定的，所以说为了满足题目条件，就应该让$\\sum a_ib_i$尽可能大。由排序不等式可知，顺序和是最大的，所以说这道题就可以转换成一道逆序对数的题目 关于排序不等式戳这 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#include&lt;bitset&gt;#include&lt;set&gt;#include&lt;cmath&gt;using namespace std;#define rint register int#define Int64 long long#define max(x,y) (((x)&gt;(y))?(x):(y))#define min(x,y) (((x)&lt;(y))?(x):(y))#define clr(x,y) memset(x,y,sizeof(x))#define sqar(x) (x)*(x)#define lowbit(x) (x&amp;(-x))#define swp(x,y) x^=y,y^=x,x^=y#define Maxn 100005#define Mod 99999997int N,ans;struct dbk&#123; int val; int pos; bool operator &lt;(const dbk &amp;obj)const&#123; return val&lt;obj.val; &#125;&#125;A[Maxn],B[Maxn];int tmp[Maxn];struct tree_array&#123; int v[Maxn]; void modify(int pos)&#123; while(pos&lt;=N)&#123; v[pos]++; pos+=lowbit(pos); &#125; &#125; int query(int pos)&#123; int res=0; while(pos)&#123; res+=v[pos]; res%=Mod; pos-=lowbit(pos); &#125; return res; &#125;&#125;T;void sol()&#123; for(int i=1;i&lt;=N;i++)&#123; cin&gt;&gt;A[i].val; A[i].pos=i; &#125; for(int i=1;i&lt;=N;i++)&#123; cin&gt;&gt;B[i].val; B[i].pos=i; &#125; sort(A+1,A+1+N); sort(B+1,B+1+N); for(int i=1;i&lt;=N;i++)&#123; tmp[A[i].pos]=B[i].pos; &#125; for(int i=1;i&lt;=N;i++)&#123; T.modify(tmp[i]); ans+=(T.query(N)-T.query(tmp[i])); ans%=Mod;ans+=Mod;ans%=Mod; &#125;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif cin&gt;&gt;N; sol(); cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"逆序对数","slug":"逆序对数","permalink":"http://example.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"}]},{"title":"大学第一篇博客","slug":"大学的第一篇博客","date":"2021-09-16T03:55:21.840Z","updated":"2021-09-16T04:00:09.539Z","comments":true,"path":"2021/09/16/大学的第一篇博客/","link":"","permalink":"http://example.com/2021/09/16/%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"重新弄了一下博客，也没有什么想说的。完了，只是说明我还活着","categories":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"线性代数笔记","slug":"线性代数笔记","date":"2021-09-15T16:00:00.000Z","updated":"2021-10-04T09:30:16.703Z","comments":true,"path":"2021/09/16/线性代数笔记/","link":"","permalink":"http://example.com/2021/09/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 前两周笔记比较少就不记录了 第三周逆矩阵的定义与性质 定义：设$A$为方阵，若存在方阵$B$,使得$AB=BA=E$，则称$A$可逆,并称$B$为$A$的逆矩阵，记作$A^{-1}$ 定理一：若矩阵$A$可逆，则逆矩阵唯一 定理二：初等矩阵都可逆，且初等矩阵逆矩阵仍是初等矩阵$$E(i,j)E(i,j)=E\\Rightarrow E(i,j)^{-1}=E(i,j)\\E(i(k))E(i(k^{-1}))=E\\Rightarrow E(i(k))^{-1}=E(i(k^{-1}))\\E(i,j(k))E(i,j(-k))=E\\Rightarrow E(i,j(k))^{-1}=E(i,j(-k))$$ 可逆的行最简行矩阵为单位矩阵 若$A$可逆，$k$为常数，则$A^T,A^{-1}$也可逆且$$(A^{-1})^{-1}=A\\(A^{-1})^{T}=(A^{T})^{-1}\\(kA)^{-1}=k^{-1}A^{-1}$$ $A,B$为同阶可逆矩阵$(AB)^{-1}=B^{-1}A^{-1}$ $A$可逆$\\Leftrightarrow A$可以写作一些初等矩阵的乘积 推论: $A$可逆$\\Leftrightarrow A$可经初等行变换转换为单位矩阵 设$A$为$m\\times n$矩阵，则存在$m$阶可逆矩阵$P$和$n$阶可逆矩阵$Q$使得$A=PE^{(r)}{m\\times n}Q$其中$$E^{(r)}{m\\times n}=\\begin{bmatrix}{E^r}&amp;{O}\\{O}&amp;{O}\\ \\end{bmatrix}$$ ​ $E^{(r)}_{m\\times n}$称作$A$的等价标准型 利用初等变换求逆矩阵$$(A\\ E)\\stackrel{初等行变换}\\longrightarrow(E\\ A^{-1})\\\\begin{bmatrix}{A}\\{E}\\end{bmatrix}\\stackrel{初等列变换}\\longrightarrow \\begin{bmatrix}{E}\\{A^{-1}}\\end{bmatrix}$$ 行列式定义 当$n\\ge 2$时,定义$n$阶行列式$D=\\Sigma^{n}{k=1}a{1k}A_{1k}$其中$A_{1k}$为$a_{1k}$代数余子式 第四周行列式的性质设 $A$为$n$阶方阵。$D=|A|$则$D^T=|A^T|$称为$D$的转置 $|A|=|A^T|$ 互换行列式中的两行(列)，行列式变号 推论：如果行列式$D$当中有两行(列)完全相同，则 $D=0$ $A\\stackrel{kr_1}\\longrightarrow B\\ |B|=k|A|$ $A\\stackrel{r_j+kr_i}\\longrightarrow B\\ |B|=|A|$ 上三角或下三角行列式值为对角线元素相乘 $|AB|=|A||B|$ PS：求行列式的时候用等号而不用箭头连接，矩阵初等变换用箭头（否则$CJL老师$视作0918旷课） 行列式的计算 二三阶行列式可用对角线法则 按某一列（行）展开 转置不改变行列式的值 常用的计算高阶行列式的办法 利用初等变化化为三角想 降阶 伴随阵和逆矩阵 $A^*A=|A|E$ $n$阶矩阵$A$可逆的充分必要条件是 $|A|\\not=0$.当$|A|\\not=0$且$n\\geq2$时$A^{-1}=\\frac{1}{|A|}A^*$ 若$A$为n阶矩阵若存在$n$阶矩阵$B$使得$AB=E$（或$BA=E$）则$A$是可逆的且$B=A^{-1}$ 分块对角矩阵$A=diag(A_1,A_2,……,A_s)$可逆的充分必要条件是$A_i(i=1,2,……,s)$均可逆，在此条件下$A^{-1}$也是分块对角矩阵且$A^{-1}=diag(A_1^{-1},A_2^{-1},……,A_s^{-1})$ $|A^*|=|A|^{n-1}$ 第五周克拉默法则设线性方程组$$Ax=b\\A=(a_{ij})_{n\\times n}=(\\alpha_1,……,\\alpha_n),x=(x_1,……,x_n)^T,b=(b_1,……,b^n)^T\\若D=|A|\\not=0,则线性方程组有唯一解且\\x_j=\\frac{D_j}{D}$$ 矩阵的秩 $0\\leq r(A_{m\\times n})\\leq min(m,n)$ $A$为$n$阶矩阵，若$|A|\\not=0$,则称其为非奇异矩阵，若$r(A)=n$,则称$A$为满秩方阵 初等变换不改变矩阵的秩 $r(A)=r(A^T)$ 若矩阵$A,B$等价，则$r(A)=r(B)$ $r(A)=r(PA)=r(AQ)=r(PAQ)$其中$P,Q$是可逆矩阵 设$A$为$s\\times m$矩阵$B$为$s\\times n$矩阵则 $$max(r(A),r(B))\\leq r(A,B)\\leq r(A)+r(B)$$ 设$A$为$s\\times n$矩阵$B$为$n\\times t$矩阵则$$r(AB)\\leq min(r(A),r(B))\\r(AB)\\geq r(A)+r(B)-n$$","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"2-SAT问题","slug":"2-SAT问题","date":"2021-09-05T02:20:23.262Z","updated":"2021-09-05T02:24:38.760Z","comments":true,"path":"2021/09/05/2-SAT问题/","link":"","permalink":"http://example.com/2021/09/05/2-SAT%E9%97%AE%E9%A2%98/","excerpt":"","text":"2-SAT问题描述有n个组，第i个组里有两个节点$A_i, A_i’$ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的n个点都能两两相容。这类型的问题我们称之为2-SAT问题 问题引入Question 某国有N个党派，每个党派里面有且只有两个代表（编号连续），要求从中选一个代表出来组成和平委员会，且如果两个代表不和，则他们不能同时属于委员会 Sample Input1233 21 32 4 Sample Output1231 45 Analysis理解可以通过图论知识来解决，如果选1,则不能选4,只能选3,而如果选4，则只能选2，所以我们根据这个来建立有向边。 $Conclusion$:若所有$i_1,i_2$都不在同一个强分支，则有解。 对于判定强分支有以下的方法 $Kusarajo$,$Tarjan$ 染色法 这里选择使用染色法 染色法从每一个组别开始去$dfs$,将要选择的点依次标记出来，并把其相关的必选点也同样染色，如果出现了冲突，则清除染色方案，重新染色。 12345678910111213141516171819202122232425//color是标记颜色的，other记录同一组中另外一个元素是多少//stk是手动的栈，这里采用链式前向星存图bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u;//记录 for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,false,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[2*i-1]||color[2*i])continue; //已经染过了色 top=0; if(!DFS(2*i-1))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(2*i))return false; &#125; &#125; return true;&#125; 这里来说一下这一段代码 123for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true; 注意这里不可以写成 1return DFS(to[i]); 因为这一点染色是否成功要看与之相关的所有的点的染色是否成功，而如果有相关一个点失败了，那么就是失败了，要回去重新$dfs$ Codes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define maxn 8005#define maxm 20005using namespace std;int other[maxn*2],ans[maxn],N,M,tot=0;int head[maxn],to[maxm],nxt[maxm];bool color[maxn];int stk[maxn],top=0;inline int read()&#123; int res=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125; void init(int K)&#123; for(int i=1;i&lt;=2*K;i++) other[i]=(i&amp;1)?i+1:i-1;&#125;inline void addedge(int x,int y)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot;&#125;bool DFS(int u);bool twoSAT();int main()&#123; N=read();M=read(); init(N); for(int i=1;i&lt;=M;i++)&#123; int a=read(),b=read(); addedge(a,other[b]); addedge(b,other[a]); //a,b之间是相互冲突的，如果a选了的话，那么就 //必须要选b所在组别的另外一个，如果是b选了同理 &#125; if(twoSAT())&#123; for(int i=1;i&lt;=2*N;i++)if(color[i])printf(&quot;%d\\n&quot;,i); &#125; else printf(&quot;NIE&quot;); return 0;&#125;bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u;//记录 for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,false,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[2&lt;&lt;i-1]||color[2*i])continue; //已经染过了色 top=0; if(!DFS(2*i-1))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(2*i))return false; &#125; &#125; return true;&#125; 例题洛谷P4782链接：洛谷P4782 Analysis就和它自己说的一样，这是一道模板题，这里选择把真和假的两种状态作为所说的选择。所以就选择用$i$表示这一个点要选，$i+N$来表示这一个点不选 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define maxn 1000005using namespace std;int color[maxn&lt;&lt;1],N,M,other[maxn&lt;&lt;1];int stk[maxn&lt;&lt;1],top=0;int head[maxn&lt;&lt;1],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],tot=0;//i表示 这一个节点真,i+N表示假 inline int read()&#123; int res=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125;void init(int K)&#123; for(int i=1;i&lt;=2*K;i++) other[i]=(i&lt;=K)?(i+K):(i-K);&#125;inline void add(int x,int y)&#123; to[++tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;bool DFS(int u);bool twoSAT();int main()&#123; N=read();M=read(); init(N); int a,b,c,d; for(int i=1;i&lt;=M;i++)&#123; a=read();b=read(); c=read();d=read(); add(a+!b*N,c+d*N); add(c+!d*N,a+b*N); &#125; if(twoSAT())&#123; printf(&quot;POSSIBLE\\n&quot;); for(int i=1;i&lt;=N;i++)&#123; printf(&quot;%d &quot;,color[i]&lt;color[i+N]); &#125; &#125; else printf(&quot;IMPOSSIBLE&quot;); return 0;&#125;bool DFS(int u)&#123; if(color[u])return true; if(color[other[u]])return false; color[u]=true; stk[++top]=u; for(int i=head[u];i;i=nxt[i]) if(!DFS(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(color,0,sizeof(color)); for(int i=1;i&lt;=N;i++)&#123; if(color[i]||color[i+N])continue; top=0; if(!DFS(i))&#123; while(top)color[stk[top]]=false,top--; if(!DFS(i+N))return false; &#125; &#125; return true;&#125; 洛谷P4171链接：洛谷P4171 Analysis这题里面一种材料要么就只能做满洲菜，要么就做汉族菜，因此每一种材料，汉族菜和满洲菜就相当于是对应着$true$和$false$两种状态了，因此就这样来染色法解决问题。这一道题最需要注意的是在于输入时，每一道菜的序号不一定只有一位数。 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define maxn 105#define maxm 1005using namespace std;int head[maxn&lt;&lt;1],to[maxm&lt;&lt;1],nxt[maxm&lt;&lt;1],tot=0;int stk[maxn&lt;&lt;1],top=0;int col[maxn&lt;&lt;1],other[maxn&lt;&lt;1],N,M,K;inline int read()&#123; int res=0,sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&lt;=&#x27;9&#x27;&amp;&amp;c&gt;=&#x27;0&#x27;)&#123;res=res*10+c-48;c=getchar();&#125; return res*sign;&#125;void init(int K)&#123; for(int i=1;i&lt;=K;i++) other[i]=i+N,other[i+N]=i;;&#125;inline void add(int x,int y)&#123; to[++tot]=y;nxt[tot]=head[x];head[x]=tot;&#125;bool dfs(int u);bool twoSAT();int main()&#123; K=read(); while(K--)&#123; N=read();M=read(); init(N); for(int i=1;i&lt;=M;i++)&#123; int x=0,y=0,rep=1; char kd[5]; cin&gt;&gt;kd; while(kd[rep]&gt;=&#x27;0&#x27;&amp;&amp;kd[rep]&lt;=&#x27;9&#x27;)&#123; x=x*10+kd[rep]-48; rep++; &#125; if(kd[0]==&#x27;m&#x27;)x+=N; cin&gt;&gt;kd; rep=1; while(kd[rep]&gt;=&#x27;0&#x27;&amp;&amp;kd[rep]&lt;=&#x27;9&#x27;)&#123; y=y*10+kd[rep]-48; rep++; &#125; if(kd[0]==&#x27;m&#x27;)y+=N;//注意这里的输入很重要 add(x,other[y]); add(y,other[x]); &#125; if(twoSAT())printf(&quot;GOOD\\n&quot;); else printf(&quot;BAD\\n&quot;); memset(other,0,sizeof(other)); memset(to,0,sizeof(to)); memset(head,0,sizeof(head)); memset(nxt,0,sizeof(nxt)); tot=0; &#125;&#125;bool dfs(int u)&#123; if(col[u])return true; if(col[other[u]])return false; col[u]=1; stk[++top]=u; for(int i=head[u];i;i=nxt[i]) if(!dfs(to[i]))return false; return true;&#125;bool twoSAT()&#123; memset(col,0,sizeof(col)); for(int i=1;i&lt;=N;i++)&#123; if(col[i]||col[i+N])continue; top=0; if(!dfs(i))&#123; while(top)col[stk[top]]=0,top--; if(!dfs(i+N))return false; &#125; &#125; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://example.com/tags/2-SAT/"},{"name":"染色法","slug":"染色法","permalink":"http://example.com/tags/%E6%9F%93%E8%89%B2%E6%B3%95/"}]},{"title":"20190709 test","slug":"20190709","date":"2021-09-05T02:20:23.192Z","updated":"2021-09-05T02:20:23.540Z","comments":true,"path":"2021/09/05/20190709/","link":"","permalink":"http://example.com/2021/09/05/20190709/","excerpt":"","text":"T1Desctription 一队勇士正在向你进攻，每名勇士都有一个战斗值$a_i$。但是这队勇士却有一个致命弱点，如果存在$i$&lt;$j$&lt;$k$使得$a_i$&gt;$a_j$&gt;$a_k$，则会影响他们整体的战斗力。我们将这样的一组(i,j,k)称为这队勇士的一个弱点。请求出这队勇士的弱点数目。 Input 输入文件：$weakness.in$ 输入的第一行是一个整数n，表示勇士的数目。 接下来一行包括n个整数，表示每个勇士的战斗值$a_i$ Output 输入文件：$weakness.out$ 输出为一行，包含一个整数。表示这队勇士的弱点数目。 Anlysis这一道题很明显的就是一个逆序对数的题目，求每一个数和前面的数可以组成多少逆序对数，和后面可以组成多少逆序对数，然后乘起来，用树状数组来进行计算就可以了。 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define lowbit(x) x&amp;(-x) #define maxn 1000000using namespace std;int N,a[maxn+5];int dat[maxn+5],dat2[maxn+5];int par[maxn+5],par2[maxn+5];int limnum=0;long long ans=0;inline void read(int &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;void upd(int x,int d[])&#123; while(x&lt;=limnum)&#123; d[x]++; x+=lowbit(x); &#125; &#125;long long sum(int x,int d[])&#123; int res=0; while(x&gt;0)&#123; res+=d[x]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; freopen(&quot;weakness.in&quot;,&quot;r&quot;,stdin); freopen(&quot;weakness.out&quot;,&quot;w&quot;,stdout); read(N); for(int i=1;i&lt;=N;i++)&#123; read(a[i]); if(a[i]&gt;limnum)limnum=a[i]; &#125; for(int i=1;i&lt;=N;i++)&#123; upd(a[i],dat); par[i]=sum(limnum,dat)-sum(a[i],dat); upd(a[N-i+1],dat2); par2[N-i+1]=sum(a[N-i+1]-1,dat2); &#125; for(int i=1;i&lt;=N;i++)&#123; ans+=(par[i]*par2[i]); &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"}]},{"title":"20190710 test","slug":"20190710test","date":"2021-09-05T02:20:22.933Z","updated":"2021-09-23T14:41:27.575Z","comments":true,"path":"2021/09/05/20190710test/","link":"","permalink":"http://example.com/2021/09/05/20190710test/","excerpt":"","text":"20190710的testT1Desctription 传说，数千年前圣帕特里克消灭了哞尔兰所有的蛇。然而，蛇们现在卷土重来了！圣帕特里克节是在每年的3月17日，所以小明要用彻底清除哞尔兰所有的蛇来纪念圣帕特里克。小明装备了一个捕网，用来捕捉N组排成一行的蛇（1≤N≤400）。小明必须按照这些组在这一行中出现的顺序捕捉每一组的所有蛇。每当小明抓完一组蛇之后，她就会将蛇放在笼子里，然后带着空的捕网开始捕捉下一组。 一个大小为s的捕网意味着小明可以抓住任意包含g条的一组蛇，其中g≤s。然而，每当小明用大小为s的捕网抓住了一组g条蛇，就意味着浪费了s−g的空间。小明可以任意设定捕网的初始大小，并且她可以改变K次捕网大小（1≤K&lt;N）。 请告诉小明她捕捉完所有组的蛇之后可以达到的总浪费空间的最小值。 Input 输入的第一行包含N和K。第二行包含N个整数$a_1$,…,$a_N$，其中$a_i$（0≤$a_i$≤10^6）为第i组蛇的数量 Output 输出一个整数，为小明抓住所有蛇的总浪费空间的最小值。 Anlysis这一道题一眼就可已看出来是在考$dp$,那么问题就在于如何来设计方程了,考试的时候我设计了一个三维的状态，接着循环写了四层，然后不负众望，$TLE$了。（而$WYXdalao$轻松$AC$） 然后重新来看，设$f[i][j]$代表第$i$个时候，用了$j$个袋子时最少浪费了多少，我们提前预处理出一个前缀和，用来获取区间内蛇的数量，因为要放下所有的蛇，所以说数量要选择最大那一个来减。 Codes123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define maxn 405#define inf 0x3f3f3f3fusing namespace std;int N,K;int f[maxn][maxn];int a[maxn],mxn[maxn][maxn]; int sum[maxn];int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); memset(f,0x3f,sizeof(f)); for(register int i=1;i&lt;=N;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; //边界 K++;//因为j要减1,所以避免负数 f[0][0]=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=min(K,i);j++)&#123; int mxn=a[i]; for(int k=i-1;k&gt;=0;k--)&#123; f[i][j]=min(f[i][j],f[k][j-1]+mxn*(i-k)-(sum[i]-sum[k])); mxn=max(mxn,a[k]); &#125; &#125; &#125; int ans=inf; for(int i=0;i&lt;=K;i++)&#123; ans=min(ans,f[N][i]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; T2Desctription 小明喜欢养宠物，想要将编号为1…N的N只宠物（N≤7500）分为非空的K组（2≤K≤N），使得任意两只来自不同组的宠物都需要走一定的距离才能相遇。宠物x和宠物y（其中1≤x&lt;y≤N）愿意为了见面走 ($2019201913x$+$2019201949y$) mod $2019201997$英里。给定一个将N只宠物分为K个非空小组的分组方案，令M为任意两头来自不同组的宠物愿意为了见面行走的英里数的最小值。为了测试宠物们相互之间的忠诚度，小明想要将N头宠物以最佳的方式分为K组，使得M尽可能大 Input 输入仅有一行，包含N和K，用空格分隔。 Output 输出最优的M。 Anlysis考试的时候我没有想到可以来找规律!!!$$(2019201913x+2019201949y)\\mod 2019201997\\\\=(-84x-48y)\\mod 2019201997$$所以$y=N $,$x=K-1$时最大 Codes123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int N,K; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); printf(&quot;%d&quot;,-84*(K-1)-48*N+2019201997); return 0;&#125; T3Desctription 设T 为一棵有根树，我们做如下的定义： • 设a和b为T 中的两个不同节点。如果a是b的祖先，那么称“a比b不知道 高明到哪里去了”。 • 设a 和 b 为 T 中的两个不同节点。如果 a 与 b 在树上的距离不超过某个给定 常数x，那么称“a 与b 谈笑风生”。 给定一棵n个节点的有根树T，节点的编号为1 到 n，根节点为1号节点。你需 要回答q 个询问，询问给定两个整数p和k，问有多少个有序三元组(a;b;c)满足： a、b和 c为 T 中三个不同的点，且 a为p 号节点； a和b 都比 c不知道高明到哪里去了； a和b 谈笑风生。这里谈笑风生中的常数为给定的 k。 Input 输入文件的第一行含有两个正整数n和q，分别代表有根树的点数与询问的个数。接下来n – 1行，每行描述一条树上的边。每行含有两个整数u和v，代表在节点u和v之间有一条边。 接下来q行，每行描述一个操作。第i行含有两个整数，分别表示第i个询问的p和k。。 Output 输出 q 行，每行对应一个询问，代表询问的答案。 Anlysis这一道题，首先要明白，要分两种情况 $b$是$a$的祖先，这种情况比较简单，可以根据乘法原理，在$O(1)$内得到答案 $b$是$a$的子孙，这种情况就不好求了，要用主席树来做，选择以深度为下标，$size$作为维护的值进行修改。还要用到$dfs$序，一个节点和他的子树的序号是一个连续的区间，这样来进行查询 考试的时候，当然就是没有做出来了 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define maxn 600300#define Int64 long longusing namespace std;int N,Q;int siz[maxn],dep[maxn],fa[maxn];int head[maxn],to[maxn],nxt[maxn],tot=0;int cnt=0,s=0;int dfn[maxn],Root[maxn];int maxdep=0;struct nde&#123; int lch,rch; Int64 data;&#125;sgt[maxn*20];inline void read(int &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign; &#125;inline void add(int x,int y)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot;&#125;void dfs(int u)&#123; siz[u]=1; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!siz[v])&#123; dep[v]=dep[u]+1; maxdep=max(dep[v],maxdep); fa[v]=u; dfs(v); siz[u]+=siz[v]; &#125; &#125;&#125;void insert(int &amp;p,int l,int r,Int64 val,int pur)&#123; sgt[++s]=sgt[p]; p=s; sgt[p].data+=val; if(l==r)return; int mid=(l+r)&gt;&gt;1; if(mid&gt;=pur)insert(sgt[p].lch,l,mid,val,pur); else insert(sgt[p].rch,mid+1,r,val,pur);&#125;Int64 query(int ver1,int ver2,int l,int r,int x,int y)&#123; if(l==x&amp;&amp;r==y)return sgt[ver2].data-sgt[ver1].data; int mid=(l+r)&gt;&gt;1; if(mid&gt;=y)return query(sgt[ver1].lch,sgt[ver2].lch,l,mid,x,y); else if(mid&lt;x) return query(sgt[ver1].rch,sgt[ver2].rch,mid+1,r,x,y); else return query(sgt[ver1].lch,sgt[ver2].lch,l,mid,x,mid)+query(sgt[ver1].rch,sgt[ver2].rch,mid+1,r,mid+1,y);&#125; void dfs_(int u)&#123; dfn[u]=++cnt; Root[cnt]=Root[cnt-1];//insert里面会给这个root赋值的 insert(Root[cnt],1,maxdep,(Int64)siz[u]-1,dep[u]); //因为是以dep作为下标来的，所以是1-maxdep //然后每一个深度相同的插入可以当作对这个的修改。 for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(v!=fa[u])dfs_(v); &#125;&#125;int main()&#123; //freopen(&quot;talk.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;talk.out&quot;,&quot;w&quot;,stdout); read(N);read(Q); for(int i=1;i&lt;=N-1;i++)&#123; int x,y; read(x);read(y); add(x,y);add(y,x); &#125; dep[1]=1; dfs(1); dfs_(1); while(Q--)&#123; int p,k; read(p);read(k); if(dep[p]==maxdep)&#123;printf(&quot;0\\n&quot;);continue;&#125; Int64 ans=0; ans+=(long long)(min(k,dep[p]-1))*(siz[p]-1); int l=dfn[p]-1,r=dfn[p]+siz[p]-1; ans+=query(Root[l],Root[r],1,maxdep,dep[p]+1,min(maxdep,dep[p]+k)); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://example.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"dfs序","slug":"dfs序","permalink":"http://example.com/tags/dfs%E5%BA%8F/"}]},{"title":"20190712的test","slug":"20190712test","date":"2021-09-05T02:20:22.776Z","updated":"2021-09-07T06:05:06.081Z","comments":true,"path":"2021/09/05/20190712test/","link":"","permalink":"http://example.com/2021/09/05/20190712test/","excerpt":"","text":"T1Description N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.例如颜色分别为1,2,2,1的四个布丁一共有3段颜色. Input 第一行给出N,M表示布丁的个数和好友的操作次数. 第二行N个数$A_1$,$A_2$…$A_n$表示第i个布丁的颜色从第三行起有M行,对于每个操作,若第一个数字是1表示要对颜色进行改变，其后的两个整数X,Y表示将所有颜色为X的变为Y，X可能等于Y. 若第一个数字为2表示要进行询问当前有多少段颜色，这时你应该输出一个整数. Output 针对第二类操作即询问，依次输出当前有多少段颜色. Sample Input123454 31 2 2 121 2 12 Sample Output1231 Analysis","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"fhq_treap","slug":"fhq-treap","permalink":"http://example.com/tags/fhq-treap/"}]},{"title":"20190723的test","slug":"20190723","date":"2021-09-05T02:20:22.666Z","updated":"2021-09-05T02:20:23.443Z","comments":true,"path":"2021/09/05/20190723/","link":"","permalink":"http://example.com/2021/09/05/20190723/","excerpt":"","text":"TrafficDescription​ 工人打算用一组传感器测量公路上的车流量，每个传感器被用来测量一小段路面上的车流量的数值。不幸的是，某一天装有传感器的盒子进了水，之后它们就不能精确的测量了。现在每个传感器只能输出一个可能结果的范围。例如，一个传感器可能会给出范围[7,13]，表示在这段路面上的车流量不小于7，并且不大于13。 ​ 高速路要测量的这一段长N英里，当然高速路都是单向的，从第1英里驶向第N英里。工人想要安装N个传感器——每个监测1英里长的路段。在其中某些路段上，有能够使得车辆进入高速公路的上匝道，在这样的路段上，工人会将传感器装在上匝道上，测量流入的车流量。在某些路段上有能够使得车辆离开高速公路的下匝道，在这样的路段上，工人会将传感器装在下匝道上。每一个路段包含至多一个匝道。如果在公路的一个路段上没有上匝道或下匝道，工人就将传感器装在高速公路的主路上。 ​ 给定N个传感器的读数，请求出在高速公路第1英里之前和第N英里之后车流量的最为准确的可能范围。这些范围应当与所有N个传感器的读数相一致。 Input​ 输入的第一行包含N（1≤N≤100）。余下N行每行按从第1英里至第N英里的顺序描述一段1英里长的路段。每行包含一个字符串，为”on”（如果这段路上有一个上匝道），”off”（如果这段路上有一个下匝道），或者是”none”（如果这段路上没有匝道），然后是两个范围为0…1000的整数，表示这段路上的传感器的读数所给出的下界、上界。至少一个高速公路路段的描述会是”none”。 Output​ 输出的第一行包含两个整数，为第1英里之前的车流量的最准确的可能范围。第二行包含两个整数，为第N英里之后的车流量的最准确的可能范围。输入保证存在符合要求的解。 Analysis前后扫一遍即可 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//正反各自扫一遍?过程中求交集和加减? #include&lt;bits/stdc++.h&gt;#define maxn 105#define inf 0x3f3f3f3f#define max(x,y) (x&gt;y)?x:y#define min(x,y) (x&lt;y)?x:yusing namespace std; int N;struct data&#123; char op[5]; int L,R;&#125;d[maxn];int main()&#123; freopen(&quot;traffic.in&quot;,&quot;r&quot;,stdin); freopen(&quot;traffic.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;N); int fs=0,fe=0; for(int i=1;i&lt;=N;i++)&#123; scanf(&quot;%s%d%d&quot;,d[i].op,&amp;d[i].L,&amp;d[i].R); &#125; int FL=-inf,FR=inf,EL=-inf,ER=inf; for(int i=N;i&gt;=1;i--)&#123; if(d[i].op[0]==&#x27;n&#x27;)&#123; FL=max(FL,d[i].L); FR=min(FR,d[i].R); &#125; if(d[i].op[0]==&#x27;o&#x27;&amp;&amp;d[i].op[1]==&#x27;n&#x27;)&#123; FL-=max(d[i].R,d[i].L); FR-=min(d[i].L,d[i].R); &#125; if(d[i].op[1]==&#x27;f&#x27;)&#123; FL+=min(d[i].L,d[i].R); FR+=max(d[i].R,d[i].L); &#125; &#125; printf(&quot;%d %d\\n&quot;,max(FL,0),FR); for(int i=fe;i&lt;=N;i++)&#123; if(d[i].op[0]==&#x27;o&#x27;&amp;&amp;d[i].op[1]==&#x27;n&#x27;)&#123; EL+=min(d[i].L,d[i].R); ER+=max(d[i].L,d[i].R); &#125; if(d[i].op[1]==&#x27;f&#x27;)&#123; EL-=max(d[i].R,d[i].L); ER-=min(d[i].L,d[i].R); &#125; if(d[i].op[0]==&#x27;n&#x27;)&#123; EL=max(EL,d[i].L); ER=min(ER,d[i].R); &#125; &#125; printf(&quot;%d %d&quot;,max(EL,0),ER); fclose(stdin); fclose(stdout); return 0;&#125; PaintDescription​ $Todobe$要把她的寝室弄得漂漂酿酿，所以她管$Yashem66$要了一些墙纸。 ​ $Todobe$有一面墙，可分为n块，$Yashem66$提供的所有墙纸都是统一规格的，均只可覆盖连续k块完整的墙面，但是有m种不同的颜色的墙纸，每种颜色的墙纸都有无限张。$Todobe$要用这些墙纸把墙贴满，墙纸不可以裁剪，墙纸与墙纸之间可以有重叠部分。当墙纸重叠时，只能看到最外层的墙纸颜色。 ​ $Todobe$想知道她以不同的方式贴墙纸，共能贴出多少种不同配色方案的墙面，两种方案不同当且仅当两种方案中至少有一块墙面的颜色不同。 Input输入一行3个整数n,m,k。 Output输出一行一个整数代表方案数量，答案取模$1e9+7$ Analysis这一道题目很不好想，首先，对于$N$个块，$M$个颜色，一共有$M^N$种方案，然后通过模拟可以发现，这里面肯定有一个连续K个块是同一个颜色的，这就好了，联想到核电站问题的做法就可以了.但是因为数据范围很大，所以要用到矩阵乘法来优化，注意快速幂要开$long;long$否则会出错 Codes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll mod=(ll)1e9+7;int N,M,K;ll A[105][105];ll qkpow(ll d,ll p)&#123; ll res=1; while(p)&#123; if(p&amp;1)res=(res*d)%mod; d=(d*d)%mod; p&gt;&gt;=1; &#125; return res;&#125;void mul(ll *a,ll (*b)[105])&#123; ll tmp[105]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=K-1;i++) for(int j=1;j&lt;=K-1;j++) (tmp[i]+=(a[j]*b[j][i]))%=mod; memcpy(a,tmp,sizeof(tmp));&#125; void mulslf(ll (*a)[105])&#123; ll tmp[105][105]; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=K-1;i++)&#123; for(int j=1;j&lt;=K-1;j++)&#123; for(int k=1;k&lt;=K-1;k++)&#123; (tmp[i][j]+=a[i][k]*a[k][j])%=mod; &#125; &#125; &#125; memcpy(a,tmp,sizeof(tmp));&#125;ll mtrqkpow(int p)&#123; ll f[105]; memset(f,0,sizeof(f)); f[K-1]=M; for(int i=K-2;i&gt;=1;i--)&#123; f[i]=(f[i+1]*M)%mod; &#125; while(p)&#123; if(p&amp;1)mul(f,A); mulslf(A); p&gt;&gt;=1; &#125; return f[1];&#125;int main()&#123; freopen(&quot;paint.in&quot;,&quot;r&quot;,stdin); freopen(&quot;paint.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); ll res1=qkpow(M,N);//总的可能性 for(int i=1;i&lt;=K-1;i++)&#123; A[i][1]=M-1; A[i][i+1]=1; &#125; printf(&quot;%lld&quot;,(((res1-mtrqkpow(N-K+1))%mod)+mod)%mod); fclose(stdin); fclose(stdout); return 0; &#125; AirlineDescription​ $Todobe$Farmer John正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到T个城镇 (1 &lt;= T &lt;= 25,000)，编号为1到T。这些城镇之间通过R条道路 (1 &lt;= R &lt;= 50,000，编号为1到R) 和P条航线 (1 &lt;= P &lt;= 50,000，编号为1到P) 连接。每条道路i或者航线i连接城镇$A_i$ (1 &lt;= $A_i$ &lt;= T)到$B_i$ (1 &lt;= $B_i$ &lt;= T)，花费为$C_i$。对于道路，0 &lt;= $C_i$ &lt;= 10,000；然而航线的花费很神奇，花费$C_i$可能是负数(-10,000 &lt;= $C_i$ &lt;= 10,000)。道路是双向的，可以从$A_i$到$B_i$，也可以从$B_i$到$A_i$，花费都是$C_i$。然而航线与之不同，只可以从$A_i$到$B_i$。事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从$A_i$到$B_i$，那么保证不可能通过一些道路和航线从$B_i$回到$A_i$。由于$FJ$的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇S(1 &lt;= S &lt;= T) 把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。 Input第1行：四个空格隔开的整数: T, R, P, and S ,第2到R+1行：三个空格隔开的整数（表示一条道路）：$A_i$, $B_i$ 和 $C_i$, 第R+2到R+P+1行：三个空格隔开的整数（表示一条航线）：$A_i$,$ B_i$ 和$ C_i$ Output第1到T行：从S到达城镇i的最小花费，如果不存在输出”NO PATH” Analysis题目分析你以为这是一道$SPFA$水题？至少我当时是这么以为的，但是这一道题要卡你的$SPFA$所以说直接来就会爆，因此必须要想办法来优化 SLF优化这一个$SLF$优化说起来并不难，它将原来的队列转换成为了双端队列，对于加入的点$v$，如果说$dist[v]&lt;=dist[Q.top()]$,那么就把这个点放在队列的顶部，反之则将这个点放在最后面 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define maxn 25005#define maxe 50005 #define Int64 long long#define max(x,y) (x&gt;y)?x:y#define min(x,y) (x&lt;y)?x:yusing namespace std;int head[maxn],to[maxe&lt;&lt;2],nxt[maxe&lt;&lt;2],wel[maxe&lt;&lt;2],tot=0;;Int64 dis[maxn];int N,R,P,S;bool vis[maxn];int dfn[maxn],low[maxn],dfst=0,stk[maxn],top=0;int block[maxn],cnt=0;template&lt;typename t&gt;inline void read(t &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;inline void add(int x,int y,int z)&#123; to[++tot]=y; nxt[tot]=head[x]; head[x]=tot; wel[tot]=z;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++dfst; stk[++top]=u; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!block[v])&#123; low[u]=min(dfn[v],low[u]); &#125; &#125; if(low[u]==dfn[u])&#123; block[u]=++cnt; while(stk[top]!=u)&#123; block[stk[top]]=cnt; top--; &#125; top--; &#125;&#125;void SPFA(int R,int w)&#123; deque&lt;int&gt;D; dis[R]=w; vis[R]=true; D.push_front(R); while(!D.empty())&#123; int u=D.front();D.pop_front(); vis[u]=false; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i],w=wel[i]; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; if(!vis[v])&#123; if(D.size()&amp;&amp;dis[v]&lt;=dis[D.front()])D.push_front(v); else D.push_back(v); vis[v]=true; &#125; &#125; &#125; &#125; &#125; int main()&#123;#ifndef ONLINE_JUDGE freopen(&quot;airline.in&quot;,&quot;r&quot;,stdin); freopen(&quot;airline.out&quot;,&quot;w&quot;,stdout);#endif read(N);read(R);read(P);read(S); for(int i=1;i&lt;=R;i++)&#123; int x,y,z;read(x);read(y);read(z); add(x,y,z);add(y,x,z); &#125; for(int i=1;i&lt;=P;i++)&#123; int x,y,z;read(x);read(y);read(z); add(x,y,z); &#125; tarjan(S); memset(dis,0x3f,sizeof(dis)); SPFA(S,0); for(int i=1;i&lt;=N;i++)&#123; if(dis[i]==0x3f3f3f3f3f3f3f3fl)printf(&quot;NO PATH\\n&quot;); else printf(&quot;%lld\\n&quot;,dis[i]); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SPFA","slug":"SPFA","permalink":"http://example.com/tags/SPFA/"},{"name":"SLF优化","slug":"SLF优化","permalink":"http://example.com/tags/SLF%E4%BC%98%E5%8C%96/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"20190820test","slug":"20190820test","date":"2021-09-05T02:20:22.627Z","updated":"2021-09-05T02:20:23.421Z","comments":true,"path":"2021/09/05/20190820test/","link":"","permalink":"http://example.com/2021/09/05/20190820test/","excerpt":"","text":"AgentDesciption IMF(不可能任务小组)有N个Agent，每个Agent的能力值互不相同，现在部长先生想要派出A,B两队Agent去参加特别任务。但是参加大战的两个队伍要满足两个要求： 1. A队中能力最大的Agent的能力值要小于B队能力最弱的Agent的能力值。 2. A,B两队都要有人参加。 并不是所有的Agent都要去参加的，心急的部长先生想知道有多少种安排Agent的方案。由于答案可能很大，所以只需要你求出答案模的值就可以了。 Input输入仅一行，为一个整数N。 Output输出答案模的值。 Analysis这一道题花了一点时间来推，就从$N==6$的情况来讨论一下： $1.$当$A$组当中只有$1$个的时候一共有: $31+15+7+3+1$种方法，这些都是$2^n-1$,没有什么问题，因为依次取$1,2,3…$你能够选的方案就是这么多，没有什么毛病（就是一个子集的问题，不过排除不选的方案） $2.$当$A$组当中只有$2$个的时候一共有：$15+7+3+1$种方法吗？不是的，这个时候因为当你选定$A$组最大的那一个的时候，剩余的小的那一个是还有选择的余地的，所以这里并不是这么多，而是要根据排列组合看一看。 $3.$到了这里的时候，差不多就可以看出规律来了，你会发现，这些$2^n-1$的系数，也是$2^x$,没错，这是因为你这样来看的时候，系数都是组合数，加起来就是$2^x$次方了 $4.$化简可以得到式子：$$2^0*(2^{n-1}-1)+2^1*(2^{n-2}-1)+……+2^{n-2}(2^1-1)\\\\=2^{n-1}(N-1)-2^{n-1}+1$$因此代码就呼之欲出了： 12345678910111213141516171819202122232425262728293031//好像找到规律了,但是找到了也一点都不好写 #include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll mod=1e9+7;ll N;inline ll qkpow(ll b,ll p)&#123; ll res=1; while(p)&#123; if(p&amp;1)res=res*b%mod; b*=b; b%=mod; p=p/2; &#125; return res;&#125;int main()&#123; //freopen(&quot;agent.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;agent.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%lld&quot;,&amp;N); ll idx=qkpow(2,N-1); ll res=(idx*(N-1))%mod; res=res-idx+1; printf(&quot;%lld&quot;,(res+mod)%mod); //fclose(stdin); //fclose(stdout); return 0; &#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://example.com/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"20190920周记","slug":"20190920","date":"2021-09-05T02:20:22.350Z","updated":"2021-09-16T03:59:33.583Z","comments":true,"path":"2021/09/05/20190920/","link":"","permalink":"http://example.com/2021/09/05/20190920/","excerpt":"","text":"Summary​ 我也不知道应该说一些什么，感觉就是很普通的一周。上周父亲带着我去买了一块表，感觉还不错。这周每天晚上都是延长了晚自习，一直到十点半的时候才从学校回来。这么一周下来感觉还是有一些累，回来锻炼，洗漱之后都是已经很晚了，然后早上再起来也是感觉有一些疲倦。至于各个学科，数学到时还不错,题目坐下来到时勉强算得上是顺手，物理化学也是还好。至于地理，感觉有的时候看到五三这些还是觉得不明所以，唉。 ​ 英语倒是感觉背单词的效率不是很高，没有找出足够多的时间来背，感觉一周七个$list$好像是成为了空谈。不过我还是在尽力，语文课，听33说话倒还是有一些意思。 ​ 自己闲暇的时光尝试去看了看$python$，感觉基本的操作倒也是不难，甚至尝试用$python$ AC了两道题目。虽然说$python$功能真的是很强大，但是确实是慢了一些，$C++$15 ms就可以A掉的题目，$python$要67 ms。 ​ 好简短的总结啊，唉，不想说了","categories":[{"name":"周记","slug":"周记","permalink":"http://example.com/categories/%E5%91%A8%E8%AE%B0/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"20191022考试总结","slug":"20191022考试总结","date":"2021-09-05T02:20:22.253Z","updated":"2021-09-05T02:20:22.597Z","comments":true,"path":"2021/09/05/20191022考试总结/","link":"","permalink":"http://example.com/2021/09/05/20191022%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"XorarrayDescription xor——异或，和 and 与or 一样，是一种重要的逻辑运算，他的运算规律是 0 xor 0 = 0，1 xor 1 = 0，1 xor 0 = 1，0 xor 1 = 1 两个整数之间的异或是将两个整数转化成二进制，对他们的每一位分别进行 xor 操作，例：6(110) xor 13(1101) = 11(1011) 现在我们要介绍一种新的操作——数组异或，将两个相同大小（假设都为n）的数组A、B异或成一个新数组C，则新数组必满足:$$C[k]=\\sum_i^{k}\\sum_j^{k}\\ A[i]\\bigoplus B[i]$$ 现在给你数组大小n，和两个数组A,B 求他们的异或数组C 由于最终答案可能过大，你需要对C的每个元素对$1e9+7$取模 Input 一共3行。 第一行一个正整数N。 接下来两行每行N个正整数，表示数组A、B。 Output 一共1行，N个正整数，表示数组C。 Analysis我，我mod少打了一个0，直接就爆0了,$qwq$,太惨了。 这一道题目的核心在于，因为对于每一个$C[k]$的值，考虑将所有的$A[i]$,$B[i]$中每一位中的0的个数,1的个数计算出来，每一位A的0的个数和B的1的个数，B的0的个数和A的1的个数相乘，然后加起来，这样就可以得到这一位上面异或所产生的总的1的个数是多少，而这里面的1是二进制下面的，因此需要还原回去乘以对应的幂次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int maxn=100005;const LL mod=1000000007;LL A[maxn],B[maxn],C[maxn],N;LL cntA[40][2],cntB[40][2]; template&lt;typename t&gt;inline void read(t &amp;x);void solve(); int main()&#123; freopen(&quot;xorarray.in&quot;,&quot;r&quot;,stdin); freopen(&quot;xorarray.out&quot;,&quot;w&quot;,stdout); read(N); solve(); fclose(stdin); fclose(stdout); return 0;&#125;template&lt;typename t&gt;inline void read(t &amp;x)&#123; x=0;int sign=1;char c=getchar(); while(c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;)&#123;if(c==&#x27;-&#x27;)sign=-1;c=getchar();&#125; while(c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;)&#123;x=x*10+c-48;c=getchar();&#125; x*=sign;&#125;void solve()&#123; for(int i=1;i&lt;=N;i++)read(A[i]); for(int i=1;i&lt;=N;i++)read(B[i]); for(int i=1;i&lt;=N;i++)&#123; LL now; for(int j=0;j&lt;=31;j++)&#123; cntA[j][(A[i]&gt;&gt;j)&amp;1]++; cntB[j][(B[i]&gt;&gt;j)&amp;1]++; now=(cntA[j][0]*cntB[j][1]+cntB[j][0]*cntA[j][1])%mod; (now&lt;&lt;=j)%=mod; (C[i]+=now)%=mod; &#125; cout&lt;&lt;C[i]&lt;&lt;&quot; &quot;; &#125;&#125; RoadDescription 给出一个 N 个点的有向图，每个点的出度恰好为一。 现在希望给这 N 条边重定向，求图中不出现环的方案数（对$1e9$+7取模）。 Input 第一行一个正整数 N。 第二行 N 个正整数 $X_i$，表示存在一条有向边 i 指向 $X_i$。 Output 一行，一个整数 Ans，表示定向后不出现环的方案数。 Analysis这一道题目，思路其实很简单，首先这个原图里面肯定是存在环的，如果说要让这个环不再是环的话，那么只需要让环里面任意条边反向就可以了，但是不可以全部反向或不反向。考虑强连通分量缩点来得到每一个环的点的个数是多少(以下记作size) 若是缩点之后，$size&gt;1$,那么让这里面的边反过来的方案数就有$$\\C_{size}^1+\\C_{size}^2+……+\\C_{size}^{size-2}+\\C_{size}^{size-1}$$ 根据所学过的排列组合的知识，可以化简为$2^{size}-2$ 若是缩点之后，$size=1$,那么这一条边反不反向都是可以的，直接乘个2就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define maxn 100005const int mod=(int)1e9+7;int N,tot=0,dfst=0,CntBlocks=0;int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];int low[maxn],dfn[maxn],Belong[maxn];int stk[maxn],Blocksize[maxn];void add(int x,int y)&#123;to[++tot]=y,nxt[tot]=head[x],head[x]=tot;&#125;void tarjan(int u); LL qkpow(LL p); int main()&#123; freopen(&quot;road.in&quot;,&quot;r&quot;,stdin); freopen(&quot;road.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;N);int t; for(int i=1;i&lt;=N;i++)scanf(&quot;%d&quot;,&amp;t),add(i,t); for(int i=1;i&lt;=N;i++)if(!dfn[i])tarjan(i); LL ans=1; for(int i=1;i&lt;=CntBlocks;i++)&#123; if(Blocksize[i]==1)&#123; (ans*=2)%=mod; &#125; else&#123; LL t=qkpow(Blocksize[i]); ans=(ans*t)%mod; &#125; &#125; cout&lt;&lt;ans; fclose(stdin); fclose(stdout); return 0;&#125;void tarjan(int u)&#123; stk[++stk[0]]=u; low[u]=dfn[u]=++dfst; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(!Belong[v]) low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u])&#123; CntBlocks++; while(stk[stk[0]]!=u)&#123; Belong[stk[stk[0]]]=CntBlocks; Blocksize[CntBlocks]++; stk[0]--; &#125; Belong[u]=CntBlocks; Blocksize[CntBlocks]++; stk[0]--; &#125;&#125;LL qkpow(LL p)&#123; LL res=1; LL now=2; while(p)&#123; if(p&amp;1)res=(res*now)%mod; (now*=now)%=mod; p&gt;&gt;=1; &#125; return res-2;&#125; DetectiveDescription 小W最近沉迷一个侦探游戏，在这个游戏中会不断出现命案，而小W作为主角，需要不断地收集各种关键证据，只有当所有的关键证据都被找到，你才能驳倒所有人错误的判断，找出真正的凶手。 一共有N个关键证据以及M条信息，每条信息如下所示 : 如果你已经掌握了证据 i ，那么你可以通过 k 个时间的搜索和推理得到证据 j ，同样的，如果你掌握了证据 j 你也可以通过 k 个时间得到证据 j 。 游戏开始时玩家通过初步观察现场已经得到了证据1，于此同时，每个玩家在游戏开始阶段时都能获得一个特殊技能来加快游戏进度，增加趣味性。小 W 选了一个他以前从来没用过的技能 : 好运。这是一个被动技能，系统会在游戏开始时选定一对证据（a，b）当小W发现其中一个证据的时候，他会很好运地立即获得另外一个证据（不计入时间）。 但是这个技能是完全随机的，小W完全不知道进入游戏后系统会挑选哪一对证据，他希望你能帮助他算出他花在本轮游戏上的时间的期望值，这样他心里能有点B数。 提供的信息保证 : i不会等于j，每个k值都互不相同，N个证据都能被得到。 Input 一共M+1行。 第一行两个正整数N,M，表示证据数量和信息数量。 接下来M行，每行三个数字i,j,k表示一个信息 Output 一共1行，1个整数（期望值是实数，但这里请直接保留0位小数输出） Analysis​ 如果说没有这个讨厌的被动技能的话，那么也就不会有这该死的期望了，那么也就是一个最小生成树就好了。 ​ 但这是不可能的，这辈子都不可能的。 ​ 首先来想一想，找到所有的证据之后，形成的那一张图，应当是一棵树，没有错吧，这一个神奇的被动技能，能都把其中一条边替换为0，这样的话通过枚举点对，我们就可以很轻松的得到错误的解法了 ​ 换一个思路，考虑在$Kruscal$制造这一棵树的时候来进行统计，每当我们选择一条边的时候，那么它所连接的两棵子树内所有的边，是不是都比它小，那么此时替换它为0的话，无疑就会使最划算的，也就是符合要求的。此时替换会减少的值为这一条边的权值乘以旁边的两棵子树的大小再来除以选择它的概率。那么答案就等于$$Ans=W-\\sum\\frac{2dsize(u)size(v)}{N(N-1)}$$其中W是最小生成树的值，d是选择的边的权值，size(u),size(v)是选择的时候两棵子树的大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 20005#define db doubleint N,M;int fa[maxn],size[maxn];struct edge&#123; int u; int v; int d; bool operator &lt;(const edge &amp;cmp)const&#123; return d&lt;cmp.d; &#125;&#125;E[maxn*5];void Kruscal();int Seek(int x);void Union(int x,int y); int main()&#123; freopen(&quot;detective.in&quot;,&quot;r&quot;,stdin); freopen(&quot;detective.out&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(false); cin&gt;&gt;N&gt;&gt;M; for(int i=1;i&lt;=M;i++)&#123; int u,v,d;cin&gt;&gt;u&gt;&gt;v&gt;&gt;d; E[i]=(edge)&#123;u,v,d&#125;; &#125; sort(E+1,E+1+M); Kruscal(); fclose(stdin); fclose(stdout); return 0;&#125; int Seek(int x)&#123; if(x!=fa[x])return fa[x]=Seek(fa[x]); return fa[x];&#125;void Union(int x,int y)&#123; fa[x]=y; size[y]=size[y]+size[x];&#125;void Kruscal()&#123; for(int i=1;i&lt;=N;i++)fa[i]=i,size[i]=1; int cnt=0; db off=0; long long ans=0; for(int i=1;i&lt;=M;i++)&#123; int u=E[i].u; int v=E[i].v; int d=E[i].d; int fu=Seek(u); int fv=Seek(v); if(fu!=fv)&#123; cnt++; ans+=d; off+=((2*(double)d*(double)size[fu]*(double)size[fv])/(double)(N*(N-1)+0.0)); Union(fu,fv); &#125; if(cnt==N-1)break; &#125; printf(&quot;%.2lf&quot;,ans-off);&#125;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"},{"name":"期望","slug":"期望","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%9B/"}]},{"title":"K-D tree入门","slug":"K-D tree","date":"2021-09-05T02:20:22.239Z","updated":"2021-09-05T02:20:22.644Z","comments":true,"path":"2021/09/05/K-D tree/","link":"","permalink":"http://example.com/2021/09/05/K-D%20tree/","excerpt":"","text":"KNN问题​ K-Nearest Neighbor，我也不知道应该说是问题还是算法，也就不要管这个了。我们想象这样一个场景，在一个平面直角坐标系上面，有很多很多个点。现在我们随机地选择一个点，想要知道离他最近的$k$个点是哪些，怎么办。如果使用肉眼观察的话，那么我们是可以大致判断出来有哪些的。可是在很多时候，我们拿到的并不是图像，而是数据，而这些数据要让计算机来处理，怎么办？？ ​ 对于这一个问题，我们可以用时间复杂度为$\\Theta(n^2)$的方法，处理出所有的距离，询问到处理的距离里面来看，但是我们还可以有别的方法。 K-D tree概念​ K-D tree 是一棵二叉查找树,它可以用来维护有多维信息的数据。因为在做题的时候，遇到的一般都是$2$维,所以说下面的例子我就以二维的来看了 建立解释​ 平常的二叉查找树，建立的时候，在每一个中间节点，会比较值的大小，比他小的就到他的左儿子那边，比他大的就到他的右儿子那边。但是K-D tree 有多维信息，这种情况下应该怎么办？既然他是有K维的信息，那么我们就任意选择其中以为来进行分割就可以了。这就好像是在平面中画了一条线一样，将它们分成了两个部分​ 比如下面的这一个，这是一个这个平面上有很多点，我们先选取其中一维进行分割，分成了两块，然后我们换一维继续分割 ​ 就这个样子交替分割下去就可以了，听着是不是就像切蛋糕一样？ ​ 那么怎么来进行分割呢，有下面两种方法： 根据深度，轮流来选择一个维度，依据这一个维度来进行划分。在划分的时候将区间内的值依照这一维的大小来进行排序，然后将中位数存下来，然后再递归的处理 我们计算一下每一维的方差，然后选择方差最大的那一维来进行划分。为什么要这样来进行划分，举个例子，如果说是一块方方正正的豆腐，那么不无论选择那一维来切，效果都是很好的。但是呢，如果说是一根细长木条呢？你轮流切未必就有一个好效果。选择计算每一维的方差，选择方差最大的那一维来的话，能够在构建树上起到很好的效果。 (假)代码首先，我们需要一个结构体 12345678struct K_D_Tree&#123; node d[maxn]; int lc[maxn]; int rc[maxn];#define D(i,j) d[i].databank[j]#define Minp(i,j) d[i].minpos[j]#define Maxp(i,j) d[i].maxpos[j]&#125; ​ 其中$node$是用来储存信息的结构体，然后来看看第一种方法如何来进行$build$ 1234567891011int build(int L,int R,int deps)&#123; if(L&gt;R)return 0; int mid=(L+R)&gt;&gt;1; keyd=deps%maxk; nth_element(point+L,point+mid,point+R+1); d[mid]=point[mid]; lc[mid]=build(L,mid-1,deps+1); rc[mid]=build(mid+1,R,deps+1); pushup(mid); return mid; &#125; ​ 这里$pushup$这个函数在接下来会讲，所以说先看着。nth_element 这一个函数第一个和第三个参量是左右区间，左闭右开，而中间的这一个则是你要排的值。像是上面代码中的那个例子，在point+mid这个位置，一定就是这个区间的中位数，前面都比它小，后面都比他大，但是前面后面未必就排好了序。 ​ 第二种方法（假代码） 1234567891011121314for(int i=0;i&lt;maxk;i++)&#123; double aver=var[i]=0.0; for(int j=L;j&lt;=R;j++) aver+=D(j,i); aver/=(R-L+1); for(int j=L;j&lt;=R;j++)&#123;&#125; var[i]+=((D(j,i)-aver)*(D(j,i)-aver)); &#125;//计算方差 dim[now]=0; for(int i=1;i&lt;k;i++)&#123; if(var[dim[now]]&lt;var[i])dim[now]=i; &#125; nth_element(……) //还要记录一下维度,然后和上面一样递归处理就可以了 查询K-D tree 的K近邻查询​ 我们之前提到了，要查询离某一个节点第$k$远（当然也可能是第$k$近）的节点的编号，或者是这一个距离。首先，这个第$k$远怎么办，怎么来记录，这个时候就可以想到优先队列了，每一次询问的时候，我们在优先队列里面先$push$ k个值进去，然后呢，查询的时候，遇到符合要求的数值，就把队首$pop$出来，然后再$push$进去，这样就可以保证我们总是维护好了第$k$远或者第$k$近了。 ​ 接下来来谈一谈如何查询，首先我们遍历到某一个节点，然后计算一下这一个节点和目标节点之间的距离，看看这一个距离是否符合要求，如果符合我们的要求，那么我们就更新一下，接着，以目标节点作为圆心，现在的答案的距离作为半径，然后做一个圆（三维的情况下是一个球，如果更多的话，那么就是超球体了）然后看看这一个圆有没有和我们遍历到的节点划分的左右平面(多维的话，按照网上的叫法就是超平面了)相交。如何判断？我们计算一下目标节点到左右平面的最小距离(注意，这里是在说第k近的情况)，如果说这个距离要比我们现在所说的这一个答案要小的话，那么就到这个平面里面去搜索，而如果是第k远的的情况下面，就是计算最远的距离是多少，然后再来判断了 ​ 可是现在还有一个问题，怎么来确定离左右平面的距离？这个时候就可以记录下每一个节点的子树下面，某一维最大最小的值是多少，建立的时候$pushup$一下，计算的时候就可以用了 123456789101112131415161718192021222324252627282930313233struct node&#123; double databank[2]; double minpos[2]; double maxpos[2]; bool operator &lt;(const node &amp;cmp)const&#123; return databank[keyd]&lt;cmp.databank[keyd]; &#125;&#125;point[maxn]; struct K_D_Tree&#123; node d[maxn]; int lc[maxn]; int rc[maxn];#define D(i,j) d[i].databank[j]#define Minp(i,j) d[i].minpos[j]#define Maxp(i,j) d[i].maxpos[j] inline void pushup(int now)&#123; if(lc[now])&#123; for(int i=0;i&lt;maxk;i++)&#123; Minp(now,i)=min(Minp(now,i),Minp(lc[now],i)); Maxp(now,i)=max(Maxp(now,i),Maxp(lc[now],i)); &#125; &#125; if(rc[now])&#123; for(int i=0;i&lt;maxk;i++)&#123; Minp(now,i)=min(Minp(now,i),Minp(rc[now],i)); Maxp(now,i)=max(Maxp(now,i),Maxp(rc[now],i)); &#125; &#125; &#125; &#125;; ​ 如果是计算最远的距离的话，那么每一维直接就是求距离的公式累加起来就可以了，最近的情况下面，则是如果处于最大最小区间以内，则是不用加，否则这一维取最小的来 ​ 用图片来表示的话，大概就是这样 上面的图就分别对应了第$k$近和第$k$远了 12345678inline double getrange(int p,int pos)&#123; double res=0; if(Minp(pos,0)&gt;D(p,0))res+=sqar(Minp(pos,0)-D(p,0)); if(Maxp(pos,0)&lt;D(p,0))res+=sqar(Maxp(pos,0)-D(p,0)); if(Minp(pos,1)&gt;D(p,1))res+=sqar(Minp(pos,1)-D(p,1)); if(Maxp(pos,1)&lt;D(p,1))res+=sqar(Minp(pos,1)-D(p,1)); return res;&#125;//第k近 123456inline ll disrange(node pos,int nowp)&#123; ll res=0; for(int i=0;i&lt;maxk;i++) res+=max(sqar(pos.databank[i]-Minp(nowp,i)),sqar(pos.databank[i]-Maxp(nowp,i))); return res;&#125; 数据类型不一样是因为不是从同一道题目上摘下来的，不要在意 那么这样一来，查询的代码就差不多可以写出来了 123456789101112131415161718192021222324void query(int L,int R,int p)&#123; if(L&gt;R)return; int mid=(L+R)&gt;&gt;1; if(mid!=p)&#123; ll res=0; for(int i=0;i&lt;maxk;i++) res+=sqar(D(mid,i)-D(p,i)); if(res&gt;que.top())&#123; que.pop(); que.push(res); &#125; &#125; ll disl=0,disr=0; disl=range(p,lc[mid]); disr=range(p,rc[mid]); if(disl&gt;disr)&#123; if(disl&gt;que.top())query(L,mid-1,p); if(disr&gt;que.top())query(mid+1,R,p); &#125; else&#123; if(disr&gt;que.top())query(mid+1,R,p); if(disl&gt;que.top())query(L,mid-1,p); &#125; &#125; 这里就只写贴一个查询第$k$远的了 K-D tree 的查询时间复杂度据说是 $\\Theta(\\sqrt N)$ 但是在某一些情况下面，它的时间复杂度还是会退化到接近$\\Theta(N)$来，比如说 所有的节点分布大致构成了一个圆，而你查询的节点差不多就是在圆心位置。 当然，设节点数为$K$,维度为$D$,只有当$K &gt;&gt; 2^D$的时候，K-D tree的效率才可以保证，当然，维数如果说高了的话，效率也是无法保证的。想K-D tree这样可以解决多维信息的树还有别的，比如说球树等等，我就不说了。因为我不会用。而如果想要解决更高维的信息，还想要保证效率的话，那么还有一种方法 BBF 算法​ 首先，我们需要另外一个优先队列。同时还需要一个对回溯次数限制的值，这个值是依据大量的结果取定的，我也不知道应该给你一个多少比较好。这个$BBF$算法的核心就在于决定一个优先级和最大回溯次数。这个优先级还是之前所说的距离来当。每一次查询到某一个节点的时候，还是计算出左右儿子和目标节点距离，然后进入其中一个查询，把另一个连同树上的位置和优先级一起放进优先队列里面来。然后查询一直到达叶子结点。如果队列不为空且没有到达最大回溯次数，那么就从队列里面拿出队首来进行查询。 插入，删除和重构插入这个时候，到达某一个节点，然后根据这个节点划分的维度，依次往下去，知道叶子节点为止，然后加上来就可以了 12345678910111213141516171819void insert(int now,node p,int deps)&#123; //插入操作，常规 keyd=deps%maxk; if(p.databank[keyd]&lt;=D(now,keyd))&#123; if(lc[now]==0)&#123; lc[now]=++tot; d[tot]=p; &#125; else insert(lc[now],p,deps+1); &#125; else&#123; if(rc[now]==0)&#123; rc[now]=++tot; d[tot]=p; &#125; else insert(rc[now],p,deps+1); &#125; pushup(now);&#125; 差不多，就这样吧…… 删除K-D tree的删除操作，对于没有后继节点的节点，那么就直接删除了就好，但是如果说有后继节点的话，你就从它的左子树中，找出这一维最小的那一个值，或者是右子树中找出最大的那一个值，然后再把把那一个值从原来的树中删除了……这是一个递归实现的过程。 重构当插入删除操作进行了一定次数以后，重新用一次$build$就好了。当然也可以类似替罪羊树那样，选择一个规定的$\\alpha$，如果说不符合要求再使用一次$build$,不过我觉得还是一种方法更好 参考oi-wiki KD树（网易游戏笔试） Kd-Tree算法原理和开源实现代码 K-D tree 数据结构","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"K-D tree","slug":"K-D-tree","permalink":"http://example.com/tags/K-D-tree/"}]},{"title":"LuoguP1005","slug":"LG1005","date":"2021-09-05T02:20:22.189Z","updated":"2021-09-05T02:20:22.756Z","comments":true,"path":"2021/09/05/LG1005/","link":"","permalink":"http://example.com/2021/09/05/LG1005/","excerpt":"","text":"LG1005十年以前，提高组的题目居然要写高精度！！！！ 这不是摆明了刁难人吗！！！！！！！ Analysis你需要写的高精度： 高精度加法 高精度比较大小 高精度乘高精度 高精度乘低精度 高精度赋初值 虽然这一道题目是一道$dp$，但是高精度完全抢走了所有的风头 关于着一道题目的$dp$，首先，就是在于每一行都是独立的，互相影响，所以说每一行单独来$dp$就可以了。 我们设$f[i][j]$来表示$[i,j]$区间里面的最优情况，他可能是是从$[i+1,j]$和$[i,j-1]$两种情况推过来的，所以说因此就可以得出他的方程了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define maxn 85#define carry 1000using namespace std;int N,M;int matrix[maxn][maxn];struct Largenum&#123; int val[maxn]; int operator [](const int &amp;ref)const&#123; return val[ref]; &#125; Largenum(int a)&#123; memset(val,0,sizeof(val)); int pos=1; while(a)&#123; val[pos]=a%carry; a/=carry; pos++; &#125; val[0]=pos; &#125; Largenum(void)&#123; memset(val,0,sizeof(val)); &#125; inline void output()&#123; printf(&quot;%d&quot;,val[val[0]]); for(int i=val[0]-1;i&gt;=1;i--) printf(&quot;%03d&quot;,val[i]); //大家都懂的，我这里是每一位存了一个三位数 &#125; Largenum operator +(const Largenum &amp;obj)const&#123; Largenum cmp; int add=0,pos=max(val[0],obj.val[0]); for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=obj.val[i]+val[i]+add; add=cmp.val[i]/carry; cmp.val[i]%=carry; &#125; if(add&gt;0)cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; bool operator ==(const Largenum &amp;obj)const&#123; if(val[0]!=obj[0])return false; for(int i=1;i&lt;=val[0];i++)if(val[i]!=obj[i])return false; return true; &#125; bool operator &lt;(const Largenum &amp;obj)const&#123; if(val[0]&gt;obj[0])return false; if((*this)==obj)return false; if(val[0]&lt;obj[0])return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i])return false; if(val[i]&lt;obj[i])return true; &#125; return true; &#125; //这个是状态转移比较大小用的 Largenum operator *(const Largenum &amp;obj)const&#123; Largenum cmp; int pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/carry; cmp.val[i+j-1]=cmp.val[i+j-1]%carry; &#125; &#125; while(cmp.val[pos]==0&amp;&amp;pos&gt;1)pos--; cmp.val[0]=pos; return cmp; &#125; Largenum operator *(const int &amp;obj)const&#123; Largenum cmp; int pos=val[0];int add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/carry; cmp.val[i]=cmp.val[i]%carry; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%carry; add/=carry; &#125; while(cmp.val[pos]==0&amp;&amp;pos&gt;1)pos--; cmp.val[0]=pos; return cmp; &#125;&#125;two[maxn],f[maxn][maxn],ans(0);void init(int M)&#123; two[0]=Largenum(1); for(int i=1;i&lt;=M;i++) two[i]=two[i-1]*2;//预处理一下 &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++) scanf(&quot;%d&quot;,&amp;matrix[i][j]); //f[i][j]表示选择[i,j]区间时的最大值，它从f[i+1][j]和f[i][j+1]这两步枚举过来 init(M); for(int k=1;k&lt;=N;k++)&#123; memset(f,0,sizeof(f)); for(int t=0;t&lt;M;t++)&#123; for(int i=1;i+t&lt;=M;++i)&#123; int j=i+t; int pw=M-t; //因为f[i][j]的定义，所以说这里是从短到长的来推的 //短的时候呢，乘的那一个数也要大一点 Largenum fir=(f[i+1][j]+two[pw]*matrix[k][i]); Largenum sec=(f[i][j-1]+two[pw]*matrix[k][j]); if(fir&lt;sec)f[i][j]=sec; else f[i][j]=fir; &#125; ans=ans+f[1][M]; &#125; &#125; ans.output(); return 0;&#125;","categories":[{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"区间dp","slug":"区间dp","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4dp/"}]},{"title":"LuoguP1373","slug":"LGP1373","date":"2021-09-05T02:20:21.881Z","updated":"2021-09-05T02:20:22.324Z","comments":true,"path":"2021/09/05/LGP1373/","link":"","permalink":"http://example.com/2021/09/05/LGP1373/","excerpt":"","text":"LGP1373Analysis这一道题目，首先，因为是交替进行，所以要有一维来表示是两个人中的哪一个，其次，这是一个矩阵，还要有矩阵的位置，最后，因为只有双方的魔液数量相同的时候才可以活下来，所以说应该还有一维来记录双方魔液的差值。对于状态转移方程，先做出如下约定： 1-&gt;小A, 0-&gt;uim 差值为：小A的魔液减去uim的魔液 对于小A:$$f[i][j][k][1]+=f[i-1][j][(k-mat[i][j]+md)\\mod md][0]\\\\f[i][j][k][1]+=f[i][j-1][(k-mat[i][j]+md)\\mod md][0]$$对于uim:$$f[i][j][k][0]+=f[i-1][j][(k+mat[i][j])\\mod md][1]\\\\f[i][j][k][0]+=f[i][j-1][(k+mat[i][j])\\mod md][1]$$ 对于差值，如果说这一步是小A拿到魔液的话，那么双方的差值就应该增大，所以说这一步应该是从减去这么多魔液的地方转移过来的，同样如果说是uim拿到了魔液的话，双方的差值就会减少，所以说因该就是从增加了这么多魔液的地方转移过来的 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define mod 1000000007#define maxn 802using namespace std;int mat[maxn][maxn];int f[maxn][maxn][18][2];int N,M,K;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=M;j++)&#123; scanf(&quot;%d&quot;,&amp;mat[i][j]); mat[i][j]%=(K+1); f[i][j][mat[i][j]][1]=1; &#125; const int md=K+1; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=M;j++)&#123; for(int del=0;del&lt;=K;del++)&#123; (f[i][j][del][1]+=f[i-1][j][(del-mat[i][j]+md)%md][0])%=mod; (f[i][j][del][1]+=f[i][j-1][(del-mat[i][j]+md)%md][0])%=mod; (f[i][j][del][0]+=f[i-1][j][(del+mat[i][j])%md][1])%=mod; (f[i][j][del][0]+=f[i][j-1][(del+mat[i][j])%md][1])%=mod; &#125; &#125; &#125; long long ans=0; for(int i=1;i&lt;=N;i++)&#123; for(int j=1;j&lt;=M;j++)&#123; (ans+=f[i][j][0][0])%=mod; &#125; &#125; cout&lt;&lt;ans; return 0; &#125;","categories":[{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"}]},{"title":"LuoguP4377","slug":"LGP4377","date":"2021-09-05T02:20:21.841Z","updated":"2021-09-05T02:20:22.223Z","comments":true,"path":"2021/09/05/LGP4377/","link":"","permalink":"http://example.com/2021/09/05/LGP4377/","excerpt":"","text":"LGP4377Analysis今天考试，$Mr.Yu$疯狂暗示，难道不是递增的哦 所以说我一来就开始看第三题，显示贪心错了大样例，然后就决定$dp$了，想不到居然对了，开心。 后面到网上来看题解，全部都是0/1分数规划，我震惊了，嗯，想不到啊。 这里来谈一谈我的做法，设$f[i]$表示才艺之的总之为$i$的时候最小的重量是多少，之所以要这么来设计是因为才艺值是固定的，重量值越小的时候，才艺值就越大，然后每一头奶牛只能够选一次，那么不就是一个0/1背包的模板题，最后来扫一遍得到答案吗 Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445/* *学学背包问题： *f[i]表示总才艺值为i时，最小的重量是多少 *f[i]=min(f[i],f[i-t[i]]+w[i]); */ #include&lt;bits/stdc++.h&gt;#define maxn 255#define inf 1e-6using namespace std; struct cow&#123; int w;//重量 int t; &#125;fj[maxn];int f[maxn*1000];int N,W; int main()&#123; freopen(&quot;show.in&quot;,&quot;r&quot;,stdin); freopen(&quot;show.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;N,&amp;W); int maxt=0; for(register int i=1;i&lt;=N;i++)&#123; scanf(&quot;%d%d&quot;,&amp;fj[i].w,&amp;fj[i].t); maxt+=fj[i].t; &#125; memset(f,0x3f,sizeof(f)); //0x3f3f3f3f很大，f[i]里面的值并不会很大，所以说不会影响结果 f[0]=0; for(register int i=1;i&lt;=N;i++)&#123; for(register int j=maxt;j&gt;=fj[i].t;j--)&#123; f[j]=min(f[j],f[j-fj[i].t]+fj[i].w); &#125; &#125; double ans=0; for(register int i=1;i&lt;=maxt;i++)&#123; if(f[i]&gt;=W)ans=max(ans,i/(f[i]+0.0)); &#125; ans*=1000; printf(&quot;%d&quot;,(int)ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"Polya定理","slug":"Polya定理和母函数","date":"2021-09-05T02:20:21.823Z","updated":"2021-09-05T02:20:22.219Z","comments":true,"path":"2021/09/05/Polya定理和母函数/","link":"","permalink":"http://example.com/2021/09/05/Polya%E5%AE%9A%E7%90%86%E5%92%8C%E6%AF%8D%E5%87%BD%E6%95%B0/","excerpt":"","text":"群论今天学习了一点很厉害的知识，我简要记录一下，方便日后再来复习，不过并不是十分地详尽。在了解什么是$Polya$定理之前，先让我们来看一看什么是群。这个知识可以是为后面奠基的。 定义群是一个集合，它满足运算$*$，这个运算是经过定义的，可以是加法，可以是乘法，也可以是其它的运算法则。作为一个群，它具有以下的性质: 封闭性:$\\forall a,b\\in G,\\exists c\\in G,a*b=c$ 结合律: $\\forall a,b,c\\in G,(ab)c=a(bc)$ 单位元: $\\exists e\\in G,\\forall a\\in G,ae=ea=a$ 逆元: $\\forall a\\in G,\\exists b\\in G,ab=ba=e,b=a^{-1}$ 举个例子，所有的整数就可以算作是一个群，这里的运算就是加法，我们带进去看一看，会发现所有的性质是满足的。没错就这样 置换$N$个元素$1,2,3,\\cdots,N$之间的置换，然后把它换成$1,2,3,\\cdots,N$的一个全排列就对了，就是这么理解的，写作：$$\\begin{pmatrix}1&amp;2&amp;3&amp;\\cdots&amp;N\\\\a_1&amp;a_2&amp;a_3&amp;\\cdots&amp;a_n\\end{pmatrix}$$就是长成这个样子的了 置换群这是一个元素是置换的群，它的运算是置换的连接。这个东西听起来很玄对不对，对了，这个东西听起来就是很玄的，因为它本来就是这么的玄，下面我们看一个例子来理解一下，比如下面两个群我们来运算一下：$$\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\3&amp;1&amp;2&amp;4\\end{pmatrix}\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\4&amp;3&amp;2&amp;1\\end{pmatrix}=\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\3&amp;1&amp;2&amp;4\\end{pmatrix}\\begin{pmatrix}3&amp;1&amp;2&amp;4\\\\2&amp;4&amp;3&amp;1\\end{pmatrix}=\\begin{pmatrix}1&amp;2&amp;3&amp;4\\\\2&amp;4&amp;3&amp;1\\end{pmatrix}$$下面解释一下这个运算，首先，先把第二个置换换一换位置，这一下他的第一行顺序是不是就和第一个置换的第二行一样了？然后这个时候再来看，第一个置换里面，1置换成了3，到了第二个置换里面，3又是置换成了2，对不对？这就相当于是1置换成了2，其他的元素我们以此类推，就可以得到最后一个置换了。 而这一个置换群，也是满足四个性质的，为什么？我想封闭性是显然的吧，至于其他的？我怎么可能知道？我都是不知道的了，那么我还讲什么 一个神奇的式子和概念$$|Z_k|*|E_k|=|G|$$ 首先，这个并不是绝对值的意思，而是说这几个分别是有多少的个数，下面一一说明每一个的意义是什么 $|Z_k|$:设$G$是$1,2,3,\\cdots,N$的置换群，$k$是$1,2,3,\\cdots,N$中的某一个元素，$G$中使$k$不变的置换，记作$Z_k$ $|E_k|$:等价类。$k$在$G$作用下的轨迹，即$k$在$G$作用下，产生的所有元素集合 证明： 请自行百度，谷歌，或者必应。 Polya定理Burnside引理我们不妨假设$D(a_j)$是置换$a_j$下面不变的元素个数，那么就很容易就有一个式子$$\\sum_{i=1}^{n}|Z_j|=\\sum_{i=1}^{s}|D(a_i)|$$我们接着往下面推$$\\sum_{i=1}^{n}|Z_j|=\\sum_{i=1}^{s}|D(a_i)|\\\\=\\sum_{i=1}^{L}\\sum_{k\\in|E_i|}|Z_k|$$这里不难理解吧，我们假设一共有$L$个等价类，各个等价类加起来实际上和原来是一样多的，对吧,然后 $$=\\sum_{i=1}^{L}|E_i||Z_i|\\\\=\\sum_{i=1}^{L}|G|=L|G|\\\\L=\\frac{1}{|G|}\\sum_{i=1}^{n}|Z_i|=\\frac{1}{|G|}\\sum_{i=1}^{n}|D(a_i)|$$ 可是，虽然我们得到了这一个式子，但是啊，难道这一个$|Z_i|$,或者$D(a_j)$什么的，难道很好算吗？，一点都没有啊，所以说接下来还是得来看一看$Polya$定理 Polya定理循环这个真的就是一个很神奇的东西，简单的来说就是一种来表示置换的方法，来看看下面这一个例子$$\\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;5\\\\3&amp;5&amp;1&amp;4&amp;2\\end{pmatrix}=(13)(25)(4)$$这样的表示是唯一的，每一个置换都可以写成若干个互不相交的循环的乘积（我想这里肯定又是重新定义了一下），对于这些循环的个数就叫做循环节数（名字听起来和小学学的小数的循环节差不多，但是要难的多） Polya定理的表达式既然我们已经是知道了什么是循环，那么我们终于是可以写出这个该死的$Polya$定理的表达式了$$L=\\frac{1}{|G|}(m^{c(g1)}+m^{c(g2)}+\\cdots+m^{c(g_n)})$$其中$G$是${g_1.g_2,g_3\\cdots,g_n}$,$c(g_i)$表示置换$g_i$的循环节个数，这一个式子看起来很神奇对吧，实际上和上面的$Burnside$引理是差不多的，只是换了一种表达的方式，这是前人们通过观察证明得出来的结论，这意味着我并不知道如何从$Burnside$引理推到$Polya$定理。 Polya定理的运用下面让我们来看一道题目，这一道题目和方格子着色有关 对于一个2*2的矩阵，选择用黑白两种颜色来进行着色，如果说经过了旋转以后，得到的图形是相同的话，那么认为是同一种染色的方案。 因为数据很小，所以说可以通过枚举的方式得出所有的可能性： 我们可以看出，如果说是不重复的话，那么一共就有16种方案，但是如果说是要去除掉重复的方案的数量的话，那么就是一共有6种了。尽管说从目前的数据规模来看，这一道题目十分简单，但是如果说数据在扩大个几十倍甚至是上百倍的话，那么就十分不容易解决这一个问题了 因此这里我们就必须要用到刚才的知识来解决现在的问题了 设置换群$G={转0度，转90度，转180度，转270度}$ 来标号分别写出四个变化的置换。然后看看，在第一个置换下面，每一个都是不会变的，而对于第二个和第四个置换，第一种和第二种图都是不会变的，对于第三个置换，则是增加了两个对角线填色的图，因此就可以直接代入到式子当中直接得到答案了。 好了，心里面大概也算的上是有一点谱了，差不多就是这么多内容了。（实际上还有一个母函数的内容，但是我自己并不是很懂。）","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"群论","slug":"群论","permalink":"http://example.com/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"Polya定理","slug":"Polya定理","permalink":"http://example.com/tags/Polya%E5%AE%9A%E7%90%86/"}]},{"title":"博弈论入门","slug":"博弈论入门","date":"2021-09-05T02:20:21.804Z","updated":"2021-09-05T02:20:22.158Z","comments":true,"path":"2021/09/05/博弈论入门/","link":"","permalink":"http://example.com/2021/09/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%85%A5%E9%97%A8/","excerpt":"","text":"博弈论（Game Theory）首先先说两个定义N状态:前面的一个玩家必胜P状态: 后面一个玩家必胜 巴什博弈 （Bush Game）有一堆数量为n的物体，轮流拿，至少拿1个，至多拿k个(N&gt;K);如果n%（k+1）==0，那么先手必败。这一切是显而易见，毫无疑问的 一道例题Tang and Jiang are good friends. To decide whose treat it is for dinner, they are playing a game. Specifically, Tang and Jiang will alternatively write numbers (integers) on a white board. Tang writes first, then Jiang, then again Tang, etc… Moreover, assuming that the number written in the previous round is X, the next person who plays should write a number Y such that 1 &lt;= Y - X &lt;= k. The person who writes a number no smaller than N first will lose the game. Note that in the first round, Tang can write a number only within range [1, k] (both inclusive). You can assume that Tang and Jiang will always be playing optimally, as they are both very smart students. 这一道题目大意上和Bush Game 差不多，但是不同的是它里面说的是写不出不小于n的就输了，那么必胜的时候就是你已经写出了n-1的时候。所以此时如果(n-1)%(k+1)==0那么先手必定输，否则就是后手输，因为先手那一次后可已转换为第一种情况 尼姆博弈 （Nim Game）有n堆物体，每一堆的数量为a[i]个，每一次一个人任选一堆取出任意个（不能为0）设k为每一堆异或的结果，如果k==0，那么先手必定失败，否则先手必定胜利。这样来想，把每一堆的数量转换成二进制然后竖着来最低位对齐。如果说k==0,那么这意味这每一个列的1的个数一定会是偶数个。而第一个人取走了一些以后呢，这意味着一定一些列的1的个数为变成奇数个，那么k一定就不再等于0了。而此时后手的人只要把异或的值修正为0就可以了。因为k不等于0了，那么这就说明k的最高位一定会是1，而这个最高位的1一定会是a[i]中的对应位上的1提供的。而根据异或的性质，k和a[i]异或结果为其他的异或结果。我们可以在a[i]中减去一些值，是a[i]最终等于k和a[i]异或的结果，又因为k最高位的1是由a[i]提供的，那么那里一定会变成0，就一定会比a[i]小，而只要把这里减掉，k就又会等于0了 SG函数公平组合游戏1.双方交替来进行；2.游戏进行的任意时刻，可以执行的合法行动与哪一个玩家执行无关；3.当玩家无法行动的时候，就判负 mex运算$$mex(S)=min{x|x\\in N,x\\notin S}$$ SG函数对于任意状态下的x$$SG(x)=mex{SG(y)|y是x的后继状态}$$对于终止状态，SG值为0。 如果某一状态后继SG有0，则当前状态为N如果当前状态所有后继SG不为0，则当前为P; 好的，既然已经知道了SG函数是什么，那么就有一道题了。 移棋子游戏 Description 给定一个有N个节点的DAG图，图上某些节点上面有棋子。两名玩家交替移动棋子，玩家每一次可以将任意一颗棋子沿着有向边移动到下一个节点，当无法移动的时候，就输掉了游戏，假设双方都足够聪明，问先手必胜还是后手必胜。 Input 第一行三个整数N,M,K,表示N个节点M条边K个棋子。接下来M行，每行两个整数x,y,代表x节点到y节点的有向边再接下来K行，表示K个棋子所在的节点编号。 output 先手胜输出”win”,否则输出”lose” Sample Input 123456789106 8 42 12 41 41 54 51 33 53 61 2 4 6 Sample Output 1win 这应该是我第一次这么抄题吧。DAG图，看到这个应该回想起拓扑排序，其次，因为没有后继的点$SG$值为0，而每一个点的$SG$值又是有它的后继决定的。如果它的后继没有弄完，那么就不可以算。这很像拓扑排序把入度为0的点push进队列。因此不难想到这一题可以用类似于拓扑排序的方法来做。我们需要存两个图，正向的和反向的。正向的图用来寻找这一个点的后继获取这一个点的$SG$值，反向的用来找祖宗，修改祖宗的出度，并把出度为0的祖宗push进入队列因为有拓扑排序的基础，所以这一道题可以比较容易的做出来了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define maxn 2003using namespace std;queue&lt;int&gt;Q;vector&lt;int&gt;G[maxn];//正着存图vector&lt;int&gt;G_[maxn];//反着存图int chess[maxn],SG[maxn];//记录棋子的位置 ,SG函数值 bool vis[maxn*3];int n,m,outdgr[maxn];//记录点，边，出度 int k; void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; if(!outdgr[i])&#123; Q.push(i); &#125; &#125; while(!Q.empty())&#123; memset(vis,0,sizeof(vis)); int u=Q.front();Q.pop(); vector&lt;int&gt;::iterator iter=G[u].begin(); int maxsg=0; while(iter!=G[u].end())&#123; maxsg=max(maxsg,SG[*iter]); vis[SG[*iter]]=true; iter++; &#125; int j; for(j=0;j&lt;=maxsg+1;j++)if(!vis[j])break; SG[u]=j;//得到这一个点的SG值 vector&lt;int&gt;::iterator iter_=G_[u].begin(); while(iter_!=G_[u].end())&#123; outdgr[*iter_]--; if(!outdgr[*iter_])Q.push(*iter_); iter_++; &#125; &#125; int ans=SG[chess[1]]; for(int i=2;i&lt;=k;i++)ans^=SG[chess[i]]; if(!ans)printf(&quot;lose\\n&quot;); else printf(&quot;win\\n&quot;); return ; &#125;int main()&#123; memset(outdgr,0,sizeof(outdgr)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[u].push_back(v); G_[v].push_back(u); outdgr[u]++; &#125; for(int i=1;i&lt;=k;i++)&#123; scanf(&quot;%d&quot;,&amp;chess[i]); &#125; solve(); return 0;&#125; 那么，That’s all.","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"博弈论","slug":"博弈论","permalink":"http://example.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"SG函数","slug":"SG函数","permalink":"http://example.com/tags/SG%E5%87%BD%E6%95%B0/"}]},{"title":"dp review (1)","slug":"递推复习 (1)","date":"2021-09-05T02:20:21.442Z","updated":"2021-09-05T02:20:21.791Z","comments":true,"path":"2021/09/05/递推复习 (1)/","link":"","permalink":"http://example.com/2021/09/05/%E9%80%92%E6%8E%A8%E5%A4%8D%E4%B9%A0%20(1)/","excerpt":"","text":"实际上我只是贴我做的题而已不仅如此，我还是一两道题就给一篇博客 骨牌问题(yzoj1366)Description 有 2 行 N 列的长方形，可以用 N 个 1*2 的骨牌铺满，但可能有很多种不同的铺法。现在给出自然数n，请回答当长方形为 2 行 n 列时，有多少种不同的铺设方法。 Input 第一行一个整数t表示测试数据组数。下面的t行，每行一个整数n。 Output 每组数据输出一行一个整数，表示方案总数，这个数可能很大，所以只需输出模10007后的结果。 Sample Input Sample Output 3 2 5 7 2 8 21 难得换行了，但是实际上答案是要求换行的这一个比较的简单，可以看出来就是斐波那契数列所以直接打表法 Code 1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define maxn 100003#define Mod 10007using namespace std;int f[maxn];int main()&#123; f[1]=1;f[2]=2; for(int i=3;i&lt;maxn;i++)f[i]=(f[i-1]+f[i-2])%Mod; int n; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; int t; cin&gt;&gt;t; cout&lt;&lt;f[t]&lt;&lt;endl; &#125; return 0;&#125; 爬楼梯(yzoj1367) Description 何老师爬楼梯，他可以每步上 1 、2或3 级，输入楼梯的级数，求不同的走法数。例如：楼梯一共有3级，他可以每步都走一级，或者第一步走一级，第二步走两级，也可以第一步走两级，第二步走一级，还有就是第一步就上3级，所以一共4种方法。 Input 第一行：N、K。 第二行：K个整数h[i]，表示坏了的楼梯的级数(1&lt;=h[i]&lt;=N)。 Output 不同的走法数，这个数字可能很巨大，所以输出最后答案mod 1234567 我懒得给样例了，说实话我不喜欢抄题 Analysis 这个的话把坏掉的楼梯直接变成方案数0就可以了，注意边界要特殊处理。方程的话经过推理事$$f[n]=f[n-1]+f[n-2]+f[n-3]$$ Code 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define Mod 1234567#define maxi 1007using namespace std;int f[maxi];bool is_broken[maxi];int main()&#123; memset(is_broken,0,sizeof(is_broken)); memset(f,0,sizeof(f)); int n,k; f[1]=1;f[2]=2;f[3]=4; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=k;i++)&#123; int x; scanf(&quot;%d&quot;,&amp;x); is_broken[x]=true; &#125; if(is_broken[1])&#123; f[1]=0;f[2]-=1;f[3]-=2; &#125; if(is_broken[2])&#123; f[2]=0; if(is_broken[1])&#123; f[3]-=1; &#125; else f[3]-=2; &#125; if(is_broken[3])&#123; f[3]=0; &#125; for(int i=4;i&lt;=n;i++)&#123; if(is_broken[i])f[i]=0; else f[i]=(f[i-1]+f[i-2]+f[i-3])%Mod; &#125; printf(&quot;%d&quot;,f[n]); return 0;&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://example.com/tags/%E9%80%92%E6%8E%A8/"}]},{"title":"二分图匹配","slug":"二分图","date":"2021-09-05T02:20:21.395Z","updated":"2021-09-05T02:20:21.758Z","comments":true,"path":"2021/09/05/二分图/","link":"","permalink":"http://example.com/2021/09/05/%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"二分图的匹配二分图的最大匹配增广路一条匹配边与非匹配边交替出现的路径叫做增广路 匹配边：两个点已经处于已选集合里面的边 非匹配边：这条边有个点不属于已经选过的集合里面的边 匈牙利算法在二分图里面交替找增广路的算法，然后把增广路取反直到不存在增广路为止 1234567891011121314151617181920bool dfs(int u)&#123; for(int i=head[u];i;i=nxt[i])&#123; int v=to[i]; if(!vis[v])&#123; vis[v]=1; if(!match[v]||dfs(match[v]))&#123; //这里对应着两种情况，一种是还没有匹配，另一种是可以腾出空间 match[v]=u; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int ans=0; for(int i=1;i&lt;=N;i++) //这个N是左边的端点 if(dfs[i])ans++;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"}]},{"title":"概率和期望入门","slug":"概率期望","date":"2021-09-05T02:20:21.380Z","updated":"2021-09-05T02:20:21.782Z","comments":true,"path":"2021/09/05/概率期望/","link":"","permalink":"http://example.com/2021/09/05/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/","excerpt":"","text":"概率与期望期望概率这一个词语在生活中实际上是经常会碰见的，所以说这里我就来说一说相对而言遇到的要少一些的期望。这个期望啊，可以理解为某些事件大量发生以后的平均的结果。这就好比一个六面的色子扔了很多很多次以后，色子平均值会趋近于3.5。这个原因啊，是显而易见，毫无疑问的，就不需要再多解释了。 例题好的，有一道例题可以看看洛谷P4316这一道题啊，读完了我就想到了拓扑排序，，同时用两个变长数组来存就可以了最开始我想用边集，可是我不知道怎么用边集来拓扑排序啊，于是ZhuFN大佬提醒我用两个变长数组。因此，我们只需要用两个变长数组，一个用来存点,一个用来存权值就OK了。而这一个拓扑排序的过程中，相对与普通的拓扑排序，增加上对于期望长度的累加就可以了这是因为期望具有可加性$probab(u)$来的那一个点的期望长度，w为这一条边的权值，$outdgr(v)$为有几条路进来，那么可以得到$$probab(v)=[probab(u)+w]/outdgr(v)$$我们这里可采用正着来或反着来（应该是吧），就像是$USACO$的数字金字塔一样吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;queue&lt;int&gt; Q; vector&lt;int&gt;G[maxn];vector&lt;int&gt;W[maxn];int n,tmp=0;int indgr[maxn];int outdgr[maxn];double probab[maxn];int m;void topsort()&#123; Q.push(n); while(!(Q.empty()))&#123; int u=Q.front(); Q.pop(); vector&lt;int&gt;::iterator iterG=G[u].begin(); vector&lt;int&gt;::iterator iterW=W[u].begin(); while(iterG!=G[u].end())&#123; int v=*iterG,w=*iterW; indgr[v]--; probab[v]+=(probab[u]+w)/(outdgr[v]); if(!indgr[v])&#123; Q.push(v); &#125; iterW++;iterG++; &#125; &#125;&#125;int main()&#123; memset(indgr,0,sizeof(indgr)); memset(outdgr,0,sizeof(outdgr)); memset(probab,0,sizeof(probab)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int a,b,c; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; indgr[a]++;outdgr[a]++; G[b].push_back(a); W[b].push_back(c); &#125; topsort(); printf(&quot;%.2lf&quot;,probab[1]); return 0;&#125; 这里再附上另外的大佬这道题的链接，我是看了dyx大佬代码以后才发现自己累加的地方做错了的对，没错，我最开始错了,而 ZhuFN则是用的dfs做的。dyxzfn那么就可以了","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"高精度压位","slug":"高精度压位","date":"2021-09-05T02:20:21.066Z","updated":"2021-09-05T02:20:21.847Z","comments":true,"path":"2021/09/05/高精度压位/","link":"","permalink":"http://example.com/2021/09/05/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8E%8B%E4%BD%8D/","excerpt":"","text":"压位的原因正常的高精度计算中，每一位只存了一位数字，可是当面对比较大的计算的时候呢，如果说每一位都只存一位数字，那么计算的时间就会比较地长。这个时候可以通过每一位高精度中存储多位数字的方法来降低运算的时间 例题引入简单的来说就是 一个高精度的开根号，只要求开到整数向下取整就可以了。数据范围是$10^{1000}$;首先就是开高精度根号的方法，很容易想到的方法就是二分或者是手动开根号。我这里使用的是二分的方法。这一道题最开始我是直接高精度来的,然后TLE了，接着我压了四位，还是TLE了，然后直接$10000000$一位了，终于A了。那么接下来我来一点点解析代码(实际上我只解析读入而已了) 12345678910111213141516inline void input()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); int j=0; for(int i=lenS-1;i&gt;=0;i-=7)&#123;//因为是10^8的进制，所以给7位 int t=max(i-6,0),res=0;//i-6~i一共七位， while(t&lt;=i)&#123; res=res*10+S[t]-&#x27;0&#x27;; t++; &#125; val[++j]=res; &#125; val[0]=j; &#125; 我的解析全写注释了，实际上总共我也只有两句解析，因为我在这两个地方没怎么注意，所以最开始我……至于这一个高精度的其他部分，那么就直接把10改成对应的大小就可以了，我这里是$10^8$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;#define Int64 long long#define carries 10000000#define maxn 1003using namespace std;struct largenum&#123; Int64 val[maxn]; Int64 operator [](const int &amp;ref)const&#123; return val[ref]; &#125; inline void input()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); int j=0; for(int i=lenS-1;i&gt;=0;i-=7)&#123; int t=max(i-6,0),res=0; while(t&lt;=i)&#123; res=res*10+S[t]-&#x27;0&#x27;; t++; &#125; val[++j]=res; &#125; val[0]=j; &#125; /*inline void StrIn(char *S)&#123; memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125;*/ inline void output()&#123; // 输出 printf(&quot;%ld&quot;,val[val[0]]); for(int i=val[0]-1;i&gt;=1;i--) printf(&quot;%07ld&quot;,val[i]); &#125; bool operator ==(const largenum &amp;obj)const&#123; // 判断是否等于 if(val[0]!=obj[0]) return false; for(int i=1;i&lt;=val[0];i++) if(val[i]!=obj[i]) return false; return true; &#125; bool operator &lt;(const largenum &amp;obj)const&#123; // 判断是否小于 if(val[0]&gt;obj[0]) return false; if((*this)==obj) return false; if(val[0]&lt;obj[0]) return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i]) return false; if(val[i]&lt;obj[i]) return true; &#125; return true; &#125; bool operator &gt;(const largenum &amp;obj)const&#123; // 判断是否大于 largenum cmp=*this; if(cmp &lt; obj || cmp == obj) return false; return true; &#125; largenum operator +(const largenum &amp;obj)const&#123; // 加法运算 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=max(val[0],obj.val[0]),add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]+obj[i]+add; add=cmp.val[i]/carries; cmp.val[i]=cmp.val[i]%carries; &#125; if(add&gt;0) cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; largenum operator -(const largenum &amp;obj)const&#123; // 减法运算 只能减出正数 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0],rent=0; // rent 借位 for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]-obj[i]-rent; if(cmp.val[i]&lt;0) &#123;cmp.val[i]+=carries;rent=1;&#125; else rent=0; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator *(const int &amp;obj)const&#123; // 高精度 ×低精度 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0]; // 进位 long long add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/carries; cmp.val[i]=cmp.val[i]%carries; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%carries; add/=carries; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator *(const largenum &amp;obj)const&#123; // 高精度 ×高精度 // 对于高精度数 a 和高精度 b // 这个算法不能写成 a=a*b largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/carries; cmp.val[i+j-1]=cmp.val[i+j-1]%carries; &#125; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator /(const int &amp;obj)const&#123; // 高精度 ÷低精度 largenum cmp; memset(cmp.val,0,sizeof(cmp.val)); Int64 pos=val[0],div=0; for(int i=pos;i&gt;=1;i--)&#123; cmp.val[i]=(div*carries+val[i])/obj; div=(div*carries+val[i])%obj; &#125; while(cmp[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; int operator %(const int &amp;obj)const&#123; // 高精度 % 低精度 int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--) div=(div*carries+val[i])%obj; return div; &#125; largenum operator /(const largenum &amp;obj)const&#123; // 高精度 ÷高精度 largenum cmp,t_cmp; memset(cmp.val,0,sizeof(cmp.val)); memset(t_cmp.val,0,sizeof(t_cmp.val)); Int64 pos=val[0]; cmp.val[0]=1;cmp.val[1]=0; t_cmp=cmp; if((*this)&lt;obj) return cmp; // 小于除数直接返回 0 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*carries; t_cmp.val[1]=val[i]; int k=0; while(t_cmp&gt;obj || t_cmp==obj) &#123; t_cmp=t_cmp-obj; k++; &#125; cmp.val[i]=k; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; largenum operator %(const largenum &amp;obj)const&#123; // 高精度 % 高精度 largenum t_cmp; memset(t_cmp.val,0,sizeof(t_cmp.val)); Int64 pos=val[0]; t_cmp.val[0]=1;t_cmp.val[1]=0; if((*this)&lt;obj) return (*this); // 小于除数直接返回本身 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*carries; t_cmp.val[1]=val[i]; while(t_cmp&gt;obj || t_cmp==obj) t_cmp=t_cmp-obj; &#125; return t_cmp; &#125; void lgnsqrt()&#123; largenum one=&#123;&#123;1,1&#125;&#125;; largenum l=&#123;&#123;1,1&#125;&#125;; largenum r=*this; largenum cmp=*this; largenum mid=(l+r)/2; largenum tmp=mid*mid; while(l&lt;r)&#123; if(tmp&lt;cmp||tmp==cmp)&#123; l=mid+one; &#125; else r=mid; mid=(l+r)/2; tmp=mid*mid; &#125; if(mid*mid&gt;cmp&amp;&amp;((mid-one)*(mid-one)&lt;cmp||(mid-one)*(mid-one)==cmp)) mid=mid-one; for(int i=0;i&lt;=mid.val[0];i++)&#123; val[i]=mid.val[i]; &#125; &#125; 在这一段高精度的最后是自己写的二分开方这里就按正常的开方来就可以了，因为是向下取整，所以呢我就在在后面加了一个if语句。那么，That’s all.","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"关于质数和约数的一个小总结","slug":"关于质数和约数的总结","date":"2021-09-05T02:20:21.030Z","updated":"2021-09-05T02:20:21.348Z","comments":true,"path":"2021/09/05/关于质数和约数的总结/","link":"","permalink":"http://example.com/2021/09/05/%E5%85%B3%E4%BA%8E%E8%B4%A8%E6%95%B0%E5%92%8C%E7%BA%A6%E6%95%B0%E7%9A%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"约数定义​ 若整数n能够整除d，则d是n的约数，n是d的倍数，记作d|n 基本性质 唯一分解定理：任何一个正整数都可以分解为$p_1^{b_1}*p_2^{b_2}*p_3^{b_3}……p_n^{b_n}$（为了后面的叙述，若$i&lt;j,p_i&lt;p_j$） 它的正约数个数：$\\prod_{i=1}^{m}(b_i+1)$ $lcm(a,b)gcd(a,b)=ab$ 基本算法和板子 试除法： 用来求解一个数的正约数集合，时间复杂度：$\\Theta(\\sqrt n)$ 更相减损术： 当使用高精度的时候，使用它来求解最大公约数很方便 123int gcd(int x,int y)&#123; return (!y)?x:gcd(y,x-y);&#125; 辗转相除法：比更相减损术更快 123int gcd(int x,int y)&#123; return (!y)?x:gcd(y,x%y);&#125; 当然了，有一个速度更快的二进制版本 12345678910111213inline int gcd(int x,int y)&#123; int i,j; if(x==0)return y; if(y==0)return x; for(i=0;(x&amp;1)==0;i++)x&gt;&gt;=1; for(j=0;(y&amp;1)==0;j++)y&gt;&gt;=1; if(i&gt;j)i=j; while(true)&#123; if(x&lt;y)&#123;x^=y;y^=x;x^=y;&#125; if(!(x%=y))return y&lt;&lt;i; while(!(x&amp;1))x&gt;&gt;=1; &#125;&#125; 素数定义这个很简单吧，小学就学过的 基本定理 唯一分解定理（同上） 威尔逊定理：如果$(p-1)!\\equiv-1(mod\\ p)$，则p为质数 质数有无穷多个 欧拉定理这些的就放在同余那一块来讲了 数论的板子都在这里面来看吧 数论板子","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"质数","slug":"质数","permalink":"http://example.com/tags/%E8%B4%A8%E6%95%B0/"},{"name":"约数","slug":"约数","permalink":"http://example.com/tags/%E7%BA%A6%E6%95%B0/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"}]},{"title":"矩阵","slug":"矩阵","date":"2021-09-05T02:20:20.988Z","updated":"2021-09-05T02:20:21.414Z","comments":true,"path":"2021/09/05/矩阵/","link":"","permalink":"http://example.com/2021/09/05/%E7%9F%A9%E9%98%B5/","excerpt":"","text":"用矩阵来祭我的第一篇博客感谢朱枫苓，WYX大佬为本人博客的建设做出的巨大贡献再次特别发出大佬博客的地址，表示我对与朱枫苓大佬的敬佩大佬自己的博客大佬在博客园的博客 好了，来看看矩阵 加法。只有同型的矩阵才可以相加，对应的位置上面相加就可以了。 数乘。把一个矩阵拿来和一个常数相乘，每一位都乘上来就行了，没有什么多的了。 倒置。直接行列倒过来就行了。还有一个定理：A*B的倒置等于A的倒置乘以B的倒置 然后就到了重点了 乘法矩阵乘法$A*B$ 可以做乘法的条件是A的列数要等于B的行数 然后呢乘法就是A的第几行和B的第几列对应相乘累加就是答案第几几的位置的值了。这个矩阵啊，作用非常的大，配合快速幂，可以加速状态转移，实现很多的骚操作。 下面让我们看看矩阵是如何骚操作斐波那契数列的 题目背景 大家都知道，斐波那契数列是满足如下性质的一个数列： $f(1) = 1$ $f(2) = 1$ $f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数)$ 题目描述 请你求出$ f(n) mod 1000000007$ 的值。 设一个有两个元素的$1*2$的矩阵 $A[n]=[f(n),f(n-1)]$然后这样的话$A[n-1]=[f(n-1),f(n-2)]$那么的设话 $A[n-1]*B=A[n]$ ,易得 B为$$\\begin{bmatrix}1&amp;1\\1&amp;0\\end{bmatrix}$$ 则 $f(n)$ 为 $A[1][1]*(B 的 n 次方时的第二个元素）$ 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Matrix F[n]=&#123;f[n],f[n-1]&#125;//A=&#123;1,1// 1,0&#125;#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll A[2][2];const ll Mod=1000000007;void mul(ll *a,ll b[2][2])&#123; ll tmp[2]; memset(tmp,0,sizeof(tmp)); for(int j=0;j&lt;=1;j++)&#123; for(int k=0;k&lt;=1;k++)&#123; (tmp[j]+=(a[k]*b[k][j]))%=Mod; &#125; &#125; memcpy(a,tmp,sizeof(tmp));&#125;void mulsel(ll (*f)[2])&#123; ll tmp[2][2]; memset(tmp,0,sizeof(tmp)); for(int i=0;i&lt;=1;i++)&#123; for(int j=0;j&lt;=1;j++)&#123; for(int k=0;k&lt;=1;k++)&#123; (tmp[i][j]+=(f[i][k]*f[k][j]))%=Mod; &#125; &#125; &#125; memcpy(f,tmp,sizeof(tmp));&#125;ll pw(ll b)&#123; ll ans[2]=&#123;1,0&#125;; while(b)&#123; if(b&amp;1)mul(ans,A); mulsel(A); b&gt;&gt;=1; &#125; return ans[1];&#125; int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif A[0][0]=1;A[0][1]=1; A[1][0]=1;A[1][1]=0; ll k; cin&gt;&gt;k; printf(&quot;%lld&quot;,pw(k));//快速幂 return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"Catalan Number入门","slug":"卡特兰数","date":"2021-09-05T02:20:20.864Z","updated":"2021-09-05T02:20:21.357Z","comments":true,"path":"2021/09/05/卡特兰数/","link":"","permalink":"http://example.com/2021/09/05/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"定义这个cn啊，是组合数学里面经常会用到的东西，比如说： 让你算算二叉树的形态 又让你算算合法的括号序列 又或者让你算算出入栈的合法顺序 还可能让你去说说把多边形割成三角形方法 综上所述就是18年初赛的第8题 于是有的人弄出来了它的式子我们设为f(n),那么有$$f(n)=\\sum^{n-1}{i=0}f(i)\\cdot f(n-i-1)$$当然人们并不会满足一个式子，于是就有了第二个$$f(n)=f(n-1)\\cdot \\frac{4n-2}{n+1}$$但是因为我们没有通项式，所以必须要一个一个的算与是通项式就来了$$f(n)=\\frac{C^{n}{2n}}{n+1}$$当然如果我们进行一点变换的话就可以得到它：$$f(n)=C^{n}{2n}-C^{n-1}{2n}$$ 这个式子是一个好式子，面对问题是往往很容易就可以化成这一个形式，然后就发现了这是卡特兰数的题 例题1.栈（洛谷P1044）洛谷P1044这一道题很容易就可以看出来这一个是Cn的模板题那么就是这样的了贴代码(用的是第二个式子) 12345678910111213141516171819//洛谷的卡特兰数模板题 #include&lt;bits/stdc++.h&gt;using namespace std;long long f[20];void getcn(int n)&#123; f[1]=1; for(int i=2;i&lt;=n;i++)&#123; f[i]=((4*i-2)*f[i-1])/(i+1); &#125; printf(&quot;%lld\\n&quot;,f[n]); return ;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); getcn(n); return 0; &#125; 2.矩阵（洛谷P1722）洛谷P1722这一道题啊，可以看出来是一道卡特兰数的题，要求我们去模100，那么向第一个式子那样没有除法，只有加和乘的方法自然就是首选了，既然如此就用第一种方法写Cn就行了 123456789101112131415161718192021//矩阵 洛谷P1722 #include&lt;bits/stdc++.h&gt;#define Mod 100using namespace std;int n;long long f[105];void solve()&#123; f[0]=f[1]=1; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i-1;j++)&#123; (f[i]+=f[j]*f[i-j-1])%=Mod; &#125; &#125; printf(&quot;%lld&quot;,f[n]); return;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); solve(); return 0;&#125; 3.树屋阶梯(洛谷P2532)洛谷P2532这一道题啊，首先你这么考虑，任意选中其中一阶阶梯，然后呢就把整个阶梯分成了它上面的阶梯和它右面的阶梯。每一阶阶梯都这么去考虑，写出整个式子就会发现是卡特兰数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194//洛谷P2532 树屋//这道题不得不用高精度了 #include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;struct Ln&#123; // 整数，最大可存储一万位数字 int val[maxn]; int operator [](const int &amp;ref)const&#123; return val[ref]; &#125; inline void Lin()&#123; // 读入 char S[maxn]; scanf(&quot;%s&quot;,S); memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125; inline void StrIn(char *S)&#123; memset(val,0,sizeof(val)); int lenS=strlen(S); val[0]=lenS; for(int i=lenS-1,j=1;i&gt;=0;i--,j++) val[j]=S[i]-&#x27;0&#x27;; &#125; inline void Lout()&#123; // 输出 for(int i=val[0];i&gt;=1;i--) putchar(val[i]+&#x27;0&#x27;); &#125; bool operator ==(const Ln &amp;obj)const&#123; // 判断是否等于 if(val[0]!=obj[0]) return false; for(int i=1;i&lt;=val[0];i++) if(val[i]!=obj[i]) return false; return true; &#125; bool operator &lt;(const Ln &amp;obj)const&#123; // 判断是否小于 if(val[0]&gt;obj[0]) return false; if((*this)==obj) return false; if(val[0]&lt;obj[0]) return true; for(int i=val[0];i&gt;=1;i--)&#123; if(val[i]&gt;obj[i]) return false; if(val[i]&lt;obj[i]) return true; &#125; return true; &#125; bool operator &gt;(const Ln &amp;obj)const&#123; // 判断是否大于 Ln cmp=*this; if(cmp &lt; obj || cmp == obj) return false; return true; &#125; Ln operator +(const Ln &amp;obj)const&#123; // 加法运算 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=max(val[0],obj[0]),add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]+obj[i]+add; add=cmp.val[i]/10; cmp.val[i]=cmp.val[i]%10; &#125; if(add&gt;0) cmp.val[++pos]=add; cmp.val[0]=pos; return cmp; &#125; Ln operator -(const Ln &amp;obj)const&#123; // 减法运算 只能减出正数 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0],rent=0; // rent 借位 for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]-obj[i]-rent; if(cmp.val[i]&lt;0) &#123;cmp.val[i]+=10;rent=1;&#125; else rent=0; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator *(const int &amp;obj)const&#123; // 高精度 ×低精度 // 对于高精度数 a 和低精度数 b // 这个算法可以写成 a=a^b Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0]; // 进位 long long add=0; for(int i=1;i&lt;=pos;i++)&#123; cmp.val[i]=val[i]*obj+add; add=cmp.val[i]/10; cmp.val[i]=cmp.val[i]%10; &#125; while(add&gt;0)&#123; cmp.val[++pos]=add%10; add/=10; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator *(const Ln &amp;obj)const&#123; // 高精度 ×高精度 // 对于高精度数 a 和高精度 b // 这个算法不能写成 a=a*b Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0]+obj[0]; for(int i=1;i&lt;=val[0];i++)&#123; for(int j=1;j&lt;=obj[0];j++)&#123; cmp.val[i+j-1]+=val[i]*obj[j]; cmp.val[i+j]+=cmp.val[i+j-1]/10; cmp.val[i+j-1]=cmp.val[i+j-1]%10; &#125; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator /(const int &amp;obj)const&#123; // 高精度 ÷低精度 Ln cmp; memset(cmp.val,0,sizeof(cmp.val)); int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--)&#123; cmp.val[i]=(div*10+val[i])/obj; div=(div*10+val[i])%obj; &#125; while(cmp[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; int operator %(const int &amp;obj)const&#123; // 高精度 % 低精度 int pos=val[0],div=0; for(int i=pos;i&gt;=1;i--) div=(div*10+val[i])%obj; return div; &#125; Ln operator /(const Ln &amp;obj)const&#123; // 高精度 ÷高精度 Ln cmp,t_cmp; memset(cmp.val,0,sizeof(cmp.val)); memset(t_cmp.val,0,sizeof(t_cmp.val)); int pos=val[0]; cmp.val[0]=1;cmp.val[1]=0; t_cmp=cmp; if((*this)&lt;obj) return cmp; // 小于除数直接返回 0 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*10; t_cmp.val[1]=val[i]; int k=0; while(t_cmp&gt;obj || t_cmp==obj) &#123; t_cmp=t_cmp-obj; k++; &#125; cmp.val[i]=k; &#125; while(cmp.val[pos]==0 &amp;&amp; pos&gt;1) pos--; cmp.val[0]=pos; return cmp; &#125; Ln operator %(const Ln &amp;obj)const&#123; // 高精度 % 高精度 Ln t_cmp; memset(t_cmp.val,0,sizeof(t_cmp.val)); int pos=val[0]; t_cmp.val[0]=1;t_cmp.val[1]=0; if((*this)&lt;obj) return (*this); // 小于除数直接返回本身 for(int i=pos;i&gt;=1;i--)&#123; t_cmp=t_cmp*10; t_cmp.val[1]=val[i]; while(t_cmp&gt;obj || t_cmp==obj) t_cmp=t_cmp-obj; &#125; return t_cmp; &#125;&#125;;Ln f[505]=&#123;&#123;1,1&#125;&#125;;int n;void solve()&#123; f[1]=f[0]; for(int i=2;i&lt;=n;i++)&#123; f[i]=(f[i-1]*(4*i-2))/(i+1); &#125; f[n].Lout();&#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); solve(); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"康托展开","slug":"康托展开","date":"2021-09-05T02:20:20.435Z","updated":"2021-09-05T02:20:21.045Z","comments":true,"path":"2021/09/05/康托展开/","link":"","permalink":"http://example.com/2021/09/05/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"按规矩，祭天 今天加了的内容是康托展开，因为时间原因就不附上题目了而且我也还没有做题，就直接来看内容了 定义它是用来求解一个数列的全排列下面的结果的序号的问题$$∑(pi*(n-i)!)(i是第几个数字)$$ 逆推那么就是根据序号求结果了，方法是类似的首先是把1~n-1的阶乘都算出来，然后呢每一位也是倒着回去，用序号整除这里对应的阶乘，然后看看在剩下的没有选的数字当中哪一个的比它小的数字的个数等于这一个结果就行了 比较简洁，大概就是我对此的理解了 最后还有一个逆元的求法这个求法的推导自己去推，书上也是有的（数学一本通P17）那么我就附上一份代码就行了 1234int inv(int n,int p)&#123; if(n==1)return 1; else return -(p/i)*inv(p%n,p);&#125; 到此为止了。","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"康托展开","slug":"康托展开","permalink":"http://example.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"}]},{"title":"洛谷P2421题解","slug":"洛谷P2421","date":"2021-09-05T02:20:20.416Z","updated":"2021-09-05T02:20:21.007Z","comments":true,"path":"2021/09/05/洛谷P2421/","link":"","permalink":"http://example.com/2021/09/05/%E6%B4%9B%E8%B0%B7P2421/","excerpt":"","text":"洛谷P2421这一道题目是一道同余的题目，进行推理后用扩展欧几里得就可以了，解析我写在了代码里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define Int64 long long#define maxn 17using namespace std;Int64 c[maxn],p[maxn],l[maxn];//出生地，速度，生命长度 int Extend_gcd(Int64 a,Int64 b,int &amp;x,int &amp;y)&#123; //ax+by=gcd(a,b); if(!b)&#123; x=1;y=0; return a; &#125; int d=Extend_gcd(b,a%b,x,y); int tmp=x; x=y;y=tmp-a/b*y; return d;&#125;int n;bool check(int pos)&#123; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; int x,y,t; t=Extend_gcd((p[i]-p[j]),pos,x,y); //t=gcd((p[i]-p[j]),pos) if((c[j]-c[i])%t)continue; /* *因为解的方程是(p[i]-p[j])x+pos*y =c[j]-c[i]; *如果说不整除，那么就没有解 */ Int64 tmp=pos/t; //用pos除以t，得到每一次 x改变多少 tmp=abs(tmp); //保证tmp是正数 x=x%tmp*((c[j]-c[i])/t)%tmp; ((x%=tmp)+=tmp)%=tmp; //对解进行修正 if(!x)x+=tmp; if(x&lt;=min(l[j],l[i]))return false ; &#125; &#125; return true ;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); Int64 pos=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;c[i]&gt;&gt;p[i]&gt;&gt;l[i]; pos=max(pos,c[i]);//寻找最大的序号 &#125; while(true)&#123; if(check(pos))&#123; printf(&quot;%lld&quot;,pos); break; &#125; pos++; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"}]},{"title":"洛谷P3807卢卡斯定理","slug":"洛谷P3807卢卡斯定理","date":"2021-09-05T02:20:20.209Z","updated":"2021-09-05T02:20:20.954Z","comments":true,"path":"2021/09/05/洛谷P3807卢卡斯定理/","link":"","permalink":"http://example.com/2021/09/05/%E6%B4%9B%E8%B0%B7P3807%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/","excerpt":"","text":"这是一道模板题 这里是题目 洛谷P3807卢卡斯定理及题目的阐释卢卡斯定理是用来解决一大很大的组合数来和一个质数求余的问题，它的定义如下如果$p$为素数，设$n=sp+q$,$m=tp+r$则:$$C^{sp+q}_{tp+r}\\equiv C^s_t*C^q_r(mod\\ p)$$ 那么来看看题。首先看这个数据范围，就知道可以用int的类型解决个屁，就是int害的我错了好多次long long 的数据类型解决，这个数据看起来好像是只有 10的5次方,但是中间这么多的计算，突然的就给我溢出了我靠着ZFN大佬的数据测试发现负数才发现的。 1234567891011long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125; ​ 这一段是求组合的函数，拿出来单独讲一讲​ 因为这里面的参数传过来的时候都是已经和p求过余了的，而且p在题目中说了的，是一个质数所以说这里的$n$,$m$都是和$p$互质的。​ 因为公式里面要除掉$m!$，同时有要去对p取模，所以考虑用它的逆元乘来代替用它来除而根据费马小定理可以知道它的逆元是它的$p-2$方 Code那么综上，加上以个快速幂就可以解出这道题了 123456789101112131415161718192021222324252627282930313233343536373839404142434445//洛谷P3807 Lucas 模板题 #include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,m,p;long long qkpow(long long b,int p,int mod)&#123; long long res=1; while(p)&#123; if(p&amp;1)&#123; (res*=b)%=mod; &#125; (b*=b)%=mod; p&gt;&gt;=1; &#125; return res;&#125;long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125;long long Lucas(int n,int m,int p)&#123; if(m==0)return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); n+=m; cout&lt;&lt;Lucas(n,m,p)&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"Lucas","slug":"Lucas","permalink":"http://example.com/tags/Lucas/"}]},{"title":"你往何处去-读后感","slug":"你往何处去-读后感","date":"2021-09-05T02:20:19.585Z","updated":"2021-09-05T02:20:20.391Z","comments":true,"path":"2021/09/05/你往何处去-读后感/","link":"","permalink":"http://example.com/2021/09/05/%E4%BD%A0%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"关于显克维奇​ 亨里克显克维奇，出生于十九世纪中叶的一个没落的地主家庭。中学毕业后进入了华沙高等学院进行学习。是波兰十九世纪的著名作家。人们评价他： 作品人物个性鲜明，情节引人入胜，语言优美流畅，深受群众欢迎，素有“波兰语言大师”之称。 ​ 他是最早被介绍到中国的波兰作家。鲁迅曾经翻译过他的短篇小说集。他的作品以炙热的爱国热情，波澜壮阔的战争场面，精致细腻的描写而令人赞叹。 ​ 显克维奇是一个波兰人，这是一个对于大多数人而言，十分陌生的国家，大多数对他的印象，应该就是德国入侵波兰，二战全面爆发和在拜仁慕尼黑踢球的波兰前锋莱万多夫斯基了。实际上关于波兰，有着很多值得一谈的地方，她的黄金自由制，萨尔马提亚主义，历史上著名的瓦尔纳十字军，1683年维也纳城下三千翼骑兵大破奥斯曼帝国十五万军队，以及对俄罗斯的入侵（值得一提的是，蒙古和波兰应当是唯二两个一度攻占了莫斯科的国家，拿破仑占领的莫斯科是俄罗斯人让的，蒙古是没有打进去，俄国人就投降了，而波兰则是在俄国王朝混乱时期攻入了莫斯科），与欧洲其他贵族截然不同的施拉赤塔。马克思曾经评价波兰是斗争的民族，认为波兰应当是实现共产主义的先驱（然而有趣的是，当1919年的时候，苏俄红军向着西方进军，准备进行世界革命，欧洲各国统治危在旦夕的时候，波兰人创造了维斯瓦河畔的奇迹，逼得苏俄人割地赔款） ​ 我们谈回到显克维奇身上来。他出身的年代，曾经一度称霸东欧的波兰已经被她曾经的附庸普鲁士，被她从奥斯曼帝国手中救下来的奥地利，以及宿敌俄国所瓜分殆尽。华沙起义的失败，更是给波兰民族的前程蒙上了一层阴影。俄国人的民族同化政策进一步加剧,上层贵族走向了对俄罗斯的妥协，而下层的民众则是看不到波兰民族的方向。 十九世纪六十年代末，一批受实证主义影响的知识分子便掀起了一场意识形态方面的斗争，他们反对旧的封建主义，主张实业救国……显克维奇虽然没有参与这场实证主义运动，但是却收到它的影响…… 显克维奇知道，在现实社会是很难找到希望和信心的。但是在波兰的历史上，却发生过伟大的事件，出现过伟大的人物，有过令人振奋的东西，伟大的性格，伟大的罪过和伟大的牺牲 ​ -《火与剑 林洪亮译本 译后前言》 ​ 显克维奇自七八十年代开始开始创作。他的哪一部《火与剑》，就是在那一个时间完成的。《火与剑》这一本书，是他历史小说三部曲的第一部。这也有可能是在中国，他最有名气的一部小说。因为在2013年的时候，$taleworlds$ 的骑马与砍杀里面增加了一部以这本书为名的资料片。相信很多人因为这知道了显克维奇。至少我是因此知道的。我必须要说一下，林洪亮翻译的火与剑真的是精彩绝伦，超乎想象，这一本书理所应当有更多的人来读。它受到的关注太少了。 ​ 而我所要说的《你往何处去》，则是他在1895年创作的，一部颇具异域风情的小说。 关于这本书​ 精彩绝伦，妙不可言，难以想象，震撼人心。我认为这一本书很合口味。古罗马距离我们很遥远了，很多人提到她，都是感到无比地陌生。我喜欢罗马，但是我喜欢的，更多的是那一个东方的罗马，是那个君士坦丁堡作为首都的罗马帝国，是那一个和萨珊波斯鏖战百年，教化了斯拉夫人，抵挡了阿拉伯人入侵的罗马。而对于那一个古罗马，我也是感到陌生。 ​ 显克维奇的笔下，这个古老的国度仿佛就已经展现在了眼前。我看到了暴君尼禄的荒淫无道，恬不知耻，滑稽可笑，我看见了众多的大臣不过是腐败堕落的怕马屁之徒（想到了语文课上讲的，如果说这些人都是一群追逐利益的人，那么这个国家也就离灭亡不远了），我看见了那些见利忘义的小人，我看见了基督徒们不畏强权，坦然受死，我看见了一个叛徒的悔过和觉悟，我看见了一位信奉基督教的少女虔诚的信仰和自重，我看见了一个残忍的罗马贵族青年如何如何变成一位虔诚善良的基督徒，和另一人共渡难关。当我一页页翻完了这本书，我感觉好像在那一个世界活过了一般（因此我赶紧去玩了一把欧陆风云4的帝国风云mod，享受了罗马帝国征服蛮子的乐趣）。 ​ 在我看来，这本有着五个最为主要的人物，男主角维尼裘斯，女主角黎吉亚，维尼裘斯叔父斐特洛纽斯，罗马皇帝尼禄，希腊哲学家基罗。维尼裘斯的转变是作者花了大量篇幅描写的一处，也是相当精彩的一部分，最终终于在黎吉亚的影响下，成为了虔诚的基督徒。斐特洛纽斯，尼禄，基罗则是主要在推动剧情。基罗无论是在前期还是后期，他的作用都是非常明显，文章重大事件的推动，甚至翻转，都是少不了他的参与。他本人或许很难给读者留下很好的印象，但是我相信在竞技场他所做的事情，无疑震撼了无数人： ……他们没有在校，因为那个希腊人脸上的表情是那么令人害怕，就像是他自己被大火烧着了一般，那样的痛苦和害怕，他的脸已经扭曲得不成样子了，只见他猛地站了起来，向上伸展自己的胳膊，口中发出悲痛欲绝的圣耀魂，叫道：“主啊，宽恕我吧，戈劳库斯” …… “罗马的居民们，你们被骗了，我可以用我的性命担保，这里所有牺牲的人都是无辜的，并且我知道纵火的人，他就是——” ​ 他将自己的手指向皇帝。 ​ 我向这么精彩的场面，是显克维奇小说能够如此受到欢迎的原因。 ​ 我读完这个本书，良久不能平静，黎吉亚和维尼裘斯的爱情令人感慨万分。当我从书中走出的时候，我的的确确有一种重生之感。两个人的感情故事让我觉得真的是万分不易，心情也是有一些沉闷。闭上眼睛，我还能想起书中所描写的场面。显克维奇的小说真的是充满了魅力（就是现在网上买另外几本有一些贵，我三年前68买的火与剑小说现在涨了好多）。 或许，暂时就这么多可说的了吧","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"显克维奇作品选读","slug":"显克维奇作品选读","permalink":"http://example.com/tags/%E6%98%BE%E5%85%8B%E7%BB%B4%E5%A5%87%E4%BD%9C%E5%93%81%E9%80%89%E8%AF%BB/"}]},{"title":"排列组合复习","slug":"排列组合复习","date":"2021-09-05T02:20:18.890Z","updated":"2021-09-05T02:20:20.810Z","comments":true,"path":"2021/09/05/排列组合复习/","link":"","permalink":"http://example.com/2021/09/05/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"排列","slug":"排列","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://example.com/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"}]},{"title":"数论test","slug":"数论test","date":"2021-09-05T02:20:18.585Z","updated":"2021-09-05T02:20:19.593Z","comments":true,"path":"2021/09/05/数论test/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BAtest/","excerpt":"","text":"有趣的序列洛谷链接这一道题是一道卡特兰数的题，但是因为数据量以及要进行模运算的原因，要采用我先前博客中写到的通项式。当然因为不可以直接算阶乘，因此采取分解阶乘的方法转换成乘法。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define maxn 1000002#define Int64 long longusing namespace std;int primes[2*maxn];int sum[2*maxn];bool isp[2*maxn];int newp=0;void Eular_Sieve()&#123; for(int i=2;i&lt;2*maxn;i++)&#123; if(!isp[i])&#123; primes[++newp]=i; &#125; for(int j=1;j&lt;=newp&amp;&amp;primes[j]*i&lt;2*maxn;j++)&#123; isp[primes[j]*i]=true; if(!(i%primes[j]))break; &#125; &#125; return;&#125;Int64 qkpow(int a,int b,int p)&#123; //a的b次方mod p if(b==1)return a; if(b%2)&#123; Int64 t=qkpow(a,b/2,p); t=t*t%p; t=t*a%p; return t; &#125; else &#123; Int64 t=qkpow(a,b/2,p); t=t*t%p; return t; &#125;&#125;int n,p;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); Eular_Sieve(); for(int i=1;i&lt;=newp;i++)&#123; Int64 t=primes[i]; Int64 cnt1=0,cnt2=0,cnt3=0; while(t&lt;=2*n)&#123; cnt1+=(2*n/t);cnt2+=((n+1)/t);cnt3+=(n/t); t*=primes[i]; &#125; sum[i]=cnt1-cnt2-cnt3; &#125; Int64 ans=1; for(int i=1;i&lt;=newp;i++)&#123; if(sum[i])&#123; (ans*=qkpow(primes[i],sum[i],p))%=p; &#125; &#125; printf(&quot;%lld&quot;,ans); return 0; &#125; 打气球这道题我就不给网址了，yzoj上面最后一页找 题目描述 Descrition 周末何老板到磁器口游玩。街边有小贩在组织一种打气球游戏，何老板很感兴趣。 店家立了一块布，布上画了N*N的方格，有的方格里挂上了气球，有的没有。 游戏规则如下： 第1步.观察。如果每一行都至少有一个方格没有气球，并且每一列都至少有一个方格没有气球，游戏结束。否则进行第2步。 第2步.抛骰子。店家拿出一个特制的骰子，该骰子有N个面，上面依次有1到N这N 个数字。玩家先后抛两次骰子，设第一次抛出的数字为x，设第二次抛出的数字为y (注：抛出的数字是随机的)。 第3步.打气球。若坐标为(x,y)的格子里有气球，玩家必须将其打爆。子弹1块钱一发。 如果该格子没有气球，忽略该格子，玩家不用开枪，但玩家也需要支付给店家1块钱。 第4步.继续。执行第1步。 何老板是个神枪手，他能做到百发百中。他想你帮他算算，对于当前给出的这局游戏，预计要花多少钱才能结束。 Input 第一行，两个整数N和M，N表示方格的尺寸,M表示游戏开始时，有M个格子里是没有气球的。 接下来M行，每行两个整数x,y,表示坐标为x,y的格子里没有气球。 Output 一行，一个实数，完成游戏预计花费，保留2个小数位。 Sample Input 1235 2 2 3 4 1 Sample Output 111.77 如果你想看更多的样例输出，可以去WYX大佬的博客 分析这一道题啊，实际上啊，就是一道期望的题，如果你点开了上面的那一个链接，多半也看见了YB说的话了吧，那么接下来要做的事情就是找出递归的关系首先，我们都知道每一个格子概率为$\\frac{1}{n^2}$我们设有$r$行已经打掉，$c$列已经打掉，函数为$f[r][c]=……$那么分类讨论1.如果说没有抽到有气球的地方，那么就是他自己乘上没有气球的地方的概率2.如果说打掉的地方只能消除行，那么就是乘上$f[r-1][c]$以及这些地方的概率，只能消除列同理3.如果可以同时消去的话，那么就可以类比上面的，写出式子来。4.当然最后你应该加上1，因为每打一次收费1 式子和化简如下$$f[r][c]=\\\\ \\frac{f[r-1][c]\\times r(n-c)+f[r][c-1]\\times c(n-r)+f[r-1][c-1]\\times r\\times c+f[r][c]\\times(n-r)(n-c)+n^2}{n^2(n-r)(n-c)}$$好了，既然已经知道了式子，那么就可以比较容易的做出来了，至于边界，那你也可以自己推出来，你可以选择两种方法，$dfs$ or$ dp$我的代码里面把$dfs$的注释掉了 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define maxn 2003using namespace std;double f[maxn][maxn];bool row[maxn],col[maxn];//行 列 int n,m;double dfs(int r,int c)&#123; double ans=0; if(!r&amp;&amp;!c)return 0; if(f[r][c]!=-1)return f[r][c]; if(r)ans+=dfs(r-1,c)*r*(n-c); if(c)ans+=dfs(r,c-1)*c*(n-r); if(r&amp;&amp;c)ans+=dfs(r-1,c-1)*r*c; return f[r][c]=(double)(ans+n*n)/(n*(c+r)-c*r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int r=n,c=n; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; if(!row[x])r--,row[x]=true; if(!col[y])c--,col[y]=true; &#125; /*for(int i=0;i&lt;=r;i++)&#123; for(int j=0;j&lt;=c;j++)f[i][j]=-1; &#125; dfs(r,c);*/ for(int i=1;i&lt;=n;i++)&#123; f[i][0]=f[i-1][0]+n/(i+0.0); f[0][i]=f[0][i-1]+n/(i+0.0); &#125; for(int i=1;i&lt;=r;i++)&#123; for(int j=1;j&lt;=c;j++)&#123; double tmp=f[i-1][j]*i*(n-j)+f[i][j-1]*(n-i)*j+f[i-1][j-1]*i*j+n*n; f[i][j]=tmp/(n*(i+j)-i*j); &#125; &#125; printf(&quot;%.2lf&quot;,f[r][c]); return 0;&#125; 还有一道题，不过比较水，居然用暴力枚举就可以做出来了，早知道我当时就直接枚举了，题目与韩信点兵类似","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"}]},{"title":"数论题目两道","slug":"数论的两道题","date":"2021-09-05T02:20:17.380Z","updated":"2021-09-05T02:20:19.565Z","comments":true,"path":"2021/09/05/数论的两道题/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%A4%E9%81%93%E9%A2%98/","excerpt":"","text":"错位排列这是一道水题，名字就直接告诉了题的内容和做题的方法，那么直接使用公式就可以了 12345678910111213141516171819202122232425262728//错排问题//就是不可以放在自己原来的位置上 //那么直接根据公式来就可以了//D=n!*(1-1/1!+1/2!+...) #include&lt;bits/stdc++.h&gt;using namespace std;long long fact[15];inline void init()&#123; fact[0]=1; for(int i=1;i&lt;=12;i++)fact[i]=fact[i-1]*i;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif init(); long long res; int n; scanf(&quot;%d&quot;,&amp;n); res=fact[n]; double tmp=1; for(int i=1;i&lt;=n;i++)&#123; tmp+=(pow(-1,i)/(fact[i]+0.0)); &#125; printf(&quot;%.0lf\\n&quot;,res*tmp); return 0;&#125; 计数器大概就是统计1~n中每一个数字出现了多少次。有10^9的数量级，所以不可以枚举的。因此要采取把每一位的数字分开来进行计算，即分解每一位，然后这一位前面的数字乘以这一位的权值(它在十的第几位，权值就是十的第几次方)，如果说这一位数字大于我们统计的数字，那么还可以再加上一次权值，而如果等于，则应该加上它后面的位数组成的数字+1，+1是因为后面的组成的还有全0。比如2533，再统计5时，统计到第三位，因为这这一位等于5，后面的位数组成的数字是33，但是漏了2500，所以要+1(注意0要进行特殊的判定，因为0在最前面是不符合计数的规则的)。那么代码如下洛谷的链接 123456789101112131415161718192021222324252627282930313233343536//计数器 #include&lt;bits/stdc++.h&gt;using namespace std;int data[11];void calc(int num,int tot)&#123; int cnt=0,k=1,upp,low,now; int tmp=tot; while(k&lt;=tot)&#123; upp=tot/(k*10); low=tot%k; now=tmp%10; cnt+=(upp*k); if(now&gt;num)cnt+=k; if(now==num)cnt+=(low+1); if(num==0)cnt-=k; k*=10; tmp/=10; if(tmp&lt;10&amp;&amp;num==0)break; &#125; data[num]=cnt;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); #endif memset(data,0,sizeof(data)); int n; cin&gt;&gt;n; for(int i=0;i&lt;=9;i++)&#123; calc(i,n); &#125; for(int i=0;i&lt;=9;i++)printf(&quot;%d\\n&quot;,data[i]); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"排列组合","slug":"排列组合","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"数论的板子","slug":"数论的一些板子","date":"2021-09-05T02:20:17.371Z","updated":"2021-10-26T06:08:24.900Z","comments":true,"path":"2021/09/05/数论的一些板子/","link":"","permalink":"http://example.com/2021/09/05/%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%BF%E5%AD%90/","excerpt":"","text":"辗转相除法原始版本123inline int gcd(x,y)&#123; return (y==0)?x:gcd(y,x%y); &#125; 高级版本123456789101112inline void gcd(int x,int y)&#123; int i,j; if(!x)return y;if(!y)return x; for(i=0;!(x&amp;1);i++)x&gt;&gt;=1; for(j=0;!(j&amp;1);j++)j&gt;&gt;=1; i=min(i,j); while(true)&#123; if(x&lt;y)&#123;x^=y;y^=x;x^=y;&#125; if(!(x-=y))return y&lt;&lt;i;//这里也可以减法改成模 while(!(x&amp;1))x&gt;&gt;=1;//消除所有的2 &#125;&#125; 扩展欧几里得123456int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123;x=1;y=0;return a;&#125; int gcd=exgcd(b,a%b,x,y); int t=x;x=y;y=t-b/a*y; return gcd;&#125; 逆元12345int inv(int n,int p)&#123; //这里面求的是n在mod p情况下的逆元 if(n==1)return 1; else return -(p/n)*inv(p%n,p);&#125; 欧拉筛1234567891011int prm[maxn],cnt=0;bool isp[maxn]=&#123;1,1&#125;;//记录哪一些数不是质数void Eular_Sieve()&#123; for(int i=2;i&lt;maxn;i++)&#123; if(!isp[i])prm[++cnt]=i; for(int j=1;j&lt;cnt and i*prm[j]&lt;maxn;j++)&#123; isp[i*prm[j]]=true; if(!(i%prm[j]))break; &#125; &#125;&#125; 欧拉函数12345678910111213141516int prm[maxn],phi[maxn],cnt=0;bool isp[maxn]=&#123;1,1&#125;;//记录哪一些数不是质数void Eular_Sieve()&#123; phi[1]=1; for(int i=2;i&lt;maxn;i++)&#123; if(!isp[i])prm[++cnt]=i,phi[i]=i-1;//质数的phi值等于他自己减去1 for(int j=1;j&lt;cnt and i*prm[j]&lt;maxn;j++)&#123; isp[i*prm[j]]=true; if(!(i%prm[j]))&#123; phi[i*prm[j]]=phi[i]*prm[j] break; &#125; else phi[i*prm[j]]=phi[i]*(prm[j]-1); &#125; &#125;&#125; Lucas非递归形式 12345678910int Lucas(int n,int m,int p)&#123; int res=1,a,b; while(n&amp;&amp;m)&#123; int a=n%p,b=b%p; if(a&lt;b)return 0; (res*=C(a,b,p))%=p; n/=p;m/=p; &#125; return res;&#125; 递归形式 1234567891011121314151617181920212223242526long long qkpow(long long b,int p,int mod)&#123; long long res=1; while(p)&#123; if(p&amp;1)&#123; (res*=b)%=mod; &#125; (b*=b)%=mod; p&gt;&gt;=1; &#125; return res;&#125;long long C(int n,int m,int p)&#123; if(n&lt;m)return 0; if(n==m)return 1; if(m&gt;n-m)m=n-m;//约掉 long long s1=1,s2=1; for(int i=0;i&lt;m;i++)&#123; s1=s1*(n-i)%p; s2=s2*(i+1)%p; &#125; return s1*qkpow(s2,p-2,p)%p;&#125;long long Lucas(int n,int m,int p)&#123; if(m==0)return 1; return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125; Catalan Number123456f[0]=1for(int i=1;i&lt;=N;i++)&#123; for(int j=0;j&lt;i;j++)&#123; f[i]=f[j]*f[i-1-j]; &#125;&#125; 1234f[0]=1;for(int i=1;i&lt;=N;i++)&#123; f[i]=((4*i-2)*f[i-1])/(i+1);&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://example.com/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://example.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"同余总结","slug":"同余总结","date":"2021-09-05T02:20:17.351Z","updated":"2021-09-05T02:20:18.864Z","comments":true,"path":"2021/09/05/同余总结/","link":"","permalink":"http://example.com/2021/09/05/%E5%90%8C%E4%BD%99%E6%80%BB%E7%BB%93/","excerpt":"","text":"同余定义若对于$a,b$两个整数，除以$m$的余数相等，则称$a$,$b$模$m$同余，记作$a\\equiv b(mod\\ m)$ 基本定理和性质 逆元：若$a*x\\equiv 1(mod\\ p)$,$a$,$b$互质,则称x是a的逆元，记为$a^{-1}$ 欧拉定理：若$a$,$m$互质，则$a^{\\phi(m)}\\equiv 1(mod \\ m)$ 扩展欧拉定理： $a^b\\equiv a^{b\\ mod\\ \\phi(m)+\\phi(m)}(mod\\ m)$ 贝祖定理：对于任意的整数$a,b,\\exists x,y,$使得$ax+by=gcd(a,b)$ 对于方程$ax+by=c$有整数解，当且仅当$gcd(a,b)|c$ 运用和板子 扩展欧几里得算法：可以用来解决线性的同余方程 逆元：可以用来解决有除法有需要取模的问题 欧拉定理：可以通过欧拉函数来进行降幂操作 板子仍然是去数论板子那一篇博客里面来看","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"}]},{"title":"对于质数知识的复习","slug":"质数复习","date":"2021-09-05T02:20:17.339Z","updated":"2021-09-05T02:20:20.181Z","comments":true,"path":"2021/09/05/质数复习/","link":"","permalink":"http://example.com/2021/09/05/%E8%B4%A8%E6%95%B0%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"Problem List洛谷4161 洛谷2926 洛谷4397","categories":[{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"}]}],"categories":[{"name":"洛谷练习题","slug":"洛谷练习题","permalink":"http://example.com/categories/%E6%B4%9B%E8%B0%B7%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"杂项","slug":"杂项","permalink":"http://example.com/categories/%E6%9D%82%E9%A1%B9/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"图论","slug":"图论","permalink":"http://example.com/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"},{"name":"周记","slug":"周记","permalink":"http://example.com/categories/%E5%91%A8%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LG训练题","slug":"LG训练题","permalink":"http://example.com/categories/LG%E8%AE%AD%E7%BB%83%E9%A2%98/"},{"name":"数论","slug":"数论","permalink":"http://example.com/categories/%E6%95%B0%E8%AE%BA/"},{"name":"基础算法","slug":"基础算法","permalink":"http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ST表","slug":"ST表","permalink":"http://example.com/tags/ST%E8%A1%A8/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"逆序对数","slug":"逆序对数","permalink":"http://example.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/"},{"name":"日记","slug":"日记","permalink":"http://example.com/tags/%E6%97%A5%E8%AE%B0/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"2-SAT","slug":"2-SAT","permalink":"http://example.com/tags/2-SAT/"},{"name":"染色法","slug":"染色法","permalink":"http://example.com/tags/%E6%9F%93%E8%89%B2%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"概率期望","slug":"概率期望","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"主席树","slug":"主席树","permalink":"http://example.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"dp","slug":"dp","permalink":"http://example.com/tags/dp/"},{"name":"dfs序","slug":"dfs序","permalink":"http://example.com/tags/dfs%E5%BA%8F/"},{"name":"fhq_treap","slug":"fhq-treap","permalink":"http://example.com/tags/fhq-treap/"},{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"SPFA","slug":"SPFA","permalink":"http://example.com/tags/SPFA/"},{"name":"SLF优化","slug":"SLF优化","permalink":"http://example.com/tags/SLF%E4%BC%98%E5%8C%96/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://example.com/tags/CDQ%E5%88%86%E6%B2%BB/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"生活","slug":"生活","permalink":"http://example.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://example.com/tags/Tarjan/"},{"name":"期望","slug":"期望","permalink":"http://example.com/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"K-D tree","slug":"K-D-tree","permalink":"http://example.com/tags/K-D-tree/"},{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"区间dp","slug":"区间dp","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4dp/"},{"name":"背包问题","slug":"背包问题","permalink":"http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"群论","slug":"群论","permalink":"http://example.com/tags/%E7%BE%A4%E8%AE%BA/"},{"name":"Polya定理","slug":"Polya定理","permalink":"http://example.com/tags/Polya%E5%AE%9A%E7%90%86/"},{"name":"搬运自旧博客","slug":"搬运自旧博客","permalink":"http://example.com/tags/%E6%90%AC%E8%BF%90%E8%87%AA%E6%97%A7%E5%8D%9A%E5%AE%A2/"},{"name":"博弈论","slug":"博弈论","permalink":"http://example.com/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"SG函数","slug":"SG函数","permalink":"http://example.com/tags/SG%E5%87%BD%E6%95%B0/"},{"name":"递推","slug":"递推","permalink":"http://example.com/tags/%E9%80%92%E6%8E%A8/"},{"name":"二分图","slug":"二分图","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"质数","slug":"质数","permalink":"http://example.com/tags/%E8%B4%A8%E6%95%B0/"},{"name":"约数","slug":"约数","permalink":"http://example.com/tags/%E7%BA%A6%E6%95%B0/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"欧拉筛","slug":"欧拉筛","permalink":"http://example.com/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/"},{"name":"Catalan Number","slug":"Catalan-Number","permalink":"http://example.com/tags/Catalan-Number/"},{"name":"康托展开","slug":"康托展开","permalink":"http://example.com/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"},{"name":"同余","slug":"同余","permalink":"http://example.com/tags/%E5%90%8C%E4%BD%99/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://example.com/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"},{"name":"Lucas","slug":"Lucas","permalink":"http://example.com/tags/Lucas/"},{"name":"显克维奇作品选读","slug":"显克维奇作品选读","permalink":"http://example.com/tags/%E6%98%BE%E5%85%8B%E7%BB%B4%E5%A5%87%E4%BD%9C%E5%93%81%E9%80%89%E8%AF%BB/"},{"name":"排列","slug":"排列","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97/"},{"name":"组合","slug":"组合","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88/"},{"name":"斯特林数","slug":"斯特林数","permalink":"http://example.com/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"排列组合","slug":"排列组合","permalink":"http://example.com/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://example.com/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://example.com/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]}